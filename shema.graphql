schema {
  query: MainQuery
  mutation: MainMutations
}

"""
The `@defer` directive ma2 be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """Deferred when true."""
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """The initial elements that shall be send down to the consumer."""
  initialCount: Int!

  """Streamed when true."""
  if: Boolean!
) on FIELD

directive @authorize(
  """
  The name of the authorization policy that determines access to the annotated resource.
  """
  policy: String

  """Roles that are allowed to access the annotated resource."""
  roles: [String!]

  """
  Defines when when the resolver shall be executed.By default the resolver is
  executed after the policy has determined that the current user is allowed to
  access the field.
  """
  apply: ApplyPolicy! = BEFORE_RESOLVER
) on SCHEMA | OBJECT | FIELD_DEFINITION

"""
The `@specifiedBy` directive is used within the type system definition language
to provide a URL for specifying the behavior of custom scalar definitions.
"""
directive @specifiedBy(
  """
  The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types.
  """
  url: String!
) on SCALAR

type AcceptanceActQueries {
  acceptanceActDetails(date: DateTime!, firmId: String, insuranceCompanyId: String): [KeyValuePairOfStringAndString!]
}

type Address {
  index: String
  house: String
  housing: String
  apartment: String
  latitude: Decimal
  longitude: Decimal
  locationId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  location: Location
}

type AddressCollectionSegment {
  items: [Address]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input AddressFilterInput {
  and: [AddressFilterInput!]
  or: [AddressFilterInput!]
  index: StringOperationFilterInput
  house: StringOperationFilterInput
  housing: StringOperationFilterInput
  apartment: StringOperationFilterInput
  latitude: ComparableNullableOfDecimalOperationFilterInput
  longitude: ComparableNullableOfDecimalOperationFilterInput
  locationId: StringOperationFilterInput
  location: LocationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input AddressInput {
  index: String
  house: String
  housing: String
  apartment: String
  latitude: Decimal
  longitude: Decimal
  locationId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type AddressMutation {
  add(model: [AddressInput]): [Address]
  update(model: [AddressInput]): [Address]
  addOrUpdate(model: [AddressInput]): [Address]
  delete(model: [AddressInput]): [Address]
}

type AddressQuery {
  all(skip: Int, take: Int, where: AddressFilterInput, order: [AddressSortInput!]): AddressCollectionSegment
  userInfo(model: AddressInput): UserInfo
  getByKeys(id: String): [Address]
}

input AddressSortInput {
  index: SortEnumType
  house: SortEnumType
  housing: SortEnumType
  apartment: SortEnumType
  latitude: SortEnumType
  longitude: SortEnumType
  locationId: SortEnumType
  location: LocationSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type AlphaDiscount {
  codeType: String
  code: String!
  amount: Decimal!
  info: String
}

input AlphaDiscountFilterInput {
  and: [AlphaDiscountFilterInput!]
  or: [AlphaDiscountFilterInput!]
  codeType: StringOperationFilterInput
  code: StringOperationFilterInput
  amount: ComparableDecimalOperationFilterInput
  info: StringOperationFilterInput
}

input AlphaDiscountInput {
  codeType: String
  code: String!
  amount: Decimal!
  info: String
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

type AuthQueries {
  accessToken(request: AuthTokenRequestInput): AuthResponse
  refreshToken(request: AuthRefreshTokenRequestInput): AuthResponse
}

input AuthRefreshTokenRequestInput {
  grant_type: String
  refresh_token: String
}

type AuthResponse {
  access_token: String
  refresh_token: String
  token_type: String
  expires_in: Int!
}

input AuthTokenRequestInput {
  grant_type: String
  username: String
  password: String
}

type Bank {
  codeM: String
  codeE: String
  _raw_json_name: String
  name: [Locale]
  internationalName: String
  dateRegistration: DateTime
  dateLicense: DateTime
  numberLicense: String
  address: String
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BankCollectionSegment {
  items: [Bank]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input BankFilterInput {
  and: [BankFilterInput!]
  or: [BankFilterInput!]
  codeM: StringOperationFilterInput
  codeE: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  internationalName: StringOperationFilterInput
  dateRegistration: ComparableNullableOfDateTimeOperationFilterInput
  dateLicense: ComparableNullableOfDateTimeOperationFilterInput
  numberLicense: StringOperationFilterInput
  address: StringOperationFilterInput
  isUse: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input BankInput {
  codeM: String
  codeE: String
  name: [LocaleInput!]!
  internationalName: String
  dateRegistration: DateTime
  dateLicense: DateTime
  numberLicense: String
  address: String
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BankMutation {
  add(model: [BankInput]): [Bank]
  update(model: [BankInput]): [Bank]
  addOrUpdate(model: [BankInput]): [Bank]
  delete(model: [BankInput]): [Bank]
}

type BankQuery {
  all(skip: Int, take: Int, where: BankFilterInput, order: [BankSortInput!]): BankCollectionSegment
  userInfo(model: BankInput): UserInfo
  getByKeys(id: String): [Bank]
}

input BankSortInput {
  codeM: SortEnumType
  codeE: SortEnumType
  internationalName: SortEnumType
  dateRegistration: SortEnumType
  dateLicense: SortEnumType
  numberLicense: SortEnumType
  address: SortEnumType
  isUse: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type BaseModelExtensionsDescription {
  modelName: String!
  fields: [BaseModelFieldExtensionsDescription!]!
}

type BaseModelFieldExtensionsDescription {
  isHidden: Boolean!
  isFilterKey: Boolean!
  isRequired: Boolean!
  isReadOnly: Boolean!
  property: String!
  title: String
  typeName: String!
  kind: BaseModelKind!
  ofModel: String
}

enum BaseModelKind {
  SCALAR
  ENUM
  ARRAY
  OBJECT
}

type BaseReportsQueries {
  incomingGoodsReport(skip: Int, take: Int, from: DateTime!, to: DateTime!, filters: [Int!], structureId: String, where: IncomingGoodsReportNodeFilterInput, order: [IncomingGoodsReportNodeSortInput!]): IncomingGoodsReportNodeCollectionSegment
  priceList(skip: Int, take: Int, structureId: String, where: PriceListModelFilterInput, order: [PriceListModelSortInput!]): PriceListModelCollectionSegment
  expiringRegistrationRests(skip: Int, take: Int, date: DateTime!, structureId: String, where: ExpiringRegistrationForRestsModelFilterInput, order: [ExpiringRegistrationForRestsModelSortInput!]): ExpiringRegistrationForRestsModelCollectionSegment
  employeeSalesAnalysis(skip: Int, take: Int, date: DateTime!, structureId: String, where: EmployeeSalesAnalysisModelFilterInput, order: [EmployeeSalesAnalysisModelSortInput!]): EmployeeSalesAnalysisModelCollectionSegment
  incomingGoodsReportFilters(skip: Int, take: Int, where: ReportFilterDescriptionModelFilterInput, order: [ReportFilterDescriptionModelSortInput!]): ReportFilterDescriptionModelCollectionSegment
  salesPlanImplementation(skip: Int, take: Int, from: DateTime!, to: DateTime!, filters: [Int!], structureId: String, where: SalesPlanImplementationNodeFilterInput, order: [SalesPlanImplementationNodeSortInput!]): SalesPlanImplementationNodeCollectionSegment
  illiquidGoodsReport(skip: Int, take: Int, from: DateTime!, to: DateTime!, structureId: String, where: IlliquidGoodsModelFilterInput, order: [IlliquidGoodsModelSortInput!]): IlliquidGoodsModelCollectionSegment
  goodsMovementReportByDocument(skip: Int, take: Int, from: DateTime!, to: DateTime!, structureId: String, documentId: String, where: GoodsMovementNodeFilterInput, order: [GoodsMovementNodeSortInput!]): GoodsMovementNodeCollectionSegment
  goodsMovementReportByProduct(skip: Int, take: Int, from: DateTime!, to: DateTime!, structureId: String, productId: String, where: GoodsMovementNodeFilterInput, order: [GoodsMovementNodeSortInput!]): GoodsMovementNodeCollectionSegment
  insuranceCompanyReport(skip: Int, take: Int, date: DateTime!, firmId: String, insuranceCompanyId: String, where: InsuranceCompanyReportModelFilterInput, order: [InsuranceCompanyReportModelSortInput!]): InsuranceCompanyReportModelCollectionSegment
}

type Benefit {
  number: Int
  _raw_json_name: String
  name: [Locale]
  benefitBegin: DateTime
  benefitEnd: DateTime
  minSum: Decimal
  neededDoctor: Boolean
  priceType: Int
  percent: Decimal
  benefitReturnModelId: Int
  returnOnRegister: Boolean
  extraGoodsPrice: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  benefitReturnModel: BenefitReturnModel!
}

type BenefitCollectionSegment {
  items: [Benefit]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input BenefitFilterInput {
  and: [BenefitFilterInput!]
  or: [BenefitFilterInput!]
  number: ComparableInt32OperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  benefitBegin: ComparableDateTimeOperationFilterInput
  benefitEnd: ComparableDateTimeOperationFilterInput
  minSum: ComparableDecimalOperationFilterInput
  neededDoctor: BooleanOperationFilterInput
  priceType: ComparableInt32OperationFilterInput
  percent: ComparableDecimalOperationFilterInput
  benefitReturnModelId: ComparableInt32OperationFilterInput
  benefitReturnModel: BenefitReturnModelFilterInput
  returnOnRegister: BooleanOperationFilterInput
  extraGoodsPrice: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input BenefitInput {
  number: Int
  name: [LocaleInput!]!
  benefitBegin: DateTime
  benefitEnd: DateTime
  minSum: Decimal
  neededDoctor: Boolean
  priceType: Int
  percent: Decimal
  benefitReturnModelId: Int
  returnOnRegister: Boolean
  extraGoodsPrice: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BenefitMutation {
  add(model: [BenefitInput]): [Benefit]
  update(model: [BenefitInput]): [Benefit]
  addOrUpdate(model: [BenefitInput]): [Benefit]
  delete(model: [BenefitInput]): [Benefit]
}

type BenefitQuery {
  all(skip: Int, take: Int, where: BenefitFilterInput, order: [BenefitSortInput!]): BenefitCollectionSegment
  userInfo(model: BenefitInput): UserInfo
  getByKeys(id: String): [Benefit]
}

type BenefitReturnModel {
  _raw_json_name: String
  name: [Locale]
  priceType: Int
  percent: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BenefitReturnModelCollectionSegment {
  items: [BenefitReturnModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input BenefitReturnModelFilterInput {
  and: [BenefitReturnModelFilterInput!]
  or: [BenefitReturnModelFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  priceType: ComparableInt32OperationFilterInput
  percent: ComparableDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input BenefitReturnModelInput {
  name: [LocaleInput!]!
  priceType: Int
  percent: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BenefitReturnModelMutation {
  add(model: [BenefitReturnModelInput]): [BenefitReturnModel]
  update(model: [BenefitReturnModelInput]): [BenefitReturnModel]
  addOrUpdate(model: [BenefitReturnModelInput]): [BenefitReturnModel]
  delete(model: [BenefitReturnModelInput]): [BenefitReturnModel]
}

type BenefitReturnModelQuery {
  all(skip: Int, take: Int, where: BenefitReturnModelFilterInput, order: [BenefitReturnModelSortInput!]): BenefitReturnModelCollectionSegment
  userInfo(model: BenefitReturnModelInput): UserInfo
  getByKeys(id: String): [BenefitReturnModel]
}

input BenefitReturnModelSortInput {
  priceType: SortEnumType
  percent: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type BenefitSaleChannel {
  benefitId: String
  saleChannelId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  benefit: Benefit!
  saleChannel: SaleChannel!
}

type BenefitSaleChannelCollectionSegment {
  items: [BenefitSaleChannel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input BenefitSaleChannelFilterInput {
  and: [BenefitSaleChannelFilterInput!]
  or: [BenefitSaleChannelFilterInput!]
  benefitId: StringOperationFilterInput
  benefit: BenefitFilterInput
  saleChannelId: StringOperationFilterInput
  saleChannel: SaleChannelFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input BenefitSaleChannelInput {
  benefitId: String
  saleChannelId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BenefitSaleChannelMutation {
  add(model: [BenefitSaleChannelInput]): [BenefitSaleChannel]
  update(model: [BenefitSaleChannelInput]): [BenefitSaleChannel]
  addOrUpdate(model: [BenefitSaleChannelInput]): [BenefitSaleChannel]
  delete(model: [BenefitSaleChannelInput]): [BenefitSaleChannel]
}

type BenefitSaleChannelQuery {
  all(skip: Int, take: Int, where: BenefitSaleChannelFilterInput, order: [BenefitSaleChannelSortInput!]): BenefitSaleChannelCollectionSegment
  userInfo(model: BenefitSaleChannelInput): UserInfo
  getByKeys(benefitId: String, saleChannelId: String): [BenefitSaleChannel]
}

input BenefitSaleChannelSortInput {
  benefitId: SortEnumType
  benefit: BenefitSortInput
  saleChannelId: SortEnumType
  saleChannel: SaleChannelSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input BenefitSortInput {
  number: SortEnumType
  benefitBegin: SortEnumType
  benefitEnd: SortEnumType
  minSum: SortEnumType
  neededDoctor: SortEnumType
  priceType: SortEnumType
  percent: SortEnumType
  benefitReturnModelId: SortEnumType
  benefitReturnModel: BenefitReturnModelSortInput
  returnOnRegister: SortEnumType
  extraGoodsPrice: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Bill {
  firmStructureId: String
  contractorId: String
  payerId: String
  contractNumber: String
  sumTax: Decimal
  sumDiscount: Decimal
  percentDiscount: Decimal
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  firmStructure: Structure!
  contractor: Firm!
  payer: Firm!
  currency: Currency
}

type BillCollectionSegment {
  items: [Bill]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input BillFilterInput {
  and: [BillFilterInput!]
  or: [BillFilterInput!]
  firmStructureId: StringOperationFilterInput
  firmStructure: StructureFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  payerId: StringOperationFilterInput
  payer: FirmFilterInput
  contractNumber: StringOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  sumDiscount: ComparableDecimalOperationFilterInput
  percentDiscount: ComparableNullableOfDecimalOperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  parentDocumentId: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input BillInput {
  firmStructureId: String
  contractorId: String
  payerId: String
  contractNumber: String
  sumTax: Decimal
  sumDiscount: Decimal
  percentDiscount: Decimal
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BillMutation {
  add(model: [BillInput]): [Bill]
  update(model: [BillInput]): [Bill]
  addOrUpdate(model: [BillInput]): [Bill]
  delete(model: [BillInput]): [Bill]
}

type BillProduct {
  billId: String
  productId: String
  taxRateId: String
  unitId: String
  amount: Decimal
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  bill: Bill!
  product: Product!
  taxRate: TaxRate!
  unit: Unit!
}

type BillProductCollectionSegment {
  items: [BillProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input BillProductFilterInput {
  and: [BillProductFilterInput!]
  or: [BillProductFilterInput!]
  billId: StringOperationFilterInput
  bill: BillFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  amount: ComparableDecimalOperationFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input BillProductInput {
  billId: String
  productId: String
  taxRateId: String
  unitId: String
  amount: Decimal
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type BillProductMutation {
  add(model: [BillProductInput]): [BillProduct]
  update(model: [BillProductInput]): [BillProduct]
  addOrUpdate(model: [BillProductInput]): [BillProduct]
  delete(model: [BillProductInput]): [BillProduct]
}

type BillProductQuery {
  all(skip: Int, take: Int, where: BillProductFilterInput, order: [BillProductSortInput!]): BillProductCollectionSegment
  userInfo(model: BillProductInput): UserInfo
  getByKeys(billId: String, productId: String): [BillProduct]
}

input BillProductSortInput {
  billId: SortEnumType
  bill: BillSortInput
  productId: SortEnumType
  product: ProductSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  unitId: SortEnumType
  unit: UnitSortInput
  amount: SortEnumType
  price: SortEnumType
  sum: SortEnumType
  sumTax: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type BillQuery {
  all(skip: Int, take: Int, where: BillFilterInput, order: [BillSortInput!]): BillCollectionSegment
  userInfo(model: BillInput): UserInfo
  getByKeys(id: String): [Bill]
}

input BillSortInput {
  firmStructureId: SortEnumType
  firmStructure: StructureSortInput
  contractorId: SortEnumType
  contractor: FirmSortInput
  payerId: SortEnumType
  payer: FirmSortInput
  contractNumber: SortEnumType
  sumTax: SortEnumType
  sumDiscount: SortEnumType
  percentDiscount: SortEnumType
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  parentDocumentId: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

type Cashbox {
  firmId: String
  structureId: String
  type: Int
  number: String
  _raw_json_name: String
  name: [Locale]
  certificateNumber: String
  certificateExpired: DateTime
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm!
  structure: Structure!
}

type CashboxBase {
  id: String
  number: String
  name: [Locale!]!
}

input CashboxBaseFilterInput {
  and: [CashboxBaseFilterInput!]
  or: [CashboxBaseFilterInput!]
  id: StringOperationFilterInput
  number: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
}

input CashboxBaseInput {
  id: String
  number: String
  name: [LocaleInput!]!
}

input CashboxBaseSortInput {
  id: SortEnumType
  number: SortEnumType
}

type CashboxCollectionSegment {
  items: [Cashbox]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CashboxFilterInput {
  and: [CashboxFilterInput!]
  or: [CashboxFilterInput!]
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  type: ComparableInt32OperationFilterInput
  number: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  certificateNumber: StringOperationFilterInput
  certificateExpired: ComparableNullableOfDateTimeOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CashboxInput {
  firmId: String
  structureId: String
  type: Int
  number: String
  name: [LocaleInput!]!
  certificateNumber: String
  certificateExpired: DateTime
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CashboxMutation {
  add(model: [CashboxInput]): [Cashbox]
  update(model: [CashboxInput]): [Cashbox]
  addOrUpdate(model: [CashboxInput]): [Cashbox]
  delete(model: [CashboxInput]): [Cashbox]
}

type CashboxPermit {
  code: String
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CashboxPermitAction {
  cashboxPermitId: String
  code: String
  name: String
  info: String
  isAction: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  cashboxPermit: CashboxPermit!
}

type CashboxPermitActionCollectionSegment {
  items: [CashboxPermitAction]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CashboxPermitActionFilterInput {
  and: [CashboxPermitActionFilterInput!]
  or: [CashboxPermitActionFilterInput!]
  cashboxPermitId: StringOperationFilterInput
  cashboxPermit: CashboxPermitFilterInput
  code: StringOperationFilterInput
  name: StringOperationFilterInput
  info: StringOperationFilterInput
  isAction: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CashboxPermitActionInput {
  cashboxPermitId: String
  code: String
  name: String
  info: String
  isAction: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CashboxPermitActionMutation {
  add(model: [CashboxPermitActionInput]): [CashboxPermitAction]
  update(model: [CashboxPermitActionInput]): [CashboxPermitAction]
  addOrUpdate(model: [CashboxPermitActionInput]): [CashboxPermitAction]
  delete(model: [CashboxPermitActionInput]): [CashboxPermitAction]
}

type CashboxPermitActionQuery {
  all(skip: Int, take: Int, where: CashboxPermitActionFilterInput, order: [CashboxPermitActionSortInput!]): CashboxPermitActionCollectionSegment
  userInfo(model: CashboxPermitActionInput): UserInfo
  getByKeys(id: String): [CashboxPermitAction]
}

input CashboxPermitActionSortInput {
  cashboxPermitId: SortEnumType
  cashboxPermit: CashboxPermitSortInput
  code: SortEnumType
  name: SortEnumType
  info: SortEnumType
  isAction: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type CashboxPermitCollectionSegment {
  items: [CashboxPermit]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CashboxPermitFilterInput {
  and: [CashboxPermitFilterInput!]
  or: [CashboxPermitFilterInput!]
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CashboxPermitInput {
  code: String
  name: [LocaleInput!]!
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CashboxPermitMutation {
  add(model: [CashboxPermitInput]): [CashboxPermit]
  update(model: [CashboxPermitInput]): [CashboxPermit]
  addOrUpdate(model: [CashboxPermitInput]): [CashboxPermit]
  delete(model: [CashboxPermitInput]): [CashboxPermit]
}

type CashboxPermitQuery {
  all(skip: Int, take: Int, where: CashboxPermitFilterInput, order: [CashboxPermitSortInput!]): CashboxPermitCollectionSegment
  userInfo(model: CashboxPermitInput): UserInfo
  getByKeys(id: String): [CashboxPermit]
}

input CashboxPermitSortInput {
  code: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type CashboxQuery {
  all(skip: Int, take: Int, where: CashboxFilterInput, order: [CashboxSortInput!]): CashboxCollectionSegment
  userInfo(model: CashboxInput): UserInfo
  getByKeys(id: String): [Cashbox]
}

input CashboxSortInput {
  firmId: SortEnumType
  firm: FirmSortInput
  structureId: SortEnumType
  structure: StructureSortInput
  type: SortEnumType
  number: SortEnumType
  certificateNumber: SortEnumType
  certificateExpired: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type CashOper {
  _raw_json_name: String
  name: [Locale]
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CashOperCollectionSegment {
  items: [CashOper]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CashOperFilterInput {
  and: [CashOperFilterInput!]
  or: [CashOperFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  isUse: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CashOperInput {
  name: [LocaleInput!]!
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CashOperMutation {
  add(model: [CashOperInput]): [CashOper]
  update(model: [CashOperInput]): [CashOper]
  addOrUpdate(model: [CashOperInput]): [CashOper]
  delete(model: [CashOperInput]): [CashOper]
}

type CashOperQuery {
  all(skip: Int, take: Int, where: CashOperFilterInput, order: [CashOperSortInput!]): CashOperCollectionSegment
  userInfo(model: CashOperInput): UserInfo
  getByKeys(id: String): [CashOper]
}

input CashOperSortInput {
  isUse: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type CashOrder {
  globalCode: String
  status: Int
  direct: Int
  number: String
  date: DateTime
  firmId: String
  structureId: String
  cashboxId: String
  cashierId: String
  workerId: String
  cashOperId: String
  sum: Decimal
  currencyId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm
  firmJson: FirmBase
  structure: Structure
  structureJson: StructureBase
  cashbox: Cashbox
  cashboxJson: CashboxBase
  cashier: FirmEmployee
  cashierJson: FirmEmployeeBase
  worker: FirmEmployee
  workerJson: FirmEmployeeBase
  cashOper: CashOper
  cashOperJson: CashOper
  currency: Currency
  currencyJson: CurrencyBase
}

type CashOrderCollectionSegment {
  items: [CashOrder]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CashOrderFilterInput {
  and: [CashOrderFilterInput!]
  or: [CashOrderFilterInput!]
  globalCode: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  direct: ComparableInt32OperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  firmJson: FirmBaseFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  structureJson: StructureBaseFilterInput
  cashboxId: StringOperationFilterInput
  cashbox: CashboxFilterInput
  cashboxJson: CashboxBaseFilterInput
  cashierId: StringOperationFilterInput
  cashier: FirmEmployeeFilterInput
  cashierJson: FirmEmployeeBaseFilterInput
  workerId: StringOperationFilterInput
  worker: FirmEmployeeFilterInput
  workerJson: FirmEmployeeBaseFilterInput
  cashOperId: StringOperationFilterInput
  cashOper: CashOperFilterInput
  cashOperJson: CashOperFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  currencyJson: CurrencyBaseFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CashOrderInput {
  globalCode: String
  status: Int
  direct: Int
  number: String
  date: DateTime
  firmId: String
  firmJson: FirmBaseInput
  structureId: String
  structureJson: StructureBaseInput
  cashboxId: String
  cashboxJson: CashboxBaseInput
  cashierId: String
  cashierJson: FirmEmployeeBaseInput
  workerId: String
  workerJson: FirmEmployeeBaseInput
  cashOperId: String
  cashOperJson: CashOperInput
  sum: Decimal
  currencyId: String
  currencyJson: CurrencyBaseInput
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CashOrderMutation {
  add(model: [CashOrderInput]): [CashOrder]
  update(model: [CashOrderInput]): [CashOrder]
  addOrUpdate(model: [CashOrderInput]): [CashOrder]
  delete(model: [CashOrderInput]): [CashOrder]
}

type CashOrderQuery {
  all(skip: Int, take: Int, where: CashOrderFilterInput, order: [CashOrderSortInput!]): CashOrderCollectionSegment
  userInfo(model: CashOrderInput): UserInfo
  getByKeys(id: String): [CashOrder]
}

input CashOrderSortInput {
  globalCode: SortEnumType
  status: SortEnumType
  direct: SortEnumType
  number: SortEnumType
  date: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  firmJson: FirmBaseSortInput
  structureId: SortEnumType
  structure: StructureSortInput
  structureJson: StructureBaseSortInput
  cashboxId: SortEnumType
  cashbox: CashboxSortInput
  cashboxJson: CashboxBaseSortInput
  cashierId: SortEnumType
  cashier: FirmEmployeeSortInput
  cashierJson: FirmEmployeeBaseSortInput
  workerId: SortEnumType
  worker: FirmEmployeeSortInput
  workerJson: FirmEmployeeBaseSortInput
  cashOperId: SortEnumType
  cashOper: CashOperSortInput
  cashOperJson: CashOperSortInput
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  currencyJson: CurrencyBaseSortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type CatalogGroup {
  parentId: String
  _raw_json_name: String
  name: [Locale]
  tableName: String
  priority: Int
  isDynamic: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: CatalogGroup
}

type CatalogGroupCollectionSegment {
  items: [CatalogGroup]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type CatalogGroupField {
  catalogGroupId: String
  fieldName: String
  value: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  group: CatalogGroup!
}

type CatalogGroupFieldCollectionSegment {
  items: [CatalogGroupField]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CatalogGroupFieldFilterInput {
  and: [CatalogGroupFieldFilterInput!]
  or: [CatalogGroupFieldFilterInput!]
  catalogGroupId: StringOperationFilterInput
  group: CatalogGroupFilterInput
  fieldName: StringOperationFilterInput
  value: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CatalogGroupFieldInput {
  catalogGroupId: String
  fieldName: String
  value: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CatalogGroupFieldMutation {
  add(model: [CatalogGroupFieldInput]): [CatalogGroupField]
  update(model: [CatalogGroupFieldInput]): [CatalogGroupField]
  addOrUpdate(model: [CatalogGroupFieldInput]): [CatalogGroupField]
  delete(model: [CatalogGroupFieldInput]): [CatalogGroupField]
}

type CatalogGroupFieldQuery {
  all(skip: Int, take: Int, where: CatalogGroupFieldFilterInput, order: [CatalogGroupFieldSortInput!]): CatalogGroupFieldCollectionSegment
  userInfo(model: CatalogGroupFieldInput): UserInfo
  getByKeys(id: String): [CatalogGroupField]
}

input CatalogGroupFieldSortInput {
  catalogGroupId: SortEnumType
  group: CatalogGroupSortInput
  fieldName: SortEnumType
  value: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input CatalogGroupFilterInput {
  and: [CatalogGroupFilterInput!]
  or: [CatalogGroupFilterInput!]
  parentId: StringOperationFilterInput
  parent: CatalogGroupFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  tableName: StringOperationFilterInput
  priority: ComparableInt32OperationFilterInput
  isDynamic: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CatalogGroupInput {
  parentId: String
  name: [LocaleInput!]
  tableName: String
  priority: Int
  isDynamic: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CatalogGroupItem {
  catalogGroupId: String
  itemId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CatalogGroupItemCollectionSegment {
  items: [CatalogGroupItem]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CatalogGroupItemFilterInput {
  and: [CatalogGroupItemFilterInput!]
  or: [CatalogGroupItemFilterInput!]
  catalogGroupId: StringOperationFilterInput
  itemId: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CatalogGroupItemInput {
  catalogGroupId: String
  itemId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CatalogGroupItemMutation {
  add(model: [CatalogGroupItemInput]): [CatalogGroupItem]
  update(model: [CatalogGroupItemInput]): [CatalogGroupItem]
  addOrUpdate(model: [CatalogGroupItemInput]): [CatalogGroupItem]
  delete(model: [CatalogGroupItemInput]): [CatalogGroupItem]
}

type CatalogGroupItemQuery {
  all(skip: Int, take: Int, where: CatalogGroupItemFilterInput, order: [CatalogGroupItemSortInput!]): CatalogGroupItemCollectionSegment
  userInfo(model: CatalogGroupItemInput): UserInfo
  getByKeys(catalogGroupId: String, itemId: String): [CatalogGroupItem]
}

input CatalogGroupItemSortInput {
  catalogGroupId: SortEnumType
  itemId: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type CatalogGroupMutation {
  add(model: [CatalogGroupInput]): [CatalogGroup]
  update(model: [CatalogGroupInput]): [CatalogGroup]
  addOrUpdate(model: [CatalogGroupInput]): [CatalogGroup]
  delete(model: [CatalogGroupInput]): [CatalogGroup]
}

type CatalogGroupQuery {
  all(skip: Int, take: Int, where: CatalogGroupFilterInput, order: [CatalogGroupSortInput!]): CatalogGroupCollectionSegment
  userInfo(model: CatalogGroupInput): UserInfo
  getByKeys(id: String): [CatalogGroup]
}

input CatalogGroupSortInput {
  parentId: SortEnumType
  parent: CatalogGroupSortInput
  tableName: SortEnumType
  priority: SortEnumType
  isDynamic: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Changes {
  id: String
  action: String
  tableName: String
  data: String
  query: String
  subdivisionTargetId: String
  subdivisionSourceId: String
  isFromParent: Boolean
  dateInsert: DateTime
}

type ChangesCollectionSegment {
  items: [Changes]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ChangesFilterInput {
  and: [ChangesFilterInput!]
  or: [ChangesFilterInput!]
  id: StringOperationFilterInput
  action: StringOperationFilterInput
  tableName: StringOperationFilterInput
  data: StringOperationFilterInput
  query: StringOperationFilterInput
  subdivisionTargetId: StringOperationFilterInput
  subdivisionSourceId: StringOperationFilterInput
  isFromParent: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
}

input ChangesInput {
  id: String
  action: String
  tableName: String
  data: String
  query: String
  subdivisionTargetId: String
  subdivisionSourceId: String
  isFromParent: Boolean
  dateInsert: DateTime
}

type ChangesMutation {
  add(model: [ChangesInput]): [Changes]
  update(model: [ChangesInput]): [Changes]
  addOrUpdate(model: [ChangesInput]): [Changes]
  delete(model: [ChangesInput]): [Changes]
}

type ChangesQuery {
  all(skip: Int, take: Int, where: ChangesFilterInput, order: [ChangesSortInput!]): ChangesCollectionSegment
  userInfo(model: ChangesInput): UserInfo
  getByKeys(id: String): [Changes]
}

input ChangesSortInput {
  id: SortEnumType
  action: SortEnumType
  tableName: SortEnumType
  data: SortEnumType
  query: SortEnumType
  subdivisionTargetId: SortEnumType
  subdivisionSourceId: SortEnumType
  isFromParent: SortEnumType
  dateInsert: SortEnumType
}

input ChangeStatusAsyncParametersInput {
  timesheetId: String
  status: TimesheetStatusType!
}

type Client {
  id: String
  identity: String
  insurancePolicyId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  insurancePolicy: Policy!
  employee: Employee!
}

type ClientCollectionSegment {
  items: [Client]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ClientFilterInput {
  and: [ClientFilterInput!]
  or: [ClientFilterInput!]
  id: StringOperationFilterInput
  identity: StringOperationFilterInput
  insurancePolicyId: StringOperationFilterInput
  insurancePolicy: PolicyFilterInput
  employee: EmployeeFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ClientInput {
  id: String
  identity: String
  insurancePolicyId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ClientMutation {
  add(model: [ClientInput]): [Client]
  update(model: [ClientInput]): [Client]
  addOrUpdate(model: [ClientInput]): [Client]
  delete(model: [ClientInput]): [Client]
}

type ClientQuery {
  all(skip: Int, take: Int, where: ClientFilterInput, order: [ClientSortInput!]): ClientCollectionSegment
  userInfo(model: ClientInput): UserInfo
  getByKeys(id: String, insurancePolicyId: String): [Client]
}

type ClientSettingMutations {
  saveItem(item: ClientSettingsInput): ClientSettings
}

type ClientSettingQueries {
  item(clientObject: String): ClientSettings
}

type ClientSettings {
  userId: String
  clientObject: String
  data: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ClientSettingsCollectionSegment {
  items: [ClientSettings]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ClientSettingsFilterInput {
  and: [ClientSettingsFilterInput!]
  or: [ClientSettingsFilterInput!]
  userId: StringOperationFilterInput
  clientObject: StringOperationFilterInput
  data: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ClientSettingsInput {
  userId: String
  clientObject: String
  data: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ClientSettingsMutation {
  add(model: [ClientSettingsInput]): [ClientSettings]
  update(model: [ClientSettingsInput]): [ClientSettings]
  addOrUpdate(model: [ClientSettingsInput]): [ClientSettings]
  delete(model: [ClientSettingsInput]): [ClientSettings]
}

type ClientSettingsQuery {
  all(skip: Int, take: Int, where: ClientSettingsFilterInput, order: [ClientSettingsSortInput!]): ClientSettingsCollectionSegment
  userInfo(model: ClientSettingsInput): UserInfo
  getByKeys(id: String): [ClientSettings]
}

input ClientSettingsSortInput {
  userId: SortEnumType
  clientObject: SortEnumType
  data: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input ClientSortInput {
  id: SortEnumType
  identity: SortEnumType
  insurancePolicyId: SortEnumType
  insurancePolicy: PolicySortInput
  employee: EmployeeSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input ClientTimesheetEmployeeModelInput {
  personalNumber: String
  dailyHours: [ClientTimesheetModelEmployeeDailyHoursInfoInput!]!
  nightlyHours: [Decimal!]!
}

input ClientTimesheetModelEmployeeDailyHoursInfoInput {
  hours: Decimal!
  timesheetAbsenceReason: TimesheetAbsenceReasonType!
}

input ClientTimesheetModelInput {
  employees: [ClientTimesheetEmployeeModelInput!]!
}

enum CodeNum {
  A
  B
  C
  D
  E
  F
  G
  H
}

input CodeNumOperationFilterInput {
  eq: CodeNum
  neq: CodeNum
  in: [CodeNum!]
  nin: [CodeNum!]
}

"""Information about the offset pagination."""
type CollectionSegmentInfo {
  """
  Indicates whether more items exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more items exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!
}

input ComparableDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ComparableDecimalOperationFilterInput {
  eq: Decimal
  neq: Decimal
  in: [Decimal!]
  nin: [Decimal!]
  gt: Decimal
  ngt: Decimal
  gte: Decimal
  ngte: Decimal
  lt: Decimal
  nlt: Decimal
  lte: Decimal
  nlte: Decimal
}

input ComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input ComparableNullableOfDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ComparableNullableOfDecimalOperationFilterInput {
  eq: Decimal
  neq: Decimal
  in: [Decimal]
  nin: [Decimal]
  gt: Decimal
  ngt: Decimal
  gte: Decimal
  ngte: Decimal
  lt: Decimal
  nlt: Decimal
  lte: Decimal
  nlte: Decimal
}

input ComparableNullableOfInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

type ConsumptionMethod {
  _raw_json_name: String
  name: [Locale]
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ConsumptionMethodCollectionSegment {
  items: [ConsumptionMethod]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ConsumptionMethodFilterInput {
  and: [ConsumptionMethodFilterInput!]
  or: [ConsumptionMethodFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ConsumptionMethodInput {
  name: [LocaleInput!]!
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ConsumptionMethodMutation {
  add(model: [ConsumptionMethodInput]): [ConsumptionMethod]
  update(model: [ConsumptionMethodInput]): [ConsumptionMethod]
  addOrUpdate(model: [ConsumptionMethodInput]): [ConsumptionMethod]
  delete(model: [ConsumptionMethodInput]): [ConsumptionMethod]
}

type ConsumptionMethodQuery {
  all(skip: Int, take: Int, where: ConsumptionMethodFilterInput, order: [ConsumptionMethodSortInput!]): ConsumptionMethodCollectionSegment
  userInfo(model: ConsumptionMethodInput): UserInfo
  getByKeys(id: String): [ConsumptionMethod]
}

input ConsumptionMethodSortInput {
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Contract {
  globalCode: String
  status: Int
  pattern: Int
  number: String
  date: DateTime
  dateBeg: DateTime
  dateEnd: DateTime
  dateBreak: DateTime
  city: String
  name: String
  firmNameSide: String
  firmId: String
  contractorNameSide: String
  contractorId: String
  make: String
  info: String
  parentId: String
  ownerFirmEmployeeId: String
  ownerCode: String
  ownerDirDo: String
  ownerDirCode: String
  ownerDirName: String
  ownerDirPost: String
  ownerAccount: String
  ownerBankId: String
  ownerBankName: String
  ownerLocationId: String
  ownerLocationAddress: String
  agentFirmEmployeeId: String
  agentCode: String
  agentDirDo: String
  agentDirCode: String
  agentDirName: String
  agentDirPost: String
  agentAccount: String
  agentBankId: String
  agentBankName: String
  agentLocationId: String
  agentLocationAddress: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm!
  firmJson: FirmBase!
  contractor: Firm!
  contractorJson: FirmBase!
  parent: Contract!
  ownerFirmEmployee: FirmEmployee!
  ownerBank: Bank!
  ownerLocation: Location!
  agentFirmEmployee: FirmEmployee!
  agentBank: Bank!
  agentLocation: Location!
}

type ContractBase {
  id: String
  number: String
  date: DateTime!
  name: String
}

input ContractBaseFilterInput {
  and: [ContractBaseFilterInput!]
  or: [ContractBaseFilterInput!]
  id: StringOperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
}

input ContractBaseInput {
  id: String
  number: String
  date: DateTime!
  name: String
}

input ContractBaseSortInput {
  id: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
}

type ContractBuySale {
  contractId: String
  payDate: DateTime
  payTerm: String
  delivDate: DateTime
  delivTerm: String
  sum: Decimal
  sumDiscount: Decimal
  sumTax: Decimal
  fine: Decimal
  currencyId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  contract: Contract!
  currency: Currency!
}

type ContractBuySaleCollectionSegment {
  items: [ContractBuySale]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ContractBuySaleFilterInput {
  and: [ContractBuySaleFilterInput!]
  or: [ContractBuySaleFilterInput!]
  contractId: StringOperationFilterInput
  contract: ContractFilterInput
  payDate: ComparableNullableOfDateTimeOperationFilterInput
  payTerm: StringOperationFilterInput
  delivDate: ComparableNullableOfDateTimeOperationFilterInput
  delivTerm: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumDiscount: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  fine: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ContractBuySaleInput {
  contractId: String
  payDate: DateTime
  payTerm: String
  delivDate: DateTime
  delivTerm: String
  sum: Decimal
  sumDiscount: Decimal
  sumTax: Decimal
  fine: Decimal
  currencyId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ContractBuySaleMutation {
  add(model: [ContractBuySaleInput]): [ContractBuySale]
  update(model: [ContractBuySaleInput]): [ContractBuySale]
  addOrUpdate(model: [ContractBuySaleInput]): [ContractBuySale]
  delete(model: [ContractBuySaleInput]): [ContractBuySale]
}

type ContractBuySaleQuery {
  all(skip: Int, take: Int, where: ContractBuySaleFilterInput, order: [ContractBuySaleSortInput!]): ContractBuySaleCollectionSegment
  userInfo(model: ContractBuySaleInput): UserInfo
  getByKeys(id: String): [ContractBuySale]
}

input ContractBuySaleSortInput {
  contractId: SortEnumType
  contract: ContractSortInput
  payDate: SortEnumType
  payTerm: SortEnumType
  delivDate: SortEnumType
  delivTerm: SortEnumType
  sum: SortEnumType
  sumDiscount: SortEnumType
  sumTax: SortEnumType
  fine: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ContractCollectionSegment {
  items: [Contract]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type ContractComission {
  contractId: String
  value: Decimal
  valueType: Int
  sum: Decimal
  currencyId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  contract: Contract!
  currency: Currency!
}

type ContractComissionCollectionSegment {
  items: [ContractComission]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ContractComissionFilterInput {
  and: [ContractComissionFilterInput!]
  or: [ContractComissionFilterInput!]
  contractId: StringOperationFilterInput
  contract: ContractFilterInput
  value: ComparableDecimalOperationFilterInput
  valueType: ComparableInt32OperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ContractComissionInput {
  contractId: String
  value: Decimal
  valueType: Int
  sum: Decimal
  currencyId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ContractComissionMutation {
  add(model: [ContractComissionInput]): [ContractComission]
  update(model: [ContractComissionInput]): [ContractComission]
  addOrUpdate(model: [ContractComissionInput]): [ContractComission]
  delete(model: [ContractComissionInput]): [ContractComission]
}

type ContractComissionQuery {
  all(skip: Int, take: Int, where: ContractComissionFilterInput, order: [ContractComissionSortInput!]): ContractComissionCollectionSegment
  userInfo(model: ContractComissionInput): UserInfo
  getByKeys(id: String): [ContractComission]
}

input ContractComissionSortInput {
  contractId: SortEnumType
  contract: ContractSortInput
  value: SortEnumType
  valueType: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input ContractFilterInput {
  and: [ContractFilterInput!]
  or: [ContractFilterInput!]
  globalCode: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  pattern: ComparableInt32OperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  dateBeg: ComparableNullableOfDateTimeOperationFilterInput
  dateEnd: ComparableNullableOfDateTimeOperationFilterInput
  dateBreak: ComparableNullableOfDateTimeOperationFilterInput
  city: StringOperationFilterInput
  name: StringOperationFilterInput
  firmNameSide: StringOperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  firmJson: FirmBaseFilterInput
  contractorNameSide: StringOperationFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  contractorJson: FirmBaseFilterInput
  make: StringOperationFilterInput
  info: StringOperationFilterInput
  parentId: StringOperationFilterInput
  parent: ContractFilterInput
  ownerFirmEmployeeId: StringOperationFilterInput
  ownerFirmEmployee: FirmEmployeeFilterInput
  ownerCode: StringOperationFilterInput
  ownerDirDo: StringOperationFilterInput
  ownerDirCode: StringOperationFilterInput
  ownerDirName: StringOperationFilterInput
  ownerDirPost: StringOperationFilterInput
  ownerAccount: StringOperationFilterInput
  ownerBankId: StringOperationFilterInput
  ownerBank: BankFilterInput
  ownerBankName: StringOperationFilterInput
  ownerLocationId: StringOperationFilterInput
  ownerLocation: LocationFilterInput
  ownerLocationAddress: StringOperationFilterInput
  agentFirmEmployeeId: StringOperationFilterInput
  agentFirmEmployee: FirmEmployeeFilterInput
  agentCode: StringOperationFilterInput
  agentDirDo: StringOperationFilterInput
  agentDirCode: StringOperationFilterInput
  agentDirName: StringOperationFilterInput
  agentDirPost: StringOperationFilterInput
  agentAccount: StringOperationFilterInput
  agentBankId: StringOperationFilterInput
  agentBank: BankFilterInput
  agentBankName: StringOperationFilterInput
  agentLocationId: StringOperationFilterInput
  agentLocation: LocationFilterInput
  agentLocationAddress: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ContractInput {
  globalCode: String
  status: Int
  pattern: Int
  number: String
  date: DateTime
  dateBeg: DateTime
  dateEnd: DateTime
  dateBreak: DateTime
  city: String
  name: String
  firmNameSide: String
  firmId: String
  firmJson: FirmBaseInput!
  contractorNameSide: String
  contractorId: String
  contractorJson: FirmBaseInput!
  make: String
  info: String
  parentId: String
  ownerFirmEmployeeId: String
  ownerCode: String
  ownerDirDo: String
  ownerDirCode: String
  ownerDirName: String
  ownerDirPost: String
  ownerAccount: String
  ownerBankId: String
  ownerBankName: String
  ownerLocationId: String
  ownerLocationAddress: String
  agentFirmEmployeeId: String
  agentCode: String
  agentDirDo: String
  agentDirCode: String
  agentDirName: String
  agentDirPost: String
  agentAccount: String
  agentBankId: String
  agentBankName: String
  agentLocationId: String
  agentLocationAddress: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ContractMutation {
  add(model: [ContractInput]): [Contract]
  update(model: [ContractInput]): [Contract]
  addOrUpdate(model: [ContractInput]): [Contract]
  delete(model: [ContractInput]): [Contract]
}

type ContractQuery {
  all(skip: Int, take: Int, where: ContractFilterInput, order: [ContractSortInput!]): ContractCollectionSegment
  userInfo(model: ContractInput): UserInfo
  getByKeys(id: String): [Contract]
}

input ContractSortInput {
  globalCode: SortEnumType
  status: SortEnumType
  pattern: SortEnumType
  number: SortEnumType
  date: SortEnumType
  dateBeg: SortEnumType
  dateEnd: SortEnumType
  dateBreak: SortEnumType
  city: SortEnumType
  name: SortEnumType
  firmNameSide: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  firmJson: FirmBaseSortInput
  contractorNameSide: SortEnumType
  contractorId: SortEnumType
  contractor: FirmSortInput
  contractorJson: FirmBaseSortInput
  make: SortEnumType
  info: SortEnumType
  parentId: SortEnumType
  parent: ContractSortInput
  ownerFirmEmployeeId: SortEnumType
  ownerFirmEmployee: FirmEmployeeSortInput
  ownerCode: SortEnumType
  ownerDirDo: SortEnumType
  ownerDirCode: SortEnumType
  ownerDirName: SortEnumType
  ownerDirPost: SortEnumType
  ownerAccount: SortEnumType
  ownerBankId: SortEnumType
  ownerBank: BankSortInput
  ownerBankName: SortEnumType
  ownerLocationId: SortEnumType
  ownerLocation: LocationSortInput
  ownerLocationAddress: SortEnumType
  agentFirmEmployeeId: SortEnumType
  agentFirmEmployee: FirmEmployeeSortInput
  agentCode: SortEnumType
  agentDirDo: SortEnumType
  agentDirCode: SortEnumType
  agentDirName: SortEnumType
  agentDirPost: SortEnumType
  agentAccount: SortEnumType
  agentBankId: SortEnumType
  agentBank: BankSortInput
  agentBankName: SortEnumType
  agentLocationId: SortEnumType
  agentLocation: LocationSortInput
  agentLocationAddress: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ContractToSpecification {
  contractId: String
  productId: String
  unitId: String
  amount: Decimal
  price: Decimal
  sum: Decimal
  taxRateId: String
  sumTax: Decimal
  sumDiscount: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  contract: Contract!
  product: Product
  productJson: Product
  unit: Unit!
  unitJson: Unit!
  taxRate: TaxRate!
  taxRateJson: TaxRate!
}

type ContractToSpecificationCollectionSegment {
  items: [ContractToSpecification]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ContractToSpecificationFilterInput {
  and: [ContractToSpecificationFilterInput!]
  or: [ContractToSpecificationFilterInput!]
  contractId: StringOperationFilterInput
  contract: ContractFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  amount: ComparableDecimalOperationFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  sumDiscount: ComparableDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ContractToSpecificationInput {
  contractId: String
  productId: String
  productJson: ProductInput
  unitId: String
  unitJson: UnitInput!
  amount: Decimal
  price: Decimal
  sum: Decimal
  taxRateId: String
  taxRateJson: TaxRateInput!
  sumTax: Decimal
  sumDiscount: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ContractToSpecificationMutation {
  add(model: [ContractToSpecificationInput]): [ContractToSpecification]
  update(model: [ContractToSpecificationInput]): [ContractToSpecification]
  addOrUpdate(model: [ContractToSpecificationInput]): [ContractToSpecification]
  delete(model: [ContractToSpecificationInput]): [ContractToSpecification]
}

type ContractToSpecificationQuery {
  all(skip: Int, take: Int, where: ContractToSpecificationFilterInput, order: [ContractToSpecificationSortInput!]): ContractToSpecificationCollectionSegment
  userInfo(model: ContractToSpecificationInput): UserInfo
  getByKeys(id: String): [ContractToSpecification]
}

input ContractToSpecificationSortInput {
  contractId: SortEnumType
  contract: ContractSortInput
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  amount: SortEnumType
  price: SortEnumType
  sum: SortEnumType
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateSortInput
  sumTax: SortEnumType
  sumDiscount: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Currency {
  codeChar: String
  codeNum: Int
  _raw_json_name: String
  name: [Locale]
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CurrencyBase {
  id: String
  codeChar: String
}

input CurrencyBaseFilterInput {
  and: [CurrencyBaseFilterInput!]
  or: [CurrencyBaseFilterInput!]
  id: StringOperationFilterInput
  codeChar: StringOperationFilterInput
}

input CurrencyBaseInput {
  id: String
  codeChar: String
}

input CurrencyBaseSortInput {
  id: SortEnumType
  codeChar: SortEnumType
}

type CurrencyCollectionSegment {
  items: [Currency]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input CurrencyFilterInput {
  and: [CurrencyFilterInput!]
  or: [CurrencyFilterInput!]
  codeChar: StringOperationFilterInput
  codeNum: ComparableInt32OperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  isUse: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input CurrencyInput {
  codeChar: String
  codeNum: Int
  name: [LocaleInput!]!
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type CurrencyMutation {
  add(model: [CurrencyInput]): [Currency]
  update(model: [CurrencyInput]): [Currency]
  addOrUpdate(model: [CurrencyInput]): [Currency]
  delete(model: [CurrencyInput]): [Currency]
}

type CurrencyQuery {
  all(skip: Int, take: Int, where: CurrencyFilterInput, order: [CurrencySortInput!]): CurrencyCollectionSegment
  userInfo(model: CurrencyInput): UserInfo
  getByKeys(id: String): [Currency]
}

input CurrencySortInput {
  codeChar: SortEnumType
  codeNum: SortEnumType
  isUse: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type DateChanges {
  id: Int
  syncDateIn: DateTime
  syncDateOut: DateTime
  elasticSync: DateTime
}

type DateChangesCollectionSegment {
  items: [DateChanges]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input DateChangesFilterInput {
  and: [DateChangesFilterInput!]
  or: [DateChangesFilterInput!]
  id: ComparableInt32OperationFilterInput
  syncDateIn: ComparableDateTimeOperationFilterInput
  syncDateOut: ComparableDateTimeOperationFilterInput
  elasticSync: ComparableDateTimeOperationFilterInput
}

input DateChangesInput {
  id: Int
  syncDateIn: DateTime
  syncDateOut: DateTime
  elasticSync: DateTime
}

type DateChangesMutation {
  add(model: [DateChangesInput]): [DateChanges]
  update(model: [DateChangesInput]): [DateChanges]
  addOrUpdate(model: [DateChangesInput]): [DateChanges]
  delete(model: [DateChangesInput]): [DateChanges]
}

type DateChangesQuery {
  all(skip: Int, take: Int, where: DateChangesFilterInput, order: [DateChangesSortInput!]): DateChangesCollectionSegment
  userInfo(model: DateChangesInput): UserInfo
}

input DateChangesSortInput {
  id: SortEnumType
  syncDateIn: SortEnumType
  syncDateOut: SortEnumType
  elasticSync: SortEnumType
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

"""The built-in `Decimal` scalar type."""
scalar Decimal

type Device {
  firmId: String
  structureId: String
  deviceModelId: String
  type: Type
  numberSerial: String
  numberFactory: String
  info: String
  cashboxId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm
  structure: Structure
  deviceModel: DeviceModel
  cashbox: Cashbox
}

type DeviceCollectionSegment {
  items: [Device]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input DeviceFilterInput {
  and: [DeviceFilterInput!]
  or: [DeviceFilterInput!]
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  deviceModelId: StringOperationFilterInput
  deviceModel: DeviceModelFilterInput
  type: TypeOperationFilterInput
  numberSerial: StringOperationFilterInput
  numberFactory: StringOperationFilterInput
  info: StringOperationFilterInput
  cashboxId: StringOperationFilterInput
  cashbox: CashboxFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input DeviceInput {
  firmId: String
  structureId: String
  deviceModelId: String
  type: Type
  numberSerial: String
  numberFactory: String
  info: String
  cashboxId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type DeviceModel {
  type: Int
  model: String
  protocol: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type DeviceModelCollectionSegment {
  items: [DeviceModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input DeviceModelFilterInput {
  and: [DeviceModelFilterInput!]
  or: [DeviceModelFilterInput!]
  type: ComparableInt32OperationFilterInput
  model: StringOperationFilterInput
  protocol: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input DeviceModelInput {
  type: Int
  model: String
  protocol: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type DeviceModelMutation {
  add(model: [DeviceModelInput]): [DeviceModel]
  update(model: [DeviceModelInput]): [DeviceModel]
  addOrUpdate(model: [DeviceModelInput]): [DeviceModel]
  delete(model: [DeviceModelInput]): [DeviceModel]
}

type DeviceModelQuery {
  all(skip: Int, take: Int, where: DeviceModelFilterInput, order: [DeviceModelSortInput!]): DeviceModelCollectionSegment
  userInfo(model: DeviceModelInput): UserInfo
  getByKeys(id: String): [DeviceModel]
}

input DeviceModelSortInput {
  type: SortEnumType
  model: SortEnumType
  protocol: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type DeviceMutation {
  add(model: [DeviceInput]): [Device]
  update(model: [DeviceInput]): [Device]
  addOrUpdate(model: [DeviceInput]): [Device]
  delete(model: [DeviceInput]): [Device]
}

type DeviceQuery {
  all(skip: Int, take: Int, where: DeviceFilterInput, order: [DeviceSortInput!]): DeviceCollectionSegment
  userInfo(model: DeviceInput): UserInfo
  getByKeys(id: String): [Device]
}

input DeviceSortInput {
  firmId: SortEnumType
  firm: FirmSortInput
  structureId: SortEnumType
  structure: StructureSortInput
  deviceModelId: SortEnumType
  deviceModel: DeviceModelSortInput
  type: SortEnumType
  numberSerial: SortEnumType
  numberFactory: SortEnumType
  info: SortEnumType
  cashboxId: SortEnumType
  cashbox: CashboxSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type DiscordReason {
  _raw_json_name: String
  name: [Locale]
  mustBeProcessed: Boolean
  virtualStoreId: String
  isUse: Boolean
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type DiscordReasonCollectionSegment {
  items: [DiscordReason]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input DiscordReasonFilterInput {
  and: [DiscordReasonFilterInput!]
  or: [DiscordReasonFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  mustBeProcessed: BooleanOperationFilterInput
  virtualStoreId: StringOperationFilterInput
  isUse: BooleanOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input DiscordReasonInput {
  name: [LocaleInput!]!
  mustBeProcessed: Boolean
  virtualStoreId: String
  isUse: Boolean
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type DiscordReasonMutation {
  add(model: [DiscordReasonInput]): [DiscordReason]
  update(model: [DiscordReasonInput]): [DiscordReason]
  addOrUpdate(model: [DiscordReasonInput]): [DiscordReason]
  delete(model: [DiscordReasonInput]): [DiscordReason]
}

type DiscordReasonQuery {
  all(skip: Int, take: Int, where: DiscordReasonFilterInput, order: [DiscordReasonSortInput!]): DiscordReasonCollectionSegment
  userInfo(model: DiscordReasonInput): UserInfo
  getByKeys(id: String): [DiscordReason]
}

input DiscordReasonSortInput {
  mustBeProcessed: SortEnumType
  virtualStoreId: SortEnumType
  isUse: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Doctor {
  _raw_json_name: String
  name: [Locale]
  clinicId: String
  specialityId: String
  percent: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  clinic: Structure!
  speciality: Speciality!
}

type DoctorCollectionSegment {
  items: [Doctor]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input DoctorFilterInput {
  and: [DoctorFilterInput!]
  or: [DoctorFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  clinicId: StringOperationFilterInput
  clinic: StructureFilterInput
  specialityId: StringOperationFilterInput
  speciality: SpecialityFilterInput
  percent: ComparableNullableOfDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input DoctorInput {
  name: [LocaleInput!]!
  clinicId: String
  specialityId: String
  percent: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type DoctorMutation {
  add(model: [DoctorInput]): [Doctor]
  update(model: [DoctorInput]): [Doctor]
  addOrUpdate(model: [DoctorInput]): [Doctor]
  delete(model: [DoctorInput]): [Doctor]
}

type DoctorQuery {
  all(skip: Int, take: Int, where: DoctorFilterInput, order: [DoctorSortInput!]): DoctorCollectionSegment
  userInfo(model: DoctorInput): UserInfo
  getByKeys(id: String): [Doctor]
}

input DoctorSortInput {
  clinicId: SortEnumType
  clinic: StructureSortInput
  specialityId: SortEnumType
  speciality: SpecialitySortInput
  percent: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type DocumentsNumber {
  structureNumber: String
  documentType: String
  documentNumber: Int
  dateReset: DateTime
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  numberString: String
}

type DocumentsNumberCollectionSegment {
  items: [DocumentsNumber]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input DocumentsNumberFilterInput {
  and: [DocumentsNumberFilterInput!]
  or: [DocumentsNumberFilterInput!]
  structureNumber: StringOperationFilterInput
  documentType: StringOperationFilterInput
  documentNumber: ComparableInt32OperationFilterInput
  dateReset: ComparableDateTimeOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input DocumentsNumberInput {
  structureNumber: String
  documentType: String
  documentNumber: Int
  dateReset: DateTime
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type DocumentsNumberMutation {
  add(model: [DocumentsNumberInput]): [DocumentsNumber]
  update(model: [DocumentsNumberInput]): [DocumentsNumber]
  addOrUpdate(model: [DocumentsNumberInput]): [DocumentsNumber]
  delete(model: [DocumentsNumberInput]): [DocumentsNumber]
}

type DocumentsNumberQuery {
  all(skip: Int, take: Int, where: DocumentsNumberFilterInput, order: [DocumentsNumberSortInput!]): DocumentsNumberCollectionSegment
  userInfo(model: DocumentsNumberInput): UserInfo
  getByKeys(id: String): [DocumentsNumber]
}

input DocumentsNumberSortInput {
  structureNumber: SortEnumType
  documentType: SortEnumType
  documentNumber: SortEnumType
  dateReset: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Employee {
  code: String
  _raw_json_surname: String
  surname: [Locale]
  _raw_json_name: String
  name: [Locale]
  _raw_json_patronymic: String
  patronymic: [Locale]
  sex: Int
  birthday: DateTime
  phone: String
  email: String
  addressId: String
  locationAddress: String
  identity: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  address: Address!
}

type EmployeeCollectionSegment {
  items: [Employee]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input EmployeeFilterInput {
  and: [EmployeeFilterInput!]
  or: [EmployeeFilterInput!]
  code: StringOperationFilterInput
  surname: ListFilterInputTypeOfLocaleFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  patronymic: ListFilterInputTypeOfLocaleFilterInput
  sex: ComparableInt32OperationFilterInput
  birthday: ComparableNullableOfDateTimeOperationFilterInput
  phone: StringOperationFilterInput
  email: StringOperationFilterInput
  addressId: StringOperationFilterInput
  address: AddressFilterInput
  locationAddress: StringOperationFilterInput
  identity: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input EmployeeInput {
  code: String
  surname: [LocaleInput!]!
  name: [LocaleInput!]!
  patronymic: [LocaleInput!]!
  sex: Int
  birthday: DateTime
  phone: String
  email: String
  addressId: String
  locationAddress: String
  identity: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type EmployeeMutation {
  add(model: [EmployeeInput]): [Employee]
  update(model: [EmployeeInput]): [Employee]
  addOrUpdate(model: [EmployeeInput]): [Employee]
  delete(model: [EmployeeInput]): [Employee]
}

type EmployeeQuery {
  all(skip: Int, take: Int, where: EmployeeFilterInput, order: [EmployeeSortInput!]): EmployeeCollectionSegment
  userInfo(model: EmployeeInput): UserInfo
  getByKeys(id: String): [Employee]
}

type EmployeeSalesAnalysisModel {
  employeePersonalNumber: String
  employeeShort: String
  post: String
  workedHours: Decimal
  receiptsAmount: Int
  averageCheck: Decimal
  packageQty: Decimal
  averagePositionsQty: Decimal
}

type EmployeeSalesAnalysisModelCollectionSegment {
  items: [EmployeeSalesAnalysisModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input EmployeeSalesAnalysisModelFilterInput {
  and: [EmployeeSalesAnalysisModelFilterInput!]
  or: [EmployeeSalesAnalysisModelFilterInput!]
  employeePersonalNumber: StringOperationFilterInput
  employeeShort: StringOperationFilterInput
  post: StringOperationFilterInput
  workedHours: ComparableNullableOfDecimalOperationFilterInput
  receiptsAmount: ComparableNullableOfInt32OperationFilterInput
  averageCheck: ComparableNullableOfDecimalOperationFilterInput
  packageQty: ComparableNullableOfDecimalOperationFilterInput
  averagePositionsQty: ComparableNullableOfDecimalOperationFilterInput
}

input EmployeeSalesAnalysisModelSortInput {
  employeePersonalNumber: SortEnumType
  employeeShort: SortEnumType
  post: SortEnumType
  workedHours: SortEnumType
  receiptsAmount: SortEnumType
  averageCheck: SortEnumType
  packageQty: SortEnumType
  averagePositionsQty: SortEnumType
}

input EmployeeSortInput {
  code: SortEnumType
  sex: SortEnumType
  birthday: SortEnumType
  phone: SortEnumType
  email: SortEnumType
  addressId: SortEnumType
  address: AddressSortInput
  locationAddress: SortEnumType
  identity: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type EnumInfo {
  key: String
  label: String
  value: Long!
}

type EnumQueries {
  constantList(typeName: String): [EnumInfo]
}

type ExpiringRegistrationForRestsModel {
  productId: String
  productName: [Locale!]!
  partyBaseId: String
  productSeries: String
  registerDateEnd: DateTime
  amount: Decimal!
}

type ExpiringRegistrationForRestsModelCollectionSegment {
  items: [ExpiringRegistrationForRestsModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ExpiringRegistrationForRestsModelFilterInput {
  and: [ExpiringRegistrationForRestsModelFilterInput!]
  or: [ExpiringRegistrationForRestsModelFilterInput!]
  productId: StringOperationFilterInput
  productName: ListFilterInputTypeOfLocaleFilterInput
  partyBaseId: StringOperationFilterInput
  productSeries: StringOperationFilterInput
  registerDateEnd: ComparableNullableOfDateTimeOperationFilterInput
  amount: ComparableDecimalOperationFilterInput
}

input ExpiringRegistrationForRestsModelSortInput {
  productId: SortEnumType
  partyBaseId: SortEnumType
  productSeries: SortEnumType
  registerDateEnd: SortEnumType
  amount: SortEnumType
}

type ExportMutation {
  exportDocumentsToBackOffice: Boolean!
  exportTimesheetsToBackOffice: Boolean!
}

type ExtDrugstore {
  name: String
  structureId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExtDrugstoreCollectionSegment {
  items: [ExtDrugstore]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ExtDrugstoreFilterInput {
  and: [ExtDrugstoreFilterInput!]
  or: [ExtDrugstoreFilterInput!]
  name: StringOperationFilterInput
  structureId: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ExtDrugstoreInput {
  name: String
  structureId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExtDrugstoreMutation {
  add(model: [ExtDrugstoreInput]): [ExtDrugstore]
  update(model: [ExtDrugstoreInput]): [ExtDrugstore]
  addOrUpdate(model: [ExtDrugstoreInput]): [ExtDrugstore]
  delete(model: [ExtDrugstoreInput]): [ExtDrugstore]
}

type ExtDrugstoreQuery {
  all(skip: Int, take: Int, where: ExtDrugstoreFilterInput, order: [ExtDrugstoreSortInput!]): ExtDrugstoreCollectionSegment
  userInfo(model: ExtDrugstoreInput): UserInfo
  getByKeys(id: String): [ExtDrugstore]
}

input ExtDrugstoreSortInput {
  name: SortEnumType
  structureId: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ExternalPriceList {
  productId: String
  extProductId: String
  supplierId: String
  morionCode: String
  supplierCode: String
  extMaker: String
  extVAT: String
  extValue: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  supplier: Firm!
}

type ExternalPriceListCollectionSegment {
  items: [ExternalPriceList]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ExternalPriceListFilterInput {
  and: [ExternalPriceListFilterInput!]
  or: [ExternalPriceListFilterInput!]
  productId: StringOperationFilterInput
  product: ProductFilterInput
  extProductId: StringOperationFilterInput
  supplierId: StringOperationFilterInput
  supplier: FirmFilterInput
  morionCode: StringOperationFilterInput
  supplierCode: StringOperationFilterInput
  extMaker: StringOperationFilterInput
  extVAT: StringOperationFilterInput
  extValue: ComparableDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ExternalPriceListInput {
  productId: String
  extProductId: String
  supplierId: String
  morionCode: String
  supplierCode: String
  extMaker: String
  extVAT: String
  extValue: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExternalPriceListMutation {
  add(model: [ExternalPriceListInput]): [ExternalPriceList]
  update(model: [ExternalPriceListInput]): [ExternalPriceList]
  addOrUpdate(model: [ExternalPriceListInput]): [ExternalPriceList]
  delete(model: [ExternalPriceListInput]): [ExternalPriceList]
}

type ExternalPriceListQuery {
  all(skip: Int, take: Int, where: ExternalPriceListFilterInput, order: [ExternalPriceListSortInput!]): ExternalPriceListCollectionSegment
  userInfo(model: ExternalPriceListInput): UserInfo
  getByKeys(id: String): [ExternalPriceList]
}

input ExternalPriceListSortInput {
  productId: SortEnumType
  product: ProductSortInput
  extProductId: SortEnumType
  supplierId: SortEnumType
  supplier: FirmSortInput
  morionCode: SortEnumType
  supplierCode: SortEnumType
  extMaker: SortEnumType
  extVAT: SortEnumType
  extValue: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ExternalReceipt {
  type: Int
  status: Int
  salesChannelCard: String
  loyaltyCard: String
  comment: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExternalReceiptCollectionSegment {
  items: [ExternalReceipt]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type ExternalReceiptDelivery {
  fio: String
  phone: String
  address: String
  comment: String
  externalReceiptId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  externalReceipt: ExternalReceipt!
}

type ExternalReceiptDeliveryCollectionSegment {
  items: [ExternalReceiptDelivery]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ExternalReceiptDeliveryFilterInput {
  and: [ExternalReceiptDeliveryFilterInput!]
  or: [ExternalReceiptDeliveryFilterInput!]
  fio: StringOperationFilterInput
  phone: StringOperationFilterInput
  address: StringOperationFilterInput
  comment: StringOperationFilterInput
  externalReceiptId: StringOperationFilterInput
  externalReceipt: ExternalReceiptFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ExternalReceiptDeliveryInput {
  fio: String
  phone: String
  address: String
  comment: String
  externalReceiptId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExternalReceiptDeliveryMutation {
  add(model: [ExternalReceiptDeliveryInput]): [ExternalReceiptDelivery]
  update(model: [ExternalReceiptDeliveryInput]): [ExternalReceiptDelivery]
  addOrUpdate(model: [ExternalReceiptDeliveryInput]): [ExternalReceiptDelivery]
  delete(model: [ExternalReceiptDeliveryInput]): [ExternalReceiptDelivery]
}

type ExternalReceiptDeliveryQuery {
  all(skip: Int, take: Int, where: ExternalReceiptDeliveryFilterInput, order: [ExternalReceiptDeliverySortInput!]): ExternalReceiptDeliveryCollectionSegment
  userInfo(model: ExternalReceiptDeliveryInput): UserInfo
  getByKeys(id: String): [ExternalReceiptDelivery]
}

input ExternalReceiptDeliverySortInput {
  fio: SortEnumType
  phone: SortEnumType
  address: SortEnumType
  comment: SortEnumType
  externalReceiptId: SortEnumType
  externalReceipt: ExternalReceiptSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input ExternalReceiptFilterInput {
  and: [ExternalReceiptFilterInput!]
  or: [ExternalReceiptFilterInput!]
  type: ComparableInt32OperationFilterInput
  status: ComparableInt32OperationFilterInput
  salesChannelCard: StringOperationFilterInput
  loyaltyCard: StringOperationFilterInput
  comment: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ExternalReceiptInput {
  type: Int
  status: Int
  salesChannelCard: String
  loyaltyCard: String
  comment: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExternalReceiptInsurer {
  insurerOrderId: String
  insurerName: String
  clientFio: String
  clientCard: String
  franchisePercent: Decimal
  comment: String
  externalReceiptId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  externalReceipt: ExternalReceipt!
}

type ExternalReceiptInsurerCollectionSegment {
  items: [ExternalReceiptInsurer]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ExternalReceiptInsurerFilterInput {
  and: [ExternalReceiptInsurerFilterInput!]
  or: [ExternalReceiptInsurerFilterInput!]
  insurerOrderId: StringOperationFilterInput
  insurerName: StringOperationFilterInput
  clientFio: StringOperationFilterInput
  clientCard: StringOperationFilterInput
  franchisePercent: ComparableDecimalOperationFilterInput
  comment: StringOperationFilterInput
  externalReceiptId: StringOperationFilterInput
  externalReceipt: ExternalReceiptFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ExternalReceiptInsurerInput {
  insurerOrderId: String
  insurerName: String
  clientFio: String
  clientCard: String
  franchisePercent: Decimal
  comment: String
  externalReceiptId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExternalReceiptInsurerMutation {
  add(model: [ExternalReceiptInsurerInput]): [ExternalReceiptInsurer]
  update(model: [ExternalReceiptInsurerInput]): [ExternalReceiptInsurer]
  addOrUpdate(model: [ExternalReceiptInsurerInput]): [ExternalReceiptInsurer]
  delete(model: [ExternalReceiptInsurerInput]): [ExternalReceiptInsurer]
}

type ExternalReceiptInsurerQuery {
  all(skip: Int, take: Int, where: ExternalReceiptInsurerFilterInput, order: [ExternalReceiptInsurerSortInput!]): ExternalReceiptInsurerCollectionSegment
  userInfo(model: ExternalReceiptInsurerInput): UserInfo
  getByKeys(id: String): [ExternalReceiptInsurer]
}

input ExternalReceiptInsurerSortInput {
  insurerOrderId: SortEnumType
  insurerName: SortEnumType
  clientFio: SortEnumType
  clientCard: SortEnumType
  franchisePercent: SortEnumType
  comment: SortEnumType
  externalReceiptId: SortEnumType
  externalReceipt: ExternalReceiptSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ExternalReceiptMutation {
  add(model: [ExternalReceiptInput]): [ExternalReceipt]
  update(model: [ExternalReceiptInput]): [ExternalReceipt]
  addOrUpdate(model: [ExternalReceiptInput]): [ExternalReceipt]
  delete(model: [ExternalReceiptInput]): [ExternalReceipt]
}

type ExternalReceiptProduct {
  article: String
  productName: String
  amount: Decimal
  price: Decimal
  productTag: String
  status: Int
  externalReceiptId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  externalReceipt: ExternalReceipt!
}

type ExternalReceiptProductCollectionSegment {
  items: [ExternalReceiptProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ExternalReceiptProductFilterInput {
  and: [ExternalReceiptProductFilterInput!]
  or: [ExternalReceiptProductFilterInput!]
  article: StringOperationFilterInput
  productName: StringOperationFilterInput
  amount: ComparableDecimalOperationFilterInput
  price: ComparableDecimalOperationFilterInput
  productTag: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  externalReceiptId: StringOperationFilterInput
  externalReceipt: ExternalReceiptFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ExternalReceiptProductInput {
  article: String
  productName: String
  amount: Decimal
  price: Decimal
  productTag: String
  status: Int
  externalReceiptId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ExternalReceiptProductMutation {
  add(model: [ExternalReceiptProductInput]): [ExternalReceiptProduct]
  update(model: [ExternalReceiptProductInput]): [ExternalReceiptProduct]
  addOrUpdate(model: [ExternalReceiptProductInput]): [ExternalReceiptProduct]
  delete(model: [ExternalReceiptProductInput]): [ExternalReceiptProduct]
}

type ExternalReceiptProductQuery {
  all(skip: Int, take: Int, where: ExternalReceiptProductFilterInput, order: [ExternalReceiptProductSortInput!]): ExternalReceiptProductCollectionSegment
  userInfo(model: ExternalReceiptProductInput): UserInfo
  getByKeys(id: String): [ExternalReceiptProduct]
}

input ExternalReceiptProductSortInput {
  article: SortEnumType
  productName: SortEnumType
  amount: SortEnumType
  price: SortEnumType
  productTag: SortEnumType
  status: SortEnumType
  externalReceiptId: SortEnumType
  externalReceipt: ExternalReceiptSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ExternalReceiptQuery {
  all(skip: Int, take: Int, where: ExternalReceiptFilterInput, order: [ExternalReceiptSortInput!]): ExternalReceiptCollectionSegment
  userInfo(model: ExternalReceiptInput): UserInfo
  getByKeys(id: String): [ExternalReceipt]
}

input ExternalReceiptSortInput {
  type: SortEnumType
  status: SortEnumType
  salesChannelCard: SortEnumType
  loyaltyCard: SortEnumType
  comment: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

enum Filters {
  STRUCTURE
  CONTRACTOR
  PRODUCT
  MANUFACTURER
  PRODUCT_BRAND
  PRODUCT_CATEGORY
  PRODUCT_GROUP
  SUBSTANCE
  CONDITION_PAYMENT
}

input FiltersOperationFilterInput {
  eq: Filters
  neq: Filters
  in: [Filters!]
  nin: [Filters!]
}

type Firm {
  code: String
  section: Int
  type: Int
  formOwnId: String
  formOwnCodeChar: String
  _raw_json_nameShort: String
  nameShort: [Locale]
  _raw_json_nameFull: String
  nameFull: [Locale]
  phone: String
  fax: String
  email: String
  seniorPosition: Int
  directorFio: String
  actualAddressId: String
  legalAddressId: String
  blocked: Boolean
  taxIsPay: Boolean
  taxNumber: String
  taxCertNumber: String
  taxCertDate: DateTime
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  formOwn: FormOwn
  actualAddress: Address
  legalAddress: Address
  groups: [FirmGroup!]
  accounts: [FirmAccount!]
  employees: [FirmEmployee!]
  structures: [Structure!]
}

type FirmAccount {
  id: String
  firmId: String
  account: String
  currencyId: String
  bankId: String
  bankName: String
  isDefault: Boolean
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm!
  currency: Currency!
  bank: Bank!
}

type FirmAccountCollectionSegment {
  items: [FirmAccount]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input FirmAccountFilterInput {
  and: [FirmAccountFilterInput!]
  or: [FirmAccountFilterInput!]
  id: StringOperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  account: StringOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  bankId: StringOperationFilterInput
  bank: BankFilterInput
  bankName: StringOperationFilterInput
  isDefault: BooleanOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input FirmAccountInput {
  id: String
  firmId: String
  account: String
  currencyId: String
  bankId: String
  bankName: String
  isDefault: Boolean
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FirmAccountMutation {
  add(model: [FirmAccountInput]): [FirmAccount]
  update(model: [FirmAccountInput]): [FirmAccount]
  addOrUpdate(model: [FirmAccountInput]): [FirmAccount]
  delete(model: [FirmAccountInput]): [FirmAccount]
}

type FirmAccountQuery {
  all(skip: Int, take: Int, where: FirmAccountFilterInput, order: [FirmAccountSortInput!]): FirmAccountCollectionSegment
  userInfo(model: FirmAccountInput): UserInfo
  getByKeys(id: String): [FirmAccount]
}

input FirmAccountSortInput {
  id: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  account: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  bankId: SortEnumType
  bank: BankSortInput
  bankName: SortEnumType
  isDefault: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type FirmBase {
  code: String
  formOwnCodeChar: String
  nameShort: [Locale!]!
  nameFull: [Locale!]!
}

input FirmBaseFilterInput {
  and: [FirmBaseFilterInput!]
  or: [FirmBaseFilterInput!]
  code: StringOperationFilterInput
  formOwnCodeChar: StringOperationFilterInput
  nameShort: ListFilterInputTypeOfLocaleFilterInput
  nameFull: ListFilterInputTypeOfLocaleFilterInput
}

input FirmBaseInput {
  code: String
  formOwnCodeChar: String
  nameShort: [LocaleInput!]!
  nameFull: [LocaleInput!]!
}

input FirmBaseSortInput {
  code: SortEnumType
  formOwnCodeChar: SortEnumType
}

type FirmCollectionSegment {
  items: [Firm]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type FirmEmployee {
  firmId: String
  employeeId: String
  employeeShort: String
  postId: String
  postName: String
  info: String
  structureId: String
  isAuthorizeCashbox: Boolean
  personalNumber: String
  employmentType: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm
  employee: Employee
  post: Post
  structure: Structure
  users: [User!]
}

type FirmEmployeeBase {
  id: String
  firmId: String
  structureId: String
  employeeId: String
  employeeShort: String
}

input FirmEmployeeBaseFilterInput {
  and: [FirmEmployeeBaseFilterInput!]
  or: [FirmEmployeeBaseFilterInput!]
  id: StringOperationFilterInput
  firmId: StringOperationFilterInput
  structureId: StringOperationFilterInput
  employeeId: StringOperationFilterInput
  employeeShort: StringOperationFilterInput
}

input FirmEmployeeBaseInput {
  id: String
  firmId: String
  structureId: String
  employeeId: String
  employeeShort: String
}

input FirmEmployeeBaseSortInput {
  id: SortEnumType
  firmId: SortEnumType
  structureId: SortEnumType
  employeeId: SortEnumType
  employeeShort: SortEnumType
}

type FirmEmployeeCollectionSegment {
  items: [FirmEmployee]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input FirmEmployeeFilterInput {
  and: [FirmEmployeeFilterInput!]
  or: [FirmEmployeeFilterInput!]
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  employeeId: StringOperationFilterInput
  employee: EmployeeFilterInput
  employeeShort: StringOperationFilterInput
  postId: StringOperationFilterInput
  post: PostFilterInput
  postName: StringOperationFilterInput
  info: StringOperationFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  isAuthorizeCashbox: BooleanOperationFilterInput
  personalNumber: StringOperationFilterInput
  employmentType: ComparableInt32OperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input FirmEmployeeInput {
  firmId: String
  employeeId: String
  employeeShort: String
  postId: String
  postName: String
  info: String
  structureId: String
  isAuthorizeCashbox: Boolean
  personalNumber: String
  employmentType: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FirmEmployeeMutation {
  add(model: [FirmEmployeeInput]): [FirmEmployee]
  update(model: [FirmEmployeeInput]): [FirmEmployee]
  addOrUpdate(model: [FirmEmployeeInput]): [FirmEmployee]
  delete(model: [FirmEmployeeInput]): [FirmEmployee]
}

type FirmEmployeeQuery {
  all(skip: Int, take: Int, where: FirmEmployeeFilterInput, order: [FirmEmployeeSortInput!]): FirmEmployeeCollectionSegment
  userInfo(model: FirmEmployeeInput): UserInfo
  getByKeys(id: String): [FirmEmployee]
}

input FirmEmployeeSortInput {
  firmId: SortEnumType
  firm: FirmSortInput
  employeeId: SortEnumType
  employee: EmployeeSortInput
  employeeShort: SortEnumType
  postId: SortEnumType
  post: PostSortInput
  postName: SortEnumType
  info: SortEnumType
  structureId: SortEnumType
  structure: StructureSortInput
  isAuthorizeCashbox: SortEnumType
  personalNumber: SortEnumType
  employmentType: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input FirmFilterInput {
  and: [FirmFilterInput!]
  or: [FirmFilterInput!]
  code: StringOperationFilterInput
  section: ComparableInt32OperationFilterInput
  type: ComparableInt32OperationFilterInput
  formOwnId: StringOperationFilterInput
  formOwn: FormOwnFilterInput
  formOwnCodeChar: StringOperationFilterInput
  nameShort: ListFilterInputTypeOfLocaleFilterInput
  nameFull: ListFilterInputTypeOfLocaleFilterInput
  phone: StringOperationFilterInput
  fax: StringOperationFilterInput
  email: StringOperationFilterInput
  seniorPosition: ComparableInt32OperationFilterInput
  directorFio: StringOperationFilterInput
  actualAddressId: StringOperationFilterInput
  actualAddress: AddressFilterInput
  legalAddressId: StringOperationFilterInput
  legalAddress: AddressFilterInput
  blocked: BooleanOperationFilterInput
  taxIsPay: BooleanOperationFilterInput
  taxNumber: StringOperationFilterInput
  taxCertNumber: StringOperationFilterInput
  taxCertDate: ComparableNullableOfDateTimeOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

type FirmGroup {
  id: String
  firmId: String
  groupFirmId: String
  groupFirmName: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm!
  groupFirm: GroupFirm!
}

type FirmGroupCollectionSegment {
  items: [FirmGroup]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input FirmGroupFilterInput {
  and: [FirmGroupFilterInput!]
  or: [FirmGroupFilterInput!]
  id: StringOperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  groupFirmId: StringOperationFilterInput
  groupFirm: GroupFirmFilterInput
  groupFirmName: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input FirmGroupInput {
  id: String
  firmId: String
  groupFirmId: String
  groupFirmName: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FirmGroupMutation {
  add(model: [FirmGroupInput]): [FirmGroup]
  update(model: [FirmGroupInput]): [FirmGroup]
  addOrUpdate(model: [FirmGroupInput]): [FirmGroup]
  delete(model: [FirmGroupInput]): [FirmGroup]
}

type FirmGroupQuery {
  all(skip: Int, take: Int, where: FirmGroupFilterInput, order: [FirmGroupSortInput!]): FirmGroupCollectionSegment
  userInfo(model: FirmGroupInput): UserInfo
  getByKeys(id: String): [FirmGroup]
}

input FirmGroupSortInput {
  id: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  groupFirmId: SortEnumType
  groupFirm: GroupFirmSortInput
  groupFirmName: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input FirmInput {
  code: String
  section: Int
  type: Int
  formOwnId: String
  formOwnCodeChar: String
  nameShort: [LocaleInput!]
  nameFull: [LocaleInput!]
  phone: String
  fax: String
  email: String
  seniorPosition: Int
  directorFio: String
  actualAddressId: String
  legalAddressId: String
  blocked: Boolean
  taxIsPay: Boolean
  taxNumber: String
  taxCertNumber: String
  taxCertDate: DateTime
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FirmMutation {
  add(model: [FirmInput]): [Firm]
  update(model: [FirmInput]): [Firm]
  addOrUpdate(model: [FirmInput]): [Firm]
  delete(model: [FirmInput]): [Firm]
}

type FirmQueries {
  firmByType(type: Int!, where: FirmFilterInput): [Firm]
  firmByTypeCount(type: Int!): Int!
}

type FirmQuery {
  all(skip: Int, take: Int, where: FirmFilterInput, order: [FirmSortInput!]): FirmCollectionSegment
  userInfo(model: FirmInput): UserInfo
  getByKeys(id: String): [Firm]
}

type FirmSetting {
  id: String
  policy: Int
  currencyId: String
  dateMoveActual: DateTime
  dateMoveTabu: DateTime
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  currency: Currency!
  firm: Firm!
}

type FirmSettingCollectionSegment {
  items: [FirmSetting]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input FirmSettingFilterInput {
  and: [FirmSettingFilterInput!]
  or: [FirmSettingFilterInput!]
  id: StringOperationFilterInput
  policy: ComparableInt32OperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  dateMoveActual: ComparableDateTimeOperationFilterInput
  dateMoveTabu: ComparableDateTimeOperationFilterInput
  firm: FirmFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input FirmSettingInput {
  id: String
  policy: Int
  currencyId: String
  dateMoveActual: DateTime
  dateMoveTabu: DateTime
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FirmSettingMutation {
  add(model: [FirmSettingInput]): [FirmSetting]
  update(model: [FirmSettingInput]): [FirmSetting]
  addOrUpdate(model: [FirmSettingInput]): [FirmSetting]
  delete(model: [FirmSettingInput]): [FirmSetting]
}

type FirmSettingQuery {
  all(skip: Int, take: Int, where: FirmSettingFilterInput, order: [FirmSettingSortInput!]): FirmSettingCollectionSegment
  userInfo(model: FirmSettingInput): UserInfo
  getByKeys(id: String): [FirmSetting]
}

input FirmSettingSortInput {
  id: SortEnumType
  policy: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  dateMoveActual: SortEnumType
  dateMoveTabu: SortEnumType
  firm: FirmSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input FirmSortInput {
  code: SortEnumType
  section: SortEnumType
  type: SortEnumType
  formOwnId: SortEnumType
  formOwn: FormOwnSortInput
  formOwnCodeChar: SortEnumType
  phone: SortEnumType
  fax: SortEnumType
  email: SortEnumType
  seniorPosition: SortEnumType
  directorFio: SortEnumType
  actualAddressId: SortEnumType
  actualAddress: AddressSortInput
  legalAddressId: SortEnumType
  legalAddress: AddressSortInput
  blocked: SortEnumType
  taxIsPay: SortEnumType
  taxNumber: SortEnumType
  taxCertNumber: SortEnumType
  taxCertDate: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type FormFactory {
  _raw_json_group: String
  group: [Locale]
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FormFactoryCollectionSegment {
  items: [FormFactory]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input FormFactoryFilterInput {
  and: [FormFactoryFilterInput!]
  or: [FormFactoryFilterInput!]
  group: ListFilterInputTypeOfLocaleFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input FormFactoryInput {
  group: [LocaleInput!]!
  name: [LocaleInput!]!
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FormFactoryMutation {
  add(model: [FormFactoryInput]): [FormFactory]
  update(model: [FormFactoryInput]): [FormFactory]
  addOrUpdate(model: [FormFactoryInput]): [FormFactory]
  delete(model: [FormFactoryInput]): [FormFactory]
}

type FormFactoryQuery {
  all(skip: Int, take: Int, where: FormFactoryFilterInput, order: [FormFactorySortInput!]): FormFactoryCollectionSegment
  userInfo(model: FormFactoryInput): UserInfo
  getByKeys(id: String): [FormFactory]
}

input FormFactorySortInput {
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type FormOwn {
  codeNum: Int
  codeChar: String
  _raw_json_name: String
  name: [Locale]
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FormOwnCollectionSegment {
  items: [FormOwn]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input FormOwnFilterInput {
  and: [FormOwnFilterInput!]
  or: [FormOwnFilterInput!]
  codeNum: ComparableInt32OperationFilterInput
  codeChar: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  isUse: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input FormOwnInput {
  codeNum: Int
  codeChar: String
  name: [LocaleInput!]!
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type FormOwnMutation {
  add(model: [FormOwnInput]): [FormOwn]
  update(model: [FormOwnInput]): [FormOwn]
  addOrUpdate(model: [FormOwnInput]): [FormOwn]
  delete(model: [FormOwnInput]): [FormOwn]
}

type FormOwnQuery {
  all(skip: Int, take: Int, where: FormOwnFilterInput, order: [FormOwnSortInput!]): FormOwnCollectionSegment
  userInfo(model: FormOwnInput): UserInfo
  getByKeys(id: String): [FormOwn]
}

input FormOwnSortInput {
  codeNum: SortEnumType
  codeChar: SortEnumType
  isUse: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

enum GoodsMovementFilters {
  PRODUCT
  PARTY
  DOCUMENT
}

input GoodsMovementFiltersOperationFilterInput {
  eq: GoodsMovementFilters
  neq: GoodsMovementFilters
  in: [GoodsMovementFilters!]
  nin: [GoodsMovementFilters!]
}

type GoodsMovementNode {
  data: GoodsMovementValues!
  children: [GoodsMovementNode!]
}

type GoodsMovementNodeCollectionSegment {
  items: [GoodsMovementNode]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input GoodsMovementNodeFilterInput {
  and: [GoodsMovementNodeFilterInput!]
  or: [GoodsMovementNodeFilterInput!]
  data: GoodsMovementValuesFilterInput
  children: ListFilterInputTypeOfGoodsMovementNodeFilterInput
}

input GoodsMovementNodeSortInput {
  data: GoodsMovementValuesSortInput
}

type GoodsMovementValues {
  nodeLevel: Int!
  value: String
  type: GoodsMovementFilters!
  initialRestsAmount: Decimal!
  amountIn: Decimal!
  amountOut: Decimal!
  finalRestsAmount: Decimal!
}

input GoodsMovementValuesFilterInput {
  and: [GoodsMovementValuesFilterInput!]
  or: [GoodsMovementValuesFilterInput!]
  nodeLevel: ComparableInt32OperationFilterInput
  value: StringOperationFilterInput
  type: GoodsMovementFiltersOperationFilterInput
  initialRestsAmount: ComparableDecimalOperationFilterInput
  amountIn: ComparableDecimalOperationFilterInput
  amountOut: ComparableDecimalOperationFilterInput
  finalRestsAmount: ComparableDecimalOperationFilterInput
}

input GoodsMovementValuesSortInput {
  nodeLevel: SortEnumType
  value: SortEnumType
  type: SortEnumType
  initialRestsAmount: SortEnumType
  amountIn: SortEnumType
  amountOut: SortEnumType
  finalRestsAmount: SortEnumType
}

type GroupFirm {
  _raw_json_name: String
  name: [Locale]
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type GroupFirmCollectionSegment {
  items: [GroupFirm]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input GroupFirmFilterInput {
  and: [GroupFirmFilterInput!]
  or: [GroupFirmFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input GroupFirmInput {
  name: [LocaleInput!]!
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type GroupFirmMutation {
  add(model: [GroupFirmInput]): [GroupFirm]
  update(model: [GroupFirmInput]): [GroupFirm]
  addOrUpdate(model: [GroupFirmInput]): [GroupFirm]
  delete(model: [GroupFirmInput]): [GroupFirm]
}

type GroupFirmQuery {
  all(skip: Int, take: Int, where: GroupFirmFilterInput, order: [GroupFirmSortInput!]): GroupFirmCollectionSegment
  userInfo(model: GroupFirmInput): UserInfo
  getByKeys(id: String): [GroupFirm]
}

input GroupFirmSortInput {
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type GroupPrice {
  code: String
  _raw_json_name: String
  name: [Locale]
  valueMin: Decimal
  valueMax: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type GroupPriceCollectionSegment {
  items: [GroupPrice]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input GroupPriceFilterInput {
  and: [GroupPriceFilterInput!]
  or: [GroupPriceFilterInput!]
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  valueMin: ComparableNullableOfDecimalOperationFilterInput
  valueMax: ComparableNullableOfDecimalOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input GroupPriceInput {
  code: String
  name: [LocaleInput!]!
  valueMin: Decimal
  valueMax: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type GroupPriceMutation {
  add(model: [GroupPriceInput]): [GroupPrice]
  update(model: [GroupPriceInput]): [GroupPrice]
  addOrUpdate(model: [GroupPriceInput]): [GroupPrice]
  delete(model: [GroupPriceInput]): [GroupPrice]
}

type GroupPriceQuery {
  all(skip: Int, take: Int, where: GroupPriceFilterInput, order: [GroupPriceSortInput!]): GroupPriceCollectionSegment
  userInfo(model: GroupPriceInput): UserInfo
  getByKeys(id: String): [GroupPrice]
}

input GroupPriceSortInput {
  code: SortEnumType
  valueMin: SortEnumType
  valueMax: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type IlliquidGoodsModel {
  productId: String
  productName: [Locale!]!
  initialRestsSum: Decimal
  sumIn: Decimal
  sumOut: Decimal
  finalRestsSum: Decimal
}

type IlliquidGoodsModelCollectionSegment {
  items: [IlliquidGoodsModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input IlliquidGoodsModelFilterInput {
  and: [IlliquidGoodsModelFilterInput!]
  or: [IlliquidGoodsModelFilterInput!]
  productId: StringOperationFilterInput
  productName: ListFilterInputTypeOfLocaleFilterInput
  initialRestsSum: ComparableNullableOfDecimalOperationFilterInput
  sumIn: ComparableNullableOfDecimalOperationFilterInput
  sumOut: ComparableNullableOfDecimalOperationFilterInput
  finalRestsSum: ComparableNullableOfDecimalOperationFilterInput
}

input IlliquidGoodsModelSortInput {
  productId: SortEnumType
  initialRestsSum: SortEnumType
  sumIn: SortEnumType
  sumOut: SortEnumType
  finalRestsSum: SortEnumType
}

type ImageLink {
  link: String
}

input ImageLinkFilterInput {
  and: [ImageLinkFilterInput!]
  or: [ImageLinkFilterInput!]
  link: StringOperationFilterInput
}

input ImageLinkInput {
  link: String
}

type IncomingGoodsReportNode {
  data: IncomingGoodsReportValues!
  children: [IncomingGoodsReportNode!]
}

type IncomingGoodsReportNodeCollectionSegment {
  items: [IncomingGoodsReportNode]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input IncomingGoodsReportNodeFilterInput {
  and: [IncomingGoodsReportNodeFilterInput!]
  or: [IncomingGoodsReportNodeFilterInput!]
  data: IncomingGoodsReportValuesFilterInput
  children: ListFilterInputTypeOfIncomingGoodsReportNodeFilterInput
}

input IncomingGoodsReportNodeSortInput {
  data: IncomingGoodsReportValuesSortInput
}

type IncomingGoodsReportValues {
  nodeLevel: Int!
  value: String
  type: Filters!
  amount: Decimal!
  sum: Decimal!
}

input IncomingGoodsReportValuesFilterInput {
  and: [IncomingGoodsReportValuesFilterInput!]
  or: [IncomingGoodsReportValuesFilterInput!]
  nodeLevel: ComparableInt32OperationFilterInput
  value: StringOperationFilterInput
  type: FiltersOperationFilterInput
  amount: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
}

input IncomingGoodsReportValuesSortInput {
  nodeLevel: SortEnumType
  value: SortEnumType
  type: SortEnumType
  amount: SortEnumType
  sum: SortEnumType
}

type InsuranceCompanyReportModel {
  policy: String
  fio: String
  date: DateTime!
  taxRateId: String!
  partyBaseId: String!
  productId: String!
  productName: [Locale!]!
  amount: Decimal!
  price: Decimal!
  sum: Decimal!
}

type InsuranceCompanyReportModelCollectionSegment {
  items: [InsuranceCompanyReportModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InsuranceCompanyReportModelFilterInput {
  and: [InsuranceCompanyReportModelFilterInput!]
  or: [InsuranceCompanyReportModelFilterInput!]
  policy: StringOperationFilterInput
  fio: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  taxRateId: StringOperationFilterInput
  partyBaseId: StringOperationFilterInput
  productId: StringOperationFilterInput
  productName: ListFilterInputTypeOfLocaleFilterInput
  amount: ComparableDecimalOperationFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
}

input InsuranceCompanyReportModelSortInput {
  policy: SortEnumType
  fio: SortEnumType
  date: SortEnumType
  taxRateId: SortEnumType
  partyBaseId: SortEnumType
  productId: SortEnumType
  amount: SortEnumType
  price: SortEnumType
  sum: SortEnumType
}

type Inventory {
  globalCode: String
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  inventoryType: Int
  number: String
  expectedEndTime: DateTime
  purposeId: String
  firmStructureId: String
  firmStoreId: String
  firmEmployeeId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  purpose: InventoryPurpose
  firmStructure: Structure
  firmStructureJson: Structure
  firmStore: Store
  firmStoreJson: Store
  firmEmployee: FirmEmployee
  firmEmployeeJson: FirmEmployee
}

type InventoryCollectionSegment {
  items: [Inventory]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InventoryDataInput {
  inventoryType: Int!
  finalInventoryDate: DateTime!
  comment: String!
  scanAmount: Int!
  purposeId: String!
}

input InventoryFilterInput {
  and: [InventoryFilterInput!]
  or: [InventoryFilterInput!]
  globalCode: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  inventoryType: ComparableInt32OperationFilterInput
  number: StringOperationFilterInput
  expectedEndTime: ComparableDateTimeOperationFilterInput
  purposeId: StringOperationFilterInput
  purpose: InventoryPurposeFilterInput
  firmStructureId: StringOperationFilterInput
  firmStructure: StructureFilterInput
  firmStructureJson: StructureFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreFilterInput
  firmEmployeeId: StringOperationFilterInput
  firmEmployee: FirmEmployeeFilterInput
  firmEmployeeJson: FirmEmployeeFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InventoryInput {
  globalCode: String
  status: Int
  statusHistory: [StatusHistoryInput!]
  inventoryType: Int
  number: String
  expectedEndTime: DateTime
  purposeId: String
  firmStructureId: String
  firmStructureJson: StructureInput
  firmStoreId: String
  firmStoreJson: StoreInput
  firmEmployeeId: String
  firmEmployeeJson: FirmEmployeeInput
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InventoryMutation {
  add(model: [InventoryInput]): [Inventory]
  update(model: [InventoryInput]): [Inventory]
  addOrUpdate(model: [InventoryInput]): [Inventory]
  delete(model: [InventoryInput]): [Inventory]
}

type InventoryMutations {
  create(data: InventoryDataInput): Inventory
  moveDo(id: String): Boolean!
  moveBack(id: String): Boolean!
}

type InventoryProduct {
  inventoryId: String
  productId: String
  unitId: String
  restComp: Decimal
  restDateTime: DateTime
  restRefinedComp: Decimal
  restFact: Decimal
  restFactDateTime: DateTime
  difAmount: Decimal
  salePrice: Decimal
  getPrice: Decimal
  partyFirmQuantityId: String
  storeFrameId: String
  taxRateId: String
  partyBaseId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  inventory: Inventory
  product: Product
  productJson: Product
  unit: Unit
  unitJson: Unit
  storeFrame: StoreFrame
  taxRate: TaxRate
  taxRateJson: TaxRate
  partyBase: PartyBase
  series: String
}

type InventoryProductCollectionSegment {
  items: [InventoryProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InventoryProductFilterInput {
  and: [InventoryProductFilterInput!]
  or: [InventoryProductFilterInput!]
  inventoryId: StringOperationFilterInput
  inventory: InventoryFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  restComp: ComparableDecimalOperationFilterInput
  restDateTime: ComparableDateTimeOperationFilterInput
  restRefinedComp: ComparableDecimalOperationFilterInput
  restFact: ComparableDecimalOperationFilterInput
  restFactDateTime: ComparableNullableOfDateTimeOperationFilterInput
  difAmount: ComparableDecimalOperationFilterInput
  salePrice: ComparableDecimalOperationFilterInput
  getPrice: ComparableDecimalOperationFilterInput
  partyFirmQuantityId: StringOperationFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateFilterInput
  partyBaseId: StringOperationFilterInput
  partyBase: PartyBaseFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InventoryProductInput {
  inventoryId: String
  productId: String
  productJson: ProductInput
  unitId: String
  unitJson: UnitInput
  restComp: Decimal
  restDateTime: DateTime
  restRefinedComp: Decimal
  restFact: Decimal
  restFactDateTime: DateTime
  difAmount: Decimal
  salePrice: Decimal
  getPrice: Decimal
  partyFirmQuantityId: String
  storeFrameId: String
  taxRateId: String
  taxRateJson: TaxRateInput
  partyBaseId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InventoryProductMutation {
  add(model: [InventoryProductInput]): [InventoryProduct]
  update(model: [InventoryProductInput]): [InventoryProduct]
  addOrUpdate(model: [InventoryProductInput]): [InventoryProduct]
  delete(model: [InventoryProductInput]): [InventoryProduct]
}

type InventoryProductMutations {
  uploadScans(id: String): Boolean!
  confirmRests(id: String): Boolean!
  removeZeroDiff(id: String): Boolean!
}

type InventoryProductQueries {
  totalResults(id: String): TotalResults
  productRests(skip: Int, take: Int, documentId: String, productId: String, where: InventoryProductFilterInput, order: [InventoryProductSortInput!]): InventoryProductCollectionSegment
}

type InventoryProductQuery {
  all(skip: Int, take: Int, where: InventoryProductFilterInput, order: [InventoryProductSortInput!]): InventoryProductCollectionSegment
  userInfo(model: InventoryProductInput): UserInfo
  getByKeys(inventoryId: String, productId: String, partyFirmQuantityId: String, partyBaseId: String, id: String): [InventoryProduct]
}

input InventoryProductSortInput {
  inventoryId: SortEnumType
  inventory: InventorySortInput
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  restComp: SortEnumType
  restDateTime: SortEnumType
  restRefinedComp: SortEnumType
  restFact: SortEnumType
  restFactDateTime: SortEnumType
  difAmount: SortEnumType
  salePrice: SortEnumType
  getPrice: SortEnumType
  partyFirmQuantityId: SortEnumType
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateSortInput
  partyBaseId: SortEnumType
  partyBase: PartyBaseSortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InventoryPurpose {
  purpose: String
  periodicity: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InventoryPurposeCollectionSegment {
  items: [InventoryPurpose]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InventoryPurposeFilterInput {
  and: [InventoryPurposeFilterInput!]
  or: [InventoryPurposeFilterInput!]
  purpose: StringOperationFilterInput
  periodicity: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InventoryPurposeInput {
  purpose: String
  periodicity: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InventoryPurposeMutation {
  add(model: [InventoryPurposeInput]): [InventoryPurpose]
  update(model: [InventoryPurposeInput]): [InventoryPurpose]
  addOrUpdate(model: [InventoryPurposeInput]): [InventoryPurpose]
  delete(model: [InventoryPurposeInput]): [InventoryPurpose]
}

type InventoryPurposeQuery {
  all(skip: Int, take: Int, where: InventoryPurposeFilterInput, order: [InventoryPurposeSortInput!]): InventoryPurposeCollectionSegment
  userInfo(model: InventoryPurposeInput): UserInfo
  getByKeys(id: String): [InventoryPurpose]
}

input InventoryPurposeSortInput {
  purpose: SortEnumType
  periodicity: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InventoryQueries {
  validate(scanId: String): Boolean!
}

type InventoryQuery {
  all(skip: Int, take: Int, where: InventoryFilterInput, order: [InventorySortInput!]): InventoryCollectionSegment
  userInfo(model: InventoryInput): UserInfo
  getByKeys(id: String): [Inventory]
}

input InventorySortInput {
  globalCode: SortEnumType
  status: SortEnumType
  inventoryType: SortEnumType
  number: SortEnumType
  expectedEndTime: SortEnumType
  purposeId: SortEnumType
  purpose: InventoryPurposeSortInput
  firmStructureId: SortEnumType
  firmStructure: StructureSortInput
  firmStructureJson: StructureSortInput
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreSortInput
  firmEmployeeId: SortEnumType
  firmEmployee: FirmEmployeeSortInput
  firmEmployeeJson: FirmEmployeeSortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceDiscord {
  status: Int
  invoiceId: String
  productId: String
  unitId: String
  amountSupplier: Decimal
  amountDiscord: Decimal
  discordReasonId: String
  price: Decimal
  sum: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  invoice: InvoiceIn!
  product: Product
  productJson: ProductBase!
  unit: Unit!
  unitJson: UnitBase!
  discordReason: DiscordReason!
}

type InvoiceDiscordCollectionSegment {
  items: [InvoiceDiscord]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceDiscordFilterInput {
  and: [InvoiceDiscordFilterInput!]
  or: [InvoiceDiscordFilterInput!]
  status: ComparableInt32OperationFilterInput
  invoiceId: StringOperationFilterInput
  invoice: InvoiceInFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductBaseFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitBaseFilterInput
  amountSupplier: ComparableDecimalOperationFilterInput
  amountDiscord: ComparableDecimalOperationFilterInput
  discordReasonId: StringOperationFilterInput
  discordReason: DiscordReasonFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceDiscordInput {
  status: Int
  invoiceId: String
  productId: String
  productJson: ProductBaseInput!
  unitId: String
  unitJson: UnitBaseInput!
  amountSupplier: Decimal
  amountDiscord: Decimal
  discordReasonId: String
  price: Decimal
  sum: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceDiscordMutation {
  add(model: [InvoiceDiscordInput]): [InvoiceDiscord]
  update(model: [InvoiceDiscordInput]): [InvoiceDiscord]
  addOrUpdate(model: [InvoiceDiscordInput]): [InvoiceDiscord]
  delete(model: [InvoiceDiscordInput]): [InvoiceDiscord]
}

type InvoiceDiscordQuery {
  all(skip: Int, take: Int, where: InvoiceDiscordFilterInput, order: [InvoiceDiscordSortInput!]): InvoiceDiscordCollectionSegment
  userInfo(model: InvoiceDiscordInput): UserInfo
  getByKeys(id: String): [InvoiceDiscord]
}

input InvoiceDiscordSortInput {
  status: SortEnumType
  invoiceId: SortEnumType
  invoice: InvoiceInSortInput
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductBaseSortInput
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitBaseSortInput
  amountSupplier: SortEnumType
  amountDiscord: SortEnumType
  discordReasonId: SortEnumType
  discordReason: DiscordReasonSortInput
  price: SortEnumType
  sum: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceIn {
  numberSupplier: String
  dateSupplier: DateTime
  isTaxIncluded: Boolean
  validated: Int
  conditionDeliveryDate: DateTime
  conditionPayment: Int
  conditionPaymentDate: DateTime
  invoiceStateId: String
  contractorId: String
  contractorStructureId: String
  contractNumber: String
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  sumTax: Decimal
  zone: Int
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  filterByStoreId(id: [String!]!): Boolean!
  invoiceState: InvoiceState
  contractor: Firm
  contractorJson: Firm
  contractorStructure: Structure
  contractorStructureJson: Structure
  firmStore: Store
  firmStoreJson: Store
  currency: Currency
}

type InvoiceInCollectionSegment {
  items: [InvoiceIn]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceInFilterInput {
  and: [InvoiceInFilterInput!]
  or: [InvoiceInFilterInput!]
  numberSupplier: StringOperationFilterInput
  dateSupplier: ComparableDateTimeOperationFilterInput
  isTaxIncluded: BooleanOperationFilterInput
  validated: ComparableInt32OperationFilterInput
  conditionDeliveryDate: ComparableDateTimeOperationFilterInput
  conditionPayment: ComparableInt32OperationFilterInput
  conditionPaymentDate: ComparableDateTimeOperationFilterInput
  invoiceStateId: StringOperationFilterInput
  invoiceState: InvoiceStateFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  contractorJson: FirmFilterInput
  contractorStructureId: StringOperationFilterInput
  contractorStructure: StructureFilterInput
  contractorStructureJson: StructureFilterInput
  contractNumber: StringOperationFilterInput
  globalCode: StringOperationFilterInput
  direct: ComparableInt32OperationFilterInput
  movingDate: ComparableNullableOfDateTimeOperationFilterInput
  conditionDelivery: ComparableInt32OperationFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  zone: ComparableNullableOfInt32OperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  parentDocumentId: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceInInput {
  numberSupplier: String
  dateSupplier: DateTime
  isTaxIncluded: Boolean
  validated: Int
  conditionDeliveryDate: DateTime
  conditionPayment: Int
  conditionPaymentDate: DateTime
  invoiceStateId: String
  contractorId: String
  contractorJson: FirmInput
  contractorStructureId: String
  contractorStructureJson: StructureInput
  contractNumber: String
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  firmStoreJson: StoreInput
  sumTax: Decimal
  zone: Int
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceInInside {
  conditionDeliveryDate: DateTime
  contractorStructureId: String
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  sumTax: Decimal
  zone: Int
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  filterByStoreId(id: [String!]!): Boolean!
  contractorStructure: Structure
  contractorStructureJson: Structure
  firmStore: Store
  firmStoreJson: Store
  currency: Currency
}

type InvoiceInInsideCollectionSegment {
  items: [InvoiceInInside]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceInInsideFilterInput {
  and: [InvoiceInInsideFilterInput!]
  or: [InvoiceInInsideFilterInput!]
  conditionDeliveryDate: ComparableNullableOfDateTimeOperationFilterInput
  contractorStructureId: StringOperationFilterInput
  contractorStructure: StructureFilterInput
  contractorStructureJson: StructureFilterInput
  globalCode: StringOperationFilterInput
  direct: ComparableInt32OperationFilterInput
  movingDate: ComparableNullableOfDateTimeOperationFilterInput
  conditionDelivery: ComparableInt32OperationFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  zone: ComparableNullableOfInt32OperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  parentDocumentId: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceInInsideInput {
  conditionDeliveryDate: DateTime
  contractorStructureId: String
  contractorStructureJson: StructureInput
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  firmStoreJson: StoreInput
  sumTax: Decimal
  zone: Int
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceInInsideMutation {
  add(model: [InvoiceInInsideInput]): [InvoiceInInside]
  update(model: [InvoiceInInsideInput]): [InvoiceInInside]
  addOrUpdate(model: [InvoiceInInsideInput]): [InvoiceInInside]
  delete(model: [InvoiceInInsideInput]): [InvoiceInInside]
}

type InvoiceInInsideProduct {
  invoiceId: String
  productId: String
  taxRateId: String
  amount: Decimal
  unitId: String
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  masterTableId: String!
  invoice: InvoiceInInside
  product: Product
  productJson: Product
  taxRate: TaxRate
  taxRateJson: TaxRate
  unit: Unit
  unitJson: Unit
  storeFrame: StoreFrame
  partyBase: PartyBase
}

type InvoiceInInsideProductCollectionSegment {
  items: [InvoiceInInsideProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceInInsideProductFilterInput {
  and: [InvoiceInInsideProductFilterInput!]
  or: [InvoiceInInsideProductFilterInput!]
  invoiceId: StringOperationFilterInput
  invoice: InvoiceInInsideFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateFilterInput
  amount: ComparableDecimalOperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  storeFrameCode: StringOperationFilterInput
  partyBaseId: StringOperationFilterInput
  partyBase: PartyBaseFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceInInsideProductInput {
  invoiceId: String
  productId: String
  productJson: ProductInput
  taxRateId: String
  taxRateJson: TaxRateInput
  amount: Decimal
  unitId: String
  unitJson: UnitInput
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceInInsideProductMutation {
  add(model: [InvoiceInInsideProductInput]): [InvoiceInInsideProduct]
  update(model: [InvoiceInInsideProductInput]): [InvoiceInInsideProduct]
  addOrUpdate(model: [InvoiceInInsideProductInput]): [InvoiceInInsideProduct]
  delete(model: [InvoiceInInsideProductInput]): [InvoiceInInsideProduct]
}

type InvoiceInInsideProductQuery {
  all(skip: Int, take: Int, where: InvoiceInInsideProductFilterInput, order: [InvoiceInInsideProductSortInput!]): InvoiceInInsideProductCollectionSegment
  userInfo(model: InvoiceInInsideProductInput): UserInfo
  getByKeys(invoiceId: String, productId: String, partyBaseId: String): [InvoiceInInsideProduct]
}

input InvoiceInInsideProductSortInput {
  invoiceId: SortEnumType
  invoice: InvoiceInInsideSortInput
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateSortInput
  amount: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  price: SortEnumType
  sum: SortEnumType
  sumTax: SortEnumType
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  storeFrameCode: SortEnumType
  partyBaseId: SortEnumType
  partyBase: PartyBaseSortInput
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceInInsideQuery {
  all(skip: Int, take: Int, where: InvoiceInInsideFilterInput, order: [InvoiceInInsideSortInput!]): InvoiceInInsideCollectionSegment
  userInfo(model: InvoiceInInsideInput): UserInfo
  getByKeys(id: String): [InvoiceInInside]
}

input InvoiceInInsideSortInput {
  conditionDeliveryDate: SortEnumType
  contractorStructureId: SortEnumType
  contractorStructure: StructureSortInput
  contractorStructureJson: StructureSortInput
  globalCode: SortEnumType
  direct: SortEnumType
  movingDate: SortEnumType
  conditionDelivery: SortEnumType
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreSortInput
  sumTax: SortEnumType
  zone: SortEnumType
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  parentDocumentId: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceInMutation {
  add(model: [InvoiceInInput]): [InvoiceIn]
  update(model: [InvoiceInInput]): [InvoiceIn]
  addOrUpdate(model: [InvoiceInInput]): [InvoiceIn]
  delete(model: [InvoiceInInput]): [InvoiceIn]
}

type InvoiceInProduct {
  invoiceId: String
  productBarId: String
  previouslyReturned: Decimal
  factRestAmount: Decimal
  discordReasonId: String
  difAmount: Decimal
  productId: String
  taxRateId: String
  amount: Decimal
  unitId: String
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  masterTableId: String!
  invoice: InvoiceIn
  productBar: ProductBar
  productBarJson: ProductBar
  discordReason: DiscordReason
  product: Product
  productJson: Product
  taxRate: TaxRate
  taxRateJson: TaxRate
  unit: Unit
  unitJson: Unit
  storeFrame: StoreFrame
  partyBase: PartyBase
}

type InvoiceInProductCollectionSegment {
  items: [InvoiceInProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceInProductFilterInput {
  and: [InvoiceInProductFilterInput!]
  or: [InvoiceInProductFilterInput!]
  invoiceId: StringOperationFilterInput
  invoice: InvoiceInFilterInput
  productBarId: StringOperationFilterInput
  productBar: ProductBarFilterInput
  productBarJson: ProductBarFilterInput
  previouslyReturned: ComparableDecimalOperationFilterInput
  factRestAmount: ComparableNullableOfDecimalOperationFilterInput
  discordReasonId: StringOperationFilterInput
  discordReason: DiscordReasonFilterInput
  difAmount: ComparableNullableOfDecimalOperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateFilterInput
  amount: ComparableDecimalOperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  storeFrameCode: StringOperationFilterInput
  partyBaseId: StringOperationFilterInput
  partyBase: PartyBaseFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceInProductInput {
  invoiceId: String
  productBarId: String
  productBarJson: ProductBarInput
  previouslyReturned: Decimal
  factRestAmount: Decimal
  discordReasonId: String
  difAmount: Decimal
  productId: String
  productJson: ProductInput
  taxRateId: String
  taxRateJson: TaxRateInput
  amount: Decimal
  unitId: String
  unitJson: UnitInput
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceInProductMutation {
  add(model: [InvoiceInProductInput]): [InvoiceInProduct]
  update(model: [InvoiceInProductInput]): [InvoiceInProduct]
  addOrUpdate(model: [InvoiceInProductInput]): [InvoiceInProduct]
  delete(model: [InvoiceInProductInput]): [InvoiceInProduct]
}

type InvoiceInProductQuery {
  all(skip: Int, take: Int, where: InvoiceInProductFilterInput, order: [InvoiceInProductSortInput!]): InvoiceInProductCollectionSegment
  userInfo(model: InvoiceInProductInput): UserInfo
  getByKeys(invoiceId: String, productId: String, partyBaseId: String): [InvoiceInProduct]
}

input InvoiceInProductSortInput {
  invoiceId: SortEnumType
  invoice: InvoiceInSortInput
  productBarId: SortEnumType
  productBar: ProductBarSortInput
  productBarJson: ProductBarSortInput
  previouslyReturned: SortEnumType
  factRestAmount: SortEnumType
  discordReasonId: SortEnumType
  discordReason: DiscordReasonSortInput
  difAmount: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateSortInput
  amount: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  price: SortEnumType
  sum: SortEnumType
  sumTax: SortEnumType
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  storeFrameCode: SortEnumType
  partyBaseId: SortEnumType
  partyBase: PartyBaseSortInput
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceInQuery {
  all(skip: Int, take: Int, where: InvoiceInFilterInput, order: [InvoiceInSortInput!]): InvoiceInCollectionSegment
  userInfo(model: InvoiceInInput): UserInfo
  getByKeys(id: String): [InvoiceIn]
}

type InvoiceInReturn {
  conditionDeliveryDate: DateTime
  invoiceStateId: String
  returnReasonId: String
  contractorId: String
  contractorStructureId: String
  contractNumber: String
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  sumTax: Decimal
  zone: Int
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  filterByStoreId(id: [String!]!): Boolean!
  invoiceState: InvoiceState
  returnReason: ReturnReason
  contractor: Firm
  contractorJson: Firm
  contractorStructure: Structure
  contractorStructureJson: Structure
  firmStore: Store
  firmStoreJson: Store
  currency: Currency
}

type InvoiceInReturnCollectionSegment {
  items: [InvoiceInReturn]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceInReturnFilterInput {
  and: [InvoiceInReturnFilterInput!]
  or: [InvoiceInReturnFilterInput!]
  conditionDeliveryDate: ComparableDateTimeOperationFilterInput
  invoiceStateId: StringOperationFilterInput
  invoiceState: InvoiceStateFilterInput
  returnReasonId: StringOperationFilterInput
  returnReason: ReturnReasonFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  contractorJson: FirmFilterInput
  contractorStructureId: StringOperationFilterInput
  contractorStructure: StructureFilterInput
  contractorStructureJson: StructureFilterInput
  contractNumber: StringOperationFilterInput
  globalCode: StringOperationFilterInput
  direct: ComparableInt32OperationFilterInput
  movingDate: ComparableNullableOfDateTimeOperationFilterInput
  conditionDelivery: ComparableInt32OperationFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  zone: ComparableNullableOfInt32OperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  parentDocumentId: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceInReturnInput {
  conditionDeliveryDate: DateTime
  invoiceStateId: String
  returnReasonId: String
  contractorId: String
  contractorJson: FirmInput
  contractorStructureId: String
  contractorStructureJson: StructureInput
  contractNumber: String
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  firmStoreJson: StoreInput
  sumTax: Decimal
  zone: Int
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceInReturnMutation {
  add(model: [InvoiceInReturnInput]): [InvoiceInReturn]
  update(model: [InvoiceInReturnInput]): [InvoiceInReturn]
  addOrUpdate(model: [InvoiceInReturnInput]): [InvoiceInReturn]
  delete(model: [InvoiceInReturnInput]): [InvoiceInReturn]
}

type InvoiceInReturnProduct {
  invoiceId: String
  productBarId: String
  partyFirmQuantityId: String
  productId: String
  taxRateId: String
  amount: Decimal
  unitId: String
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  masterTableId: String!
  invoice: InvoiceInReturn
  productBar: ProductBar
  productBarJson: ProductBar
  product: Product
  productJson: Product
  taxRate: TaxRate
  taxRateJson: TaxRate
  unit: Unit
  unitJson: Unit
  storeFrame: StoreFrame
  partyBase: PartyBase
}

type InvoiceInReturnProductCollectionSegment {
  items: [InvoiceInReturnProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceInReturnProductFilterInput {
  and: [InvoiceInReturnProductFilterInput!]
  or: [InvoiceInReturnProductFilterInput!]
  invoiceId: StringOperationFilterInput
  invoice: InvoiceInReturnFilterInput
  productBarId: StringOperationFilterInput
  productBar: ProductBarFilterInput
  productBarJson: ProductBarFilterInput
  partyFirmQuantityId: StringOperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateFilterInput
  amount: ComparableDecimalOperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  storeFrameCode: StringOperationFilterInput
  partyBaseId: StringOperationFilterInput
  partyBase: PartyBaseFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceInReturnProductInput {
  invoiceId: String
  productBarId: String
  productBarJson: ProductBarInput
  partyFirmQuantityId: String
  productId: String
  productJson: ProductInput
  taxRateId: String
  taxRateJson: TaxRateInput
  amount: Decimal
  unitId: String
  unitJson: UnitInput
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceInReturnProductMutation {
  add(model: [InvoiceInReturnProductInput]): [InvoiceInReturnProduct]
  update(model: [InvoiceInReturnProductInput]): [InvoiceInReturnProduct]
  addOrUpdate(model: [InvoiceInReturnProductInput]): [InvoiceInReturnProduct]
  delete(model: [InvoiceInReturnProductInput]): [InvoiceInReturnProduct]
}

type InvoiceInReturnProductQuery {
  all(skip: Int, take: Int, where: InvoiceInReturnProductFilterInput, order: [InvoiceInReturnProductSortInput!]): InvoiceInReturnProductCollectionSegment
  userInfo(model: InvoiceInReturnProductInput): UserInfo
  getByKeys(invoiceId: String, partyFirmQuantityId: String, productId: String, partyBaseId: String): [InvoiceInReturnProduct]
}

input InvoiceInReturnProductSortInput {
  invoiceId: SortEnumType
  invoice: InvoiceInReturnSortInput
  productBarId: SortEnumType
  productBar: ProductBarSortInput
  productBarJson: ProductBarSortInput
  partyFirmQuantityId: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateSortInput
  amount: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  price: SortEnumType
  sum: SortEnumType
  sumTax: SortEnumType
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  storeFrameCode: SortEnumType
  partyBaseId: SortEnumType
  partyBase: PartyBaseSortInput
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceInReturnQuery {
  all(skip: Int, take: Int, where: InvoiceInReturnFilterInput, order: [InvoiceInReturnSortInput!]): InvoiceInReturnCollectionSegment
  userInfo(model: InvoiceInReturnInput): UserInfo
  getByKeys(id: String): [InvoiceInReturn]
}

input InvoiceInReturnSortInput {
  conditionDeliveryDate: SortEnumType
  invoiceStateId: SortEnumType
  invoiceState: InvoiceStateSortInput
  returnReasonId: SortEnumType
  returnReason: ReturnReasonSortInput
  contractorId: SortEnumType
  contractor: FirmSortInput
  contractorJson: FirmSortInput
  contractorStructureId: SortEnumType
  contractorStructure: StructureSortInput
  contractorStructureJson: StructureSortInput
  contractNumber: SortEnumType
  globalCode: SortEnumType
  direct: SortEnumType
  movingDate: SortEnumType
  conditionDelivery: SortEnumType
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreSortInput
  sumTax: SortEnumType
  zone: SortEnumType
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  parentDocumentId: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input InvoiceInSortInput {
  numberSupplier: SortEnumType
  dateSupplier: SortEnumType
  isTaxIncluded: SortEnumType
  validated: SortEnumType
  conditionDeliveryDate: SortEnumType
  conditionPayment: SortEnumType
  conditionPaymentDate: SortEnumType
  invoiceStateId: SortEnumType
  invoiceState: InvoiceStateSortInput
  contractorId: SortEnumType
  contractor: FirmSortInput
  contractorJson: FirmSortInput
  contractorStructureId: SortEnumType
  contractorStructure: StructureSortInput
  contractorStructureJson: StructureSortInput
  contractNumber: SortEnumType
  globalCode: SortEnumType
  direct: SortEnumType
  movingDate: SortEnumType
  conditionDelivery: SortEnumType
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreSortInput
  sumTax: SortEnumType
  zone: SortEnumType
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  parentDocumentId: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceOrder {
  invoiceId: String
  orderId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  invoice: InvoiceIn!
}

type InvoiceOrderCollectionSegment {
  items: [InvoiceOrder]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceOrderFilterInput {
  and: [InvoiceOrderFilterInput!]
  or: [InvoiceOrderFilterInput!]
  invoiceId: StringOperationFilterInput
  invoice: InvoiceInFilterInput
  orderId: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceOrderInput {
  invoiceId: String
  orderId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceOrderMutation {
  add(model: [InvoiceOrderInput]): [InvoiceOrder]
  update(model: [InvoiceOrderInput]): [InvoiceOrder]
  addOrUpdate(model: [InvoiceOrderInput]): [InvoiceOrder]
  delete(model: [InvoiceOrderInput]): [InvoiceOrder]
}

type InvoiceOrderQuery {
  all(skip: Int, take: Int, where: InvoiceOrderFilterInput, order: [InvoiceOrderSortInput!]): InvoiceOrderCollectionSegment
  userInfo(model: InvoiceOrderInput): UserInfo
  getByKeys(invoiceId: String, orderId: String): [InvoiceOrder]
}

input InvoiceOrderSortInput {
  invoiceId: SortEnumType
  invoice: InvoiceInSortInput
  orderId: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceOut {
  conditionDeliveryDate: DateTime
  conditionPayment: Int
  conditionPaymentDate: DateTime
  contractorId: String
  contractorStructureId: String
  contractNumber: String
  taxInvoiceNumber: String
  taxInvoiceDate: DateTime
  isTaxInvoiceRegister: Boolean
  salesChannelId: String
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  sumTax: Decimal
  zone: Int
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  filterByStoreId(id: [String!]!): Boolean!
  contractor: Firm
  contractorJson: Firm
  contractorStructure: Structure
  contractorStructureJson: Structure
  salesChannel: SaleChannel
  salesChannelJson: SaleChannel
  firmStore: Store
  firmStoreJson: Store
  currency: Currency
}

type InvoiceOutCollectionSegment {
  items: [InvoiceOut]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceOutFilterInput {
  and: [InvoiceOutFilterInput!]
  or: [InvoiceOutFilterInput!]
  conditionDeliveryDate: ComparableDateTimeOperationFilterInput
  conditionPayment: ComparableInt32OperationFilterInput
  conditionPaymentDate: ComparableDateTimeOperationFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  contractorJson: FirmFilterInput
  contractorStructureId: StringOperationFilterInput
  contractorStructure: StructureFilterInput
  contractorStructureJson: StructureFilterInput
  contractNumber: StringOperationFilterInput
  taxInvoiceNumber: StringOperationFilterInput
  taxInvoiceDate: ComparableNullableOfDateTimeOperationFilterInput
  isTaxInvoiceRegister: BooleanOperationFilterInput
  salesChannelId: StringOperationFilterInput
  salesChannel: SaleChannelFilterInput
  salesChannelJson: SaleChannelFilterInput
  globalCode: StringOperationFilterInput
  direct: ComparableInt32OperationFilterInput
  movingDate: ComparableNullableOfDateTimeOperationFilterInput
  conditionDelivery: ComparableInt32OperationFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  zone: ComparableNullableOfInt32OperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  parentDocumentId: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceOutInput {
  conditionDeliveryDate: DateTime
  conditionPayment: Int
  conditionPaymentDate: DateTime
  contractorId: String
  contractorJson: FirmInput
  contractorStructureId: String
  contractorStructureJson: StructureInput
  contractNumber: String
  taxInvoiceNumber: String
  taxInvoiceDate: DateTime
  isTaxInvoiceRegister: Boolean
  salesChannelId: String
  salesChannelJson: SaleChannelInput
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  firmStoreJson: StoreInput
  sumTax: Decimal
  zone: Int
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceOutInside {
  conditionDeliveryDate: DateTime
  contractorStructureId: String
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  sumTax: Decimal
  zone: Int
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  filterByStoreId(id: [String!]!): Boolean!
  contractorStructure: Structure
  contractorStructureJson: Structure
  firmStore: Store
  firmStoreJson: Store
  currency: Currency
}

type InvoiceOutInsideCollectionSegment {
  items: [InvoiceOutInside]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceOutInsideFilterInput {
  and: [InvoiceOutInsideFilterInput!]
  or: [InvoiceOutInsideFilterInput!]
  conditionDeliveryDate: ComparableNullableOfDateTimeOperationFilterInput
  contractorStructureId: StringOperationFilterInput
  contractorStructure: StructureFilterInput
  contractorStructureJson: StructureFilterInput
  globalCode: StringOperationFilterInput
  direct: ComparableInt32OperationFilterInput
  movingDate: ComparableNullableOfDateTimeOperationFilterInput
  conditionDelivery: ComparableInt32OperationFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  zone: ComparableNullableOfInt32OperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  parentDocumentId: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceOutInsideInput {
  conditionDeliveryDate: DateTime
  contractorStructureId: String
  contractorStructureJson: StructureInput
  globalCode: String
  direct: Int
  movingDate: DateTime
  conditionDelivery: Int
  firmStoreId: String
  firmStoreJson: StoreInput
  sumTax: Decimal
  zone: Int
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceOutInsideMutation {
  add(model: [InvoiceOutInsideInput]): [InvoiceOutInside]
  update(model: [InvoiceOutInsideInput]): [InvoiceOutInside]
  addOrUpdate(model: [InvoiceOutInsideInput]): [InvoiceOutInside]
  delete(model: [InvoiceOutInsideInput]): [InvoiceOutInside]
}

type InvoiceOutInsideProduct {
  invoiceId: String
  partyFirmQuantityId: String
  productId: String
  taxRateId: String
  amount: Decimal
  unitId: String
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  masterTableId: String!
  invoice: InvoiceOutInside
  product: Product
  productJson: Product
  taxRate: TaxRate
  taxRateJson: TaxRate
  unit: Unit
  unitJson: Unit
  storeFrame: StoreFrame
  partyBase: PartyBase
}

type InvoiceOutInsideProductCollectionSegment {
  items: [InvoiceOutInsideProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceOutInsideProductFilterInput {
  and: [InvoiceOutInsideProductFilterInput!]
  or: [InvoiceOutInsideProductFilterInput!]
  invoiceId: StringOperationFilterInput
  invoice: InvoiceOutInsideFilterInput
  partyFirmQuantityId: StringOperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateFilterInput
  amount: ComparableDecimalOperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  storeFrameCode: StringOperationFilterInput
  partyBaseId: StringOperationFilterInput
  partyBase: PartyBaseFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceOutInsideProductInput {
  invoiceId: String
  partyFirmQuantityId: String
  productId: String
  productJson: ProductInput
  taxRateId: String
  taxRateJson: TaxRateInput
  amount: Decimal
  unitId: String
  unitJson: UnitInput
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceOutInsideProductMutation {
  add(model: [InvoiceOutInsideProductInput]): [InvoiceOutInsideProduct]
  update(model: [InvoiceOutInsideProductInput]): [InvoiceOutInsideProduct]
  addOrUpdate(model: [InvoiceOutInsideProductInput]): [InvoiceOutInsideProduct]
  delete(model: [InvoiceOutInsideProductInput]): [InvoiceOutInsideProduct]
}

type InvoiceOutInsideProductQuery {
  all(skip: Int, take: Int, where: InvoiceOutInsideProductFilterInput, order: [InvoiceOutInsideProductSortInput!]): InvoiceOutInsideProductCollectionSegment
  userInfo(model: InvoiceOutInsideProductInput): UserInfo
  getByKeys(invoiceId: String, partyFirmQuantityId: String, productId: String, partyBaseId: String): [InvoiceOutInsideProduct]
}

input InvoiceOutInsideProductSortInput {
  invoiceId: SortEnumType
  invoice: InvoiceOutInsideSortInput
  partyFirmQuantityId: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateSortInput
  amount: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  price: SortEnumType
  sum: SortEnumType
  sumTax: SortEnumType
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  storeFrameCode: SortEnumType
  partyBaseId: SortEnumType
  partyBase: PartyBaseSortInput
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceOutInsideQuery {
  all(skip: Int, take: Int, where: InvoiceOutInsideFilterInput, order: [InvoiceOutInsideSortInput!]): InvoiceOutInsideCollectionSegment
  userInfo(model: InvoiceOutInsideInput): UserInfo
  getByKeys(id: String): [InvoiceOutInside]
}

input InvoiceOutInsideSortInput {
  conditionDeliveryDate: SortEnumType
  contractorStructureId: SortEnumType
  contractorStructure: StructureSortInput
  contractorStructureJson: StructureSortInput
  globalCode: SortEnumType
  direct: SortEnumType
  movingDate: SortEnumType
  conditionDelivery: SortEnumType
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreSortInput
  sumTax: SortEnumType
  zone: SortEnumType
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  parentDocumentId: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceOutMutation {
  add(model: [InvoiceOutInput]): [InvoiceOut]
  update(model: [InvoiceOutInput]): [InvoiceOut]
  addOrUpdate(model: [InvoiceOutInput]): [InvoiceOut]
  delete(model: [InvoiceOutInput]): [InvoiceOut]
}

type InvoiceOutProduct {
  invoiceId: String
  productBarId: String
  partyFirmQuantityId: String
  productId: String
  taxRateId: String
  amount: Decimal
  unitId: String
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  masterTableId: String!
  invoice: InvoiceOut
  productBar: ProductBar
  productBarJson: ProductBar
  product: Product
  productJson: Product
  taxRate: TaxRate
  taxRateJson: TaxRate
  unit: Unit
  unitJson: Unit
  storeFrame: StoreFrame
  partyBase: PartyBase
}

type InvoiceOutProductCollectionSegment {
  items: [InvoiceOutProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceOutProductFilterInput {
  and: [InvoiceOutProductFilterInput!]
  or: [InvoiceOutProductFilterInput!]
  invoiceId: StringOperationFilterInput
  invoice: InvoiceOutFilterInput
  productBarId: StringOperationFilterInput
  productBar: ProductBarFilterInput
  productBarJson: ProductBarFilterInput
  partyFirmQuantityId: StringOperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateFilterInput
  amount: ComparableDecimalOperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  storeFrameCode: StringOperationFilterInput
  partyBaseId: StringOperationFilterInput
  partyBase: PartyBaseFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceOutProductInput {
  invoiceId: String
  productBarId: String
  productBarJson: ProductBarInput
  partyFirmQuantityId: String
  productId: String
  productJson: ProductInput
  taxRateId: String
  taxRateJson: TaxRateInput
  amount: Decimal
  unitId: String
  unitJson: UnitInput
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  storeFrameId: String
  storeFrameCode: String
  partyBaseId: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceOutProductMutation {
  add(model: [InvoiceOutProductInput]): [InvoiceOutProduct]
  update(model: [InvoiceOutProductInput]): [InvoiceOutProduct]
  addOrUpdate(model: [InvoiceOutProductInput]): [InvoiceOutProduct]
  delete(model: [InvoiceOutProductInput]): [InvoiceOutProduct]
}

type InvoiceOutProductQuery {
  all(skip: Int, take: Int, where: InvoiceOutProductFilterInput, order: [InvoiceOutProductSortInput!]): InvoiceOutProductCollectionSegment
  userInfo(model: InvoiceOutProductInput): UserInfo
  getByKeys(invoiceId: String, partyFirmQuantityId: String, productId: String, partyBaseId: String): [InvoiceOutProduct]
}

input InvoiceOutProductSortInput {
  invoiceId: SortEnumType
  invoice: InvoiceOutSortInput
  productBarId: SortEnumType
  productBar: ProductBarSortInput
  productBarJson: ProductBarSortInput
  partyFirmQuantityId: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateSortInput
  amount: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  price: SortEnumType
  sum: SortEnumType
  sumTax: SortEnumType
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  storeFrameCode: SortEnumType
  partyBaseId: SortEnumType
  partyBase: PartyBaseSortInput
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceOutQuery {
  all(skip: Int, take: Int, where: InvoiceOutFilterInput, order: [InvoiceOutSortInput!]): InvoiceOutCollectionSegment
  userInfo(model: InvoiceOutInput): UserInfo
  getByKeys(id: String): [InvoiceOut]
}

input InvoiceOutSortInput {
  conditionDeliveryDate: SortEnumType
  conditionPayment: SortEnumType
  conditionPaymentDate: SortEnumType
  contractorId: SortEnumType
  contractor: FirmSortInput
  contractorJson: FirmSortInput
  contractorStructureId: SortEnumType
  contractorStructure: StructureSortInput
  contractorStructureJson: StructureSortInput
  contractNumber: SortEnumType
  taxInvoiceNumber: SortEnumType
  taxInvoiceDate: SortEnumType
  isTaxInvoiceRegister: SortEnumType
  salesChannelId: SortEnumType
  salesChannel: SaleChannelSortInput
  salesChannelJson: SaleChannelSortInput
  globalCode: SortEnumType
  direct: SortEnumType
  movingDate: SortEnumType
  conditionDelivery: SortEnumType
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreSortInput
  sumTax: SortEnumType
  zone: SortEnumType
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  parentDocumentId: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceState {
  _raw_json_name: String
  name: [Locale]
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceStateCollectionSegment {
  items: [InvoiceState]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceStateFilterInput {
  and: [InvoiceStateFilterInput!]
  or: [InvoiceStateFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  isUse: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceStateInput {
  name: [LocaleInput!]!
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceStateInvoices {
  invoiceStateId: String
  globalCode: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  invoiceState: InvoiceState
}

type InvoiceStateInvoicesCollectionSegment {
  items: [InvoiceStateInvoices]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input InvoiceStateInvoicesFilterInput {
  and: [InvoiceStateInvoicesFilterInput!]
  or: [InvoiceStateInvoicesFilterInput!]
  invoiceStateId: StringOperationFilterInput
  invoiceState: InvoiceStateFilterInput
  globalCode: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input InvoiceStateInvoicesInput {
  invoiceStateId: String
  globalCode: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type InvoiceStateInvoicesMutation {
  add(model: [InvoiceStateInvoicesInput]): [InvoiceStateInvoices]
  update(model: [InvoiceStateInvoicesInput]): [InvoiceStateInvoices]
  addOrUpdate(model: [InvoiceStateInvoicesInput]): [InvoiceStateInvoices]
  delete(model: [InvoiceStateInvoicesInput]): [InvoiceStateInvoices]
}

type InvoiceStateInvoicesQuery {
  all(skip: Int, take: Int, where: InvoiceStateInvoicesFilterInput, order: [InvoiceStateInvoicesSortInput!]): InvoiceStateInvoicesCollectionSegment
  userInfo(model: InvoiceStateInvoicesInput): UserInfo
  getByKeys(invoiceStateId: String, globalCode: String): [InvoiceStateInvoices]
}

input InvoiceStateInvoicesSortInput {
  invoiceStateId: SortEnumType
  invoiceState: InvoiceStateSortInput
  globalCode: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type InvoiceStateMutation {
  add(model: [InvoiceStateInput]): [InvoiceState]
  update(model: [InvoiceStateInput]): [InvoiceState]
  addOrUpdate(model: [InvoiceStateInput]): [InvoiceState]
  delete(model: [InvoiceStateInput]): [InvoiceState]
}

type InvoiceStateQuery {
  all(skip: Int, take: Int, where: InvoiceStateFilterInput, order: [InvoiceStateSortInput!]): InvoiceStateCollectionSegment
  userInfo(model: InvoiceStateInput): UserInfo
  getByKeys(id: String): [InvoiceState]
}

input InvoiceStateSortInput {
  isUse: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

type KPIPlanDistribution {
  kPISalesPlanId: String
  firmEmployeeId: String
  disributionPercent: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  kPISalesPlan: KPISalesPlan!
  firmEmployee: FirmEmployee!
}

type KPIPlanDistributionCollectionSegment {
  items: [KPIPlanDistribution]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input KPIPlanDistributionFilterInput {
  and: [KPIPlanDistributionFilterInput!]
  or: [KPIPlanDistributionFilterInput!]
  kPISalesPlanId: StringOperationFilterInput
  kPISalesPlan: KPISalesPlanFilterInput
  firmEmployeeId: StringOperationFilterInput
  firmEmployee: FirmEmployeeFilterInput
  disributionPercent: ComparableDecimalOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input KPIPlanDistributionInput {
  kPISalesPlanId: String
  firmEmployeeId: String
  disributionPercent: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type KPIPlanDistributionMutation {
  add(model: [KPIPlanDistributionInput]): [KPIPlanDistribution]
  update(model: [KPIPlanDistributionInput]): [KPIPlanDistribution]
  addOrUpdate(model: [KPIPlanDistributionInput]): [KPIPlanDistribution]
  delete(model: [KPIPlanDistributionInput]): [KPIPlanDistribution]
}

type KPIPlanDistributionQuery {
  all(skip: Int, take: Int, where: KPIPlanDistributionFilterInput, order: [KPIPlanDistributionSortInput!]): KPIPlanDistributionCollectionSegment
  userInfo(model: KPIPlanDistributionInput): UserInfo
  getByKeys(kPISalesPlanId: String, firmEmployeeId: String): [KPIPlanDistribution]
}

input KPIPlanDistributionSortInput {
  kPISalesPlanId: SortEnumType
  kPISalesPlan: KPISalesPlanSortInput
  firmEmployeeId: SortEnumType
  firmEmployee: FirmEmployeeSortInput
  disributionPercent: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type KPISalesPlan {
  id: String
  status: Int
  number: String
  date: DateTime
  firmStructureId: String
  name: String
  comment: String
  beginDate: DateTime
  endDate: DateTime
  plan: Decimal
  measure: Int
  formula: Int
  percent: Decimal
  price: Decimal
  bonus: Decimal
  coefficients: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firmStructure: Structure
}

type KPISalesPlanCollectionSegment {
  items: [KPISalesPlan]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input KPISalesPlanFilterInput {
  and: [KPISalesPlanFilterInput!]
  or: [KPISalesPlanFilterInput!]
  id: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  firmStructureId: StringOperationFilterInput
  firmStructure: StructureFilterInput
  name: StringOperationFilterInput
  comment: StringOperationFilterInput
  beginDate: ComparableDateTimeOperationFilterInput
  endDate: ComparableDateTimeOperationFilterInput
  plan: ComparableDecimalOperationFilterInput
  measure: ComparableInt32OperationFilterInput
  formula: ComparableInt32OperationFilterInput
  percent: ComparableDecimalOperationFilterInput
  price: ComparableDecimalOperationFilterInput
  bonus: ComparableDecimalOperationFilterInput
  coefficients: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input KPISalesPlanInput {
  id: String
  status: Int
  number: String
  date: DateTime
  firmStructureId: String
  name: String
  comment: String
  beginDate: DateTime
  endDate: DateTime
  plan: Decimal
  measure: Int
  formula: Int
  percent: Decimal
  price: Decimal
  bonus: Decimal
  coefficients: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type KPISalesPlanMutation {
  add(model: [KPISalesPlanInput]): [KPISalesPlan]
  update(model: [KPISalesPlanInput]): [KPISalesPlan]
  addOrUpdate(model: [KPISalesPlanInput]): [KPISalesPlan]
  delete(model: [KPISalesPlanInput]): [KPISalesPlan]
}

type KPISalesPlanMutations {
  changeStatus(id: String, status: Int!): KPISalesPlan
}

type KPISalesPlanProduct {
  kPISalesPlanId: String
  productId: String
  percent: Decimal
  price: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  kPISalesPlan: KPISalesPlan!
  product: Product!
}

type KPISalesPlanProductCollectionSegment {
  items: [KPISalesPlanProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input KPISalesPlanProductFilterInput {
  and: [KPISalesPlanProductFilterInput!]
  or: [KPISalesPlanProductFilterInput!]
  kPISalesPlanId: StringOperationFilterInput
  kPISalesPlan: KPISalesPlanFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  percent: ComparableNullableOfDecimalOperationFilterInput
  price: ComparableNullableOfDecimalOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input KPISalesPlanProductInput {
  kPISalesPlanId: String
  productId: String
  percent: Decimal
  price: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type KPISalesPlanProductMutation {
  add(model: [KPISalesPlanProductInput]): [KPISalesPlanProduct]
  update(model: [KPISalesPlanProductInput]): [KPISalesPlanProduct]
  addOrUpdate(model: [KPISalesPlanProductInput]): [KPISalesPlanProduct]
  delete(model: [KPISalesPlanProductInput]): [KPISalesPlanProduct]
}

type KPISalesPlanProductQuery {
  all(skip: Int, take: Int, where: KPISalesPlanProductFilterInput, order: [KPISalesPlanProductSortInput!]): KPISalesPlanProductCollectionSegment
  userInfo(model: KPISalesPlanProductInput): UserInfo
  getByKeys(kPISalesPlanId: String, productId: String): [KPISalesPlanProduct]
}

input KPISalesPlanProductSortInput {
  kPISalesPlanId: SortEnumType
  kPISalesPlan: KPISalesPlanSortInput
  productId: SortEnumType
  product: ProductSortInput
  percent: SortEnumType
  price: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type KPISalesPlanQueries {
  template: KPISalesPlan
}

type KPISalesPlanQuery {
  all(skip: Int, take: Int, where: KPISalesPlanFilterInput, order: [KPISalesPlanSortInput!]): KPISalesPlanCollectionSegment
  userInfo(model: KPISalesPlanInput): UserInfo
  getByKeys(firmStructureId: String, name: String): [KPISalesPlan]
}

input KPISalesPlanSortInput {
  id: SortEnumType
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  firmStructureId: SortEnumType
  firmStructure: StructureSortInput
  name: SortEnumType
  comment: SortEnumType
  beginDate: SortEnumType
  endDate: SortEnumType
  plan: SortEnumType
  measure: SortEnumType
  formula: SortEnumType
  percent: SortEnumType
  price: SortEnumType
  bonus: SortEnumType
  coefficients: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type LineDictionary {
  parentId: String
  _raw_json_name: String
  name: [Locale]
  type: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: LineDictionary!
}

type LineDictionaryCollectionSegment {
  items: [LineDictionary]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input LineDictionaryFilterInput {
  and: [LineDictionaryFilterInput!]
  or: [LineDictionaryFilterInput!]
  parentId: StringOperationFilterInput
  parent: LineDictionaryFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  type: ComparableNullableOfInt32OperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

type LineDictionaryFirm {
  firmId: String
  lineDictionaryId: String
  salesChannelId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm!
  lineDictionary: LineDictionary!
  salesChannel: SaleChannel!
}

type LineDictionaryFirmCollectionSegment {
  items: [LineDictionaryFirm]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input LineDictionaryFirmFilterInput {
  and: [LineDictionaryFirmFilterInput!]
  or: [LineDictionaryFirmFilterInput!]
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  lineDictionaryId: StringOperationFilterInput
  lineDictionary: LineDictionaryFilterInput
  salesChannelId: StringOperationFilterInput
  salesChannel: SaleChannelFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input LineDictionaryFirmInput {
  firmId: String
  lineDictionaryId: String
  salesChannelId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type LineDictionaryFirmMutation {
  add(model: [LineDictionaryFirmInput]): [LineDictionaryFirm]
  update(model: [LineDictionaryFirmInput]): [LineDictionaryFirm]
  addOrUpdate(model: [LineDictionaryFirmInput]): [LineDictionaryFirm]
  delete(model: [LineDictionaryFirmInput]): [LineDictionaryFirm]
}

type LineDictionaryFirmQuery {
  all(skip: Int, take: Int, where: LineDictionaryFirmFilterInput, order: [LineDictionaryFirmSortInput!]): LineDictionaryFirmCollectionSegment
  userInfo(model: LineDictionaryFirmInput): UserInfo
  getByKeys(firmId: String, lineDictionaryId: String): [LineDictionaryFirm]
}

input LineDictionaryFirmSortInput {
  firmId: SortEnumType
  firm: FirmSortInput
  lineDictionaryId: SortEnumType
  lineDictionary: LineDictionarySortInput
  salesChannelId: SortEnumType
  salesChannel: SaleChannelSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input LineDictionaryInput {
  parentId: String
  name: [LocaleInput!]!
  type: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type LineDictionaryMutation {
  add(model: [LineDictionaryInput]): [LineDictionary]
  update(model: [LineDictionaryInput]): [LineDictionary]
  addOrUpdate(model: [LineDictionaryInput]): [LineDictionary]
  delete(model: [LineDictionaryInput]): [LineDictionary]
}

type LineDictionaryQuery {
  all(skip: Int, take: Int, where: LineDictionaryFilterInput, order: [LineDictionarySortInput!]): LineDictionaryCollectionSegment
  userInfo(model: LineDictionaryInput): UserInfo
  getByKeys(id: String): [LineDictionary]
}

input LineDictionarySortInput {
  parentId: SortEnumType
  parent: LineDictionarySortInput
  type: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input ListComparableDecimalOperationFilterInput {
  all: ComparableDecimalOperationFilterInput
  none: ComparableDecimalOperationFilterInput
  some: ComparableDecimalOperationFilterInput
  any: Boolean
}

input ListFilterInputTypeOfAlphaDiscountFilterInput {
  all: AlphaDiscountFilterInput
  none: AlphaDiscountFilterInput
  some: AlphaDiscountFilterInput
  any: Boolean
}

input ListFilterInputTypeOfGoodsMovementNodeFilterInput {
  all: GoodsMovementNodeFilterInput
  none: GoodsMovementNodeFilterInput
  some: GoodsMovementNodeFilterInput
  any: Boolean
}

input ListFilterInputTypeOfImageLinkFilterInput {
  all: ImageLinkFilterInput
  none: ImageLinkFilterInput
  some: ImageLinkFilterInput
  any: Boolean
}

input ListFilterInputTypeOfIncomingGoodsReportNodeFilterInput {
  all: IncomingGoodsReportNodeFilterInput
  none: IncomingGoodsReportNodeFilterInput
  some: IncomingGoodsReportNodeFilterInput
  any: Boolean
}

input ListFilterInputTypeOfLocaleFilterInput {
  all: LocaleFilterInput
  none: LocaleFilterInput
  some: LocaleFilterInput
  any: Boolean
}

input ListFilterInputTypeOfSalesPlanImplementationNodeFilterInput {
  all: SalesPlanImplementationNodeFilterInput
  none: SalesPlanImplementationNodeFilterInput
  some: SalesPlanImplementationNodeFilterInput
  any: Boolean
}

input ListFilterInputTypeOfStatusHistoryFilterInput {
  all: StatusHistoryFilterInput
  none: StatusHistoryFilterInput
  some: StatusHistoryFilterInput
  any: Boolean
}

input ListFilterInputTypeOfTimesheetDaySummaryStatisticsFilterInput {
  all: TimesheetDaySummaryStatisticsFilterInput
  none: TimesheetDaySummaryStatisticsFilterInput
  some: TimesheetDaySummaryStatisticsFilterInput
  any: Boolean
}

input ListFilterInputTypeOfTimesheetEmployeeDailyHoursInfoFilterInput {
  all: TimesheetEmployeeDailyHoursInfoFilterInput
  none: TimesheetEmployeeDailyHoursInfoFilterInput
  some: TimesheetEmployeeDailyHoursInfoFilterInput
  any: Boolean
}

input ListFilterInputTypeOfTimesheetEmployeeFieldsModelFilterInput {
  all: TimesheetEmployeeFieldsModelFilterInput
  none: TimesheetEmployeeFieldsModelFilterInput
  some: TimesheetEmployeeFieldsModelFilterInput
  any: Boolean
}

type Locale {
  language: String
  name: String
}

input LocaleFilterInput {
  and: [LocaleFilterInput!]
  or: [LocaleFilterInput!]
  language: StringOperationFilterInput
  name: StringOperationFilterInput
}

input LocaleInput {
  language: String
  name: String
}

type Location {
  parentId: String
  type: Int
  code: String
  name: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: Location!
}

type LocationCollectionSegment {
  items: [Location]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input LocationFilterInput {
  and: [LocationFilterInput!]
  or: [LocationFilterInput!]
  parentId: StringOperationFilterInput
  parent: LocationFilterInput
  type: ComparableInt32OperationFilterInput
  code: StringOperationFilterInput
  name: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input LocationInput {
  parentId: String
  type: Int
  code: String
  name: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type LocationMutation {
  add(model: [LocationInput]): [Location]
  update(model: [LocationInput]): [Location]
  addOrUpdate(model: [LocationInput]): [Location]
  delete(model: [LocationInput]): [Location]
}

type LocationQuery {
  all(skip: Int, take: Int, where: LocationFilterInput, order: [LocationSortInput!]): LocationCollectionSegment
  userInfo(model: LocationInput): UserInfo
  getByKeys(id: String): [Location]
}

input LocationSortInput {
  parentId: SortEnumType
  parent: LocationSortInput
  type: SortEnumType
  code: SortEnumType
  name: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Log {
  message: String
  level: String
  logger: String
  datetime: DateTime
}

type LogCollectionSegment {
  items: [Log]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input LogFilterInput {
  and: [LogFilterInput!]
  or: [LogFilterInput!]
  message: StringOperationFilterInput
  level: StringOperationFilterInput
  logger: StringOperationFilterInput
  datetime: ComparableDateTimeOperationFilterInput
}

input LogInput {
  message: String
  level: String
  logger: String
  datetime: DateTime
}

type LogMutation {
  add(model: [LogInput]): [Log]
  update(model: [LogInput]): [Log]
  addOrUpdate(model: [LogInput]): [Log]
  delete(model: [LogInput]): [Log]
}

type LogQuery {
  all(skip: Int, take: Int, where: LogFilterInput, order: [LogSortInput!]): LogCollectionSegment
  userInfo(model: LogInput): UserInfo
}

input LogSortInput {
  message: SortEnumType
  level: SortEnumType
  logger: SortEnumType
  datetime: SortEnumType
}

"""
The `Long` scalar type represents non-fractional signed whole 64-bit numeric
values. Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type MainMutations {
  productStoreCondition: ProductStoreConditionMutation
  priceRuleRelation: PriceRuleRelationMutation
  symptom: SymptomMutation
  formFactory: FormFactoryMutation
  invoiceStateInvoices: InvoiceStateInvoicesMutation
  salesPlan: SalesPlanMutation
  productSubstance: ProductSubstanceMutation
  invoiceDiscord: InvoiceDiscordMutation
  invoiceOutProduct: InvoiceOutProductMutation
  firmEmployee: FirmEmployeeMutation
  priceRuleRelationSaleChannel: PriceRuleRelationSaleChannelMutation
  address: AddressMutation
  priceRule: PriceRuleMutation
  refreshToken: RefreshTokenMutation
  productManager: ProductManagerMutation
  userRole: UserRoleMutation
  invoiceInProduct: InvoiceInProductMutation
  taskJournal: TaskJournalMutation
  extDrugstore: ExtDrugstoreMutation
  storeFrame: StoreFrameMutation
  kPISalesPlan: KPISalesPlanMutation
  templateData: TemplateDataMutation
  documentsNumber: DocumentsNumberMutation
  priceRange: PriceRangeMutation
  cashOper: CashOperMutation
  relatedCategoryProduct: RelatedCategoryProductMutation
  invoiceOutInsideProduct: InvoiceOutInsideProductMutation
  benefitReturnModel: BenefitReturnModelMutation
  groupPrice: GroupPriceMutation
  inventory: InventoryMutation
  viewQuantity: ViewQuantityMutation
  contractComission: ContractComissionMutation
  firmSetting: FirmSettingMutation
  discordReason: DiscordReasonMutation
  storeCondition: StoreConditionMutation
  productGroup: ProductGroupMutation
  priceRuleRelationStructureCatalogGroup: PriceRuleRelationStructureCatalogGroupMutation
  externalReceiptProduct: ExternalReceiptProductMutation
  productSymptom: ProductSymptomMutation
  bill: BillMutation
  consumptionMethod: ConsumptionMethodMutation
  userTemplates: UserTemplatesMutation
  scanProduct: ScanProductMutation
  segregatedStorage: SegregatedStorageMutation
  unit: UnitMutation
  cashboxPermit: CashboxPermitMutation
  priceRuleRelationProduct: PriceRuleRelationProductMutation
  firmGroup: FirmGroupMutation
  inventoryPurpose: InventoryPurposeMutation
  returnReason: ReturnReasonMutation
  storeFrameProduct: StoreFrameProductMutation
  receiptAdditionalInfo: ReceiptAdditionalInfoMutation
  priceRuleRelationContractor: PriceRuleRelationContractorMutation
  store: StoreMutation
  systemSettings: SystemSettingsMutation
  log: LogMutation
  productBar: ProductBarMutation
  doctor: DoctorMutation
  invoiceState: InvoiceStateMutation
  changes: ChangesMutation
  taxRate: TaxRateMutation
  kPIPlanDistribution: KPIPlanDistributionMutation
  returnReasonInvoice: ReturnReasonInvoiceMutation
  productKind: ProductKindMutation
  moving: MovingMutation
  clientSettings: ClientSettingsMutation
  device: DeviceMutation
  deviceModel: DeviceModelMutation
  invoiceOut: InvoiceOutMutation
  nationRegulPrice: NationRegulPriceMutation
  location: LocationMutation
  invoiceInReturnProduct: InvoiceInReturnProductMutation
  currency: CurrencyMutation
  invoiceInReturn: InvoiceInReturnMutation
  externalReceiptDelivery: ExternalReceiptDeliveryMutation
  catalogGroupItem: CatalogGroupItemMutation
  formOwn: FormOwnMutation
  role: RoleMutation
  lineDictionaryFirm: LineDictionaryFirmMutation
  productConsumptionMethod: ProductConsumptionMethodMutation
  receiptPayment: ReceiptPaymentMutation
  invoiceIn: InvoiceInMutation
  externalReceiptInsurer: ExternalReceiptInsurerMutation
  bank: BankMutation
  client: ClientMutation
  priceRuleRelationProductCatalogGroup: PriceRuleRelationProductCatalogGroupMutation
  benefit: BenefitMutation
  policy: PolicyMutation
  receipt: ReceiptMutation
  speciality: SpecialityMutation
  user: UserMutation
  firmAccount: FirmAccountMutation
  firm: FirmMutation
  reimbursementMedication: ReimbursementMedicationMutation
  catalogGroupField: CatalogGroupFieldMutation
  inventoryProduct: InventoryProductMutation
  productTransform: ProductTransformMutation
  product: ProductMutation
  newProduct: NewProductMutation
  receiptProduct: ReceiptProductMutation
  invoiceInInsideProduct: InvoiceInInsideProductMutation
  partyBase: PartyBaseMutation
  quantity: QuantityMutation
  lineDictionary: LineDictionaryMutation
  scan: ScanMutation
  cashbox: CashboxMutation
  productBrand: ProductBrandMutation
  userData: UserDataMutation
  catalogGroup: CatalogGroupMutation
  externalPriceList: ExternalPriceListMutation
  objectsCompliance: ObjectsComplianceMutation
  externalReceipt: ExternalReceiptMutation
  priceRoundRule: PriceRoundRuleMutation
  structure: StructureMutation
  billProduct: BillProductMutation
  post: PostMutation
  invoiceOutInside: InvoiceOutInsideMutation
  dateChanges: DateChangesMutation
  menu: MenuMutation
  priceRuleRelationRange: PriceRuleRelationRangeMutation
  substance: SubstanceMutation
  cashOrder: CashOrderMutation
  kPISalesPlanProduct: KPISalesPlanProductMutation
  benefitSaleChannel: BenefitSaleChannelMutation
  groupFirm: GroupFirmMutation
  relatedCategory: RelatedCategoryMutation
  invoiceOrder: InvoiceOrderMutation
  rolePermition: RolePermitionMutation
  contract: ContractMutation
  salesPlanDay: SalesPlanDayMutation
  cashboxPermitAction: CashboxPermitActionMutation
  contractToSpecification: ContractToSpecificationMutation
  invoiceInInside: InvoiceInInsideMutation
  movingProduct: MovingProductMutation
  employee: EmployeeMutation
  quantityParty: QuantityPartyMutation
  priceRuleRelationStructure: PriceRuleRelationStructureMutation
  contractBuySale: ContractBuySaleMutation
  saleChannel: SaleChannelMutation
  productCategory: ProductCategoryMutation
  timesheets: TimesheetMutations
  exportMutations: ExportMutation
  kPISalesPlans: KPISalesPlanMutations
  inventories: InventoryMutations
  inventoryProducts: InventoryProductMutations
  taskJournals: TaskJournalMutations
  clientSetting: ClientSettingMutations
}

type MainQuery {
  productStoreCondition: ProductStoreConditionQuery
  priceRuleRelation: PriceRuleRelationQuery
  symptom: SymptomQuery
  formFactory: FormFactoryQuery
  invoiceStateInvoices: InvoiceStateInvoicesQuery
  salesPlan: SalesPlanQuery
  productSubstance: ProductSubstanceQuery
  invoiceDiscord: InvoiceDiscordQuery
  invoiceOutProduct: InvoiceOutProductQuery
  firmEmployee: FirmEmployeeQuery
  priceRuleRelationSaleChannel: PriceRuleRelationSaleChannelQuery
  address: AddressQuery
  priceRule: PriceRuleQuery
  refreshToken: RefreshTokenQuery
  productManager: ProductManagerQuery
  userRole: UserRoleQuery
  invoiceInProduct: InvoiceInProductQuery
  taskJournal: TaskJournalQuery
  extDrugstore: ExtDrugstoreQuery
  storeFrame: StoreFrameQuery
  kPISalesPlan: KPISalesPlanQuery
  templateData: TemplateDataQuery
  documentsNumber: DocumentsNumberQuery
  priceRange: PriceRangeQuery
  cashOper: CashOperQuery
  relatedCategoryProduct: RelatedCategoryProductQuery
  invoiceOutInsideProduct: InvoiceOutInsideProductQuery
  benefitReturnModel: BenefitReturnModelQuery
  groupPrice: GroupPriceQuery
  inventory: InventoryQuery
  viewQuantity: ViewQuantityQuery
  contractComission: ContractComissionQuery
  firmSetting: FirmSettingQuery
  discordReason: DiscordReasonQuery
  storeCondition: StoreConditionQuery
  productGroup: ProductGroupQuery
  priceRuleRelationStructureCatalogGroup: PriceRuleRelationStructureCatalogGroupQuery
  externalReceiptProduct: ExternalReceiptProductQuery
  productSymptom: ProductSymptomQuery
  bill: BillQuery
  consumptionMethod: ConsumptionMethodQuery
  userTemplates: UserTemplatesQuery
  scanProduct: ScanProductQuery
  segregatedStorage: SegregatedStorageQuery
  unit: UnitQuery
  cashboxPermit: CashboxPermitQuery
  priceRuleRelationProduct: PriceRuleRelationProductQuery
  firmGroup: FirmGroupQuery
  inventoryPurpose: InventoryPurposeQuery
  returnReason: ReturnReasonQuery
  storeFrameProduct: StoreFrameProductQuery
  receiptAdditionalInfo: ReceiptAdditionalInfoQuery
  priceRuleRelationContractor: PriceRuleRelationContractorQuery
  store: StoreQuery
  systemSettings: SystemSettingsQuery
  log: LogQuery
  productBar: ProductBarQuery
  doctor: DoctorQuery
  invoiceState: InvoiceStateQuery
  changes: ChangesQuery
  taxRate: TaxRateQuery
  kPIPlanDistribution: KPIPlanDistributionQuery
  returnReasonInvoice: ReturnReasonInvoiceQuery
  productKind: ProductKindQuery
  moving: MovingQuery
  clientSettings: ClientSettingsQuery
  device: DeviceQuery
  deviceModel: DeviceModelQuery
  invoiceOut: InvoiceOutQuery
  nationRegulPrice: NationRegulPriceQuery
  location: LocationQuery
  invoiceInReturnProduct: InvoiceInReturnProductQuery
  currency: CurrencyQuery
  invoiceInReturn: InvoiceInReturnQuery
  externalReceiptDelivery: ExternalReceiptDeliveryQuery
  catalogGroupItem: CatalogGroupItemQuery
  formOwn: FormOwnQuery
  role: RoleQuery
  lineDictionaryFirm: LineDictionaryFirmQuery
  productConsumptionMethod: ProductConsumptionMethodQuery
  receiptPayment: ReceiptPaymentQuery
  invoiceIn: InvoiceInQuery
  externalReceiptInsurer: ExternalReceiptInsurerQuery
  bank: BankQuery
  client: ClientQuery
  priceRuleRelationProductCatalogGroup: PriceRuleRelationProductCatalogGroupQuery
  benefit: BenefitQuery
  policy: PolicyQuery
  receipt: ReceiptQuery
  speciality: SpecialityQuery
  user: UserQuery
  firmAccount: FirmAccountQuery
  firm: FirmQuery
  reimbursementMedication: ReimbursementMedicationQuery
  catalogGroupField: CatalogGroupFieldQuery
  inventoryProduct: InventoryProductQuery
  productTransform: ProductTransformQuery
  product: ProductQuery
  newProduct: NewProductQuery
  receiptProduct: ReceiptProductQuery
  invoiceInInsideProduct: InvoiceInInsideProductQuery
  partyBase: PartyBaseQuery
  quantity: QuantityQuery
  lineDictionary: LineDictionaryQuery
  scan: ScanQuery
  cashbox: CashboxQuery
  productBrand: ProductBrandQuery
  userData: UserDataQuery
  catalogGroup: CatalogGroupQuery
  externalPriceList: ExternalPriceListQuery
  objectsCompliance: ObjectsComplianceQuery
  externalReceipt: ExternalReceiptQuery
  priceRoundRule: PriceRoundRuleQuery
  structure: StructureQuery
  billProduct: BillProductQuery
  post: PostQuery
  invoiceOutInside: InvoiceOutInsideQuery
  dateChanges: DateChangesQuery
  menu: MenuQuery
  priceRuleRelationRange: PriceRuleRelationRangeQuery
  substance: SubstanceQuery
  cashOrder: CashOrderQuery
  kPISalesPlanProduct: KPISalesPlanProductQuery
  benefitSaleChannel: BenefitSaleChannelQuery
  groupFirm: GroupFirmQuery
  relatedCategory: RelatedCategoryQuery
  invoiceOrder: InvoiceOrderQuery
  rolePermition: RolePermitionQuery
  contract: ContractQuery
  salesPlanDay: SalesPlanDayQuery
  cashboxPermitAction: CashboxPermitActionQuery
  contractToSpecification: ContractToSpecificationQuery
  invoiceInInside: InvoiceInInsideQuery
  movingProduct: MovingProductQuery
  employee: EmployeeQuery
  quantityParty: QuantityPartyQuery
  priceRuleRelationStructure: PriceRuleRelationStructureQuery
  contractBuySale: ContractBuySaleQuery
  saleChannel: SaleChannelQuery
  productCategory: ProductCategoryQuery
  timesheets: TimesheetQueries
  kPISalesPlans: KPISalesPlanQueries
  inventories: InventoryQueries
  inventoryProducts: InventoryProductQueries
  scanProducts: ScanProductQueries
  auth: AuthQueries
  baseReports: BaseReportsQueries
  enum: EnumQueries
  settings: SettingsQueries
  acceptanceAct: AcceptanceActQueries
  firmAdd: FirmQueries
  productAdd: ProductQueries
  headers: [BaseModelExtensionsDescription]
  clientSetting: ClientSettingQueries
}

type Menu {
  parentId: String
  _raw_json_name: String
  name: [Locale]
  url: String
  image: String
  level: Int
  tooltip: String
  sortOrder: Int
  color: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: Menu
}

type MenuCollectionSegment {
  items: [Menu]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input MenuFilterInput {
  and: [MenuFilterInput!]
  or: [MenuFilterInput!]
  parentId: StringOperationFilterInput
  parent: MenuFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  url: StringOperationFilterInput
  image: StringOperationFilterInput
  level: ComparableNullableOfInt32OperationFilterInput
  tooltip: StringOperationFilterInput
  sortOrder: ComparableNullableOfInt32OperationFilterInput
  color: ComparableNullableOfInt32OperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input MenuInput {
  parentId: String
  name: [LocaleInput!]!
  url: String
  image: String
  level: Int
  tooltip: String
  sortOrder: Int
  color: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type MenuMutation {
  add(model: [MenuInput]): [Menu]
  update(model: [MenuInput]): [Menu]
  addOrUpdate(model: [MenuInput]): [Menu]
  delete(model: [MenuInput]): [Menu]
}

type MenuQuery {
  all(skip: Int, take: Int, where: MenuFilterInput, order: [MenuSortInput!]): MenuCollectionSegment
  userInfo(model: MenuInput): UserInfo
  getByKeys(id: String): [Menu]
}

input MenuSortInput {
  parentId: SortEnumType
  parent: MenuSortInput
  url: SortEnumType
  image: SortEnumType
  level: SortEnumType
  tooltip: SortEnumType
  sortOrder: SortEnumType
  color: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Moving {
  globalCode: String
  direct: Int
  firmId: String
  structureId: String
  storeFromId: String
  storeToId: String
  frpId: String
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  filterByStoreId(id: [String!]!): Boolean!
  firm: Firm
  firmJson: FirmBase
  structure: Structure
  structureJson: StructureBase
  storeFrom: Store
  storeFromJson: StoreBase
  storeTo: Store
  storeToJson: StoreBase
  frp: FirmEmployee
  frpJson: FirmEmployeeBase
  currency: Currency
}

type MovingCollectionSegment {
  items: [Moving]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input MovingFilterInput {
  and: [MovingFilterInput!]
  or: [MovingFilterInput!]
  globalCode: StringOperationFilterInput
  direct: ComparableInt32OperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  firmJson: FirmBaseFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  structureJson: StructureBaseFilterInput
  storeFromId: StringOperationFilterInput
  storeFrom: StoreFilterInput
  storeFromJson: StoreBaseFilterInput
  storeToId: StringOperationFilterInput
  storeTo: StoreFilterInput
  storeToJson: StoreBaseFilterInput
  frpId: StringOperationFilterInput
  frp: FirmEmployeeFilterInput
  frpJson: FirmEmployeeBaseFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  parentDocumentId: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input MovingInput {
  globalCode: String
  direct: Int
  firmId: String
  firmJson: FirmBaseInput
  structureId: String
  structureJson: StructureBaseInput
  storeFromId: String
  storeFromJson: StoreBaseInput
  storeToId: String
  storeToJson: StoreBaseInput
  frpId: String
  frpJson: FirmEmployeeBaseInput
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  date: DateTime
  name: String
  sum: Decimal
  currencyId: String
  parentDocumentId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type MovingMutation {
  add(model: [MovingInput]): [Moving]
  update(model: [MovingInput]): [Moving]
  addOrUpdate(model: [MovingInput]): [Moving]
  delete(model: [MovingInput]): [Moving]
}

type MovingProduct {
  movingId: String
  productId: String
  productBarId: String
  amount: Decimal
  unitId: String
  priceBase: Decimal
  sumBase: Decimal
  partyFirmQuantityId: String
  storeFrameFromId: String
  storeFrameFromCode: String
  storeFrameToId: String
  storeFrameToCode: String
  partyBaseId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  masterTableId: String!
  moving: Moving
  product: Product
  productJson: Product
  productBar: ProductBar
  productBarJson: ProductBarBase
  unit: Unit
  unitJson: UnitBase
  storeFrameFrom: StoreFrame
  storeFrameTo: StoreFrame
  partyBase: PartyBase!
}

type MovingProductCollectionSegment {
  items: [MovingProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input MovingProductFilterInput {
  and: [MovingProductFilterInput!]
  or: [MovingProductFilterInput!]
  movingId: StringOperationFilterInput
  moving: MovingFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  productBarId: StringOperationFilterInput
  productBar: ProductBarFilterInput
  productBarJson: ProductBarBaseFilterInput
  amount: ComparableDecimalOperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitBaseFilterInput
  priceBase: ComparableDecimalOperationFilterInput
  sumBase: ComparableDecimalOperationFilterInput
  partyFirmQuantityId: StringOperationFilterInput
  storeFrameFromId: StringOperationFilterInput
  storeFrameFrom: StoreFrameFilterInput
  storeFrameFromCode: StringOperationFilterInput
  storeFrameToId: StringOperationFilterInput
  storeFrameTo: StoreFrameFilterInput
  storeFrameToCode: StringOperationFilterInput
  partyBaseId: StringOperationFilterInput
  partyBase: PartyBaseFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input MovingProductInput {
  movingId: String
  productId: String
  productJson: ProductInput
  productBarId: String
  productBarJson: ProductBarBaseInput
  amount: Decimal
  unitId: String
  unitJson: UnitBaseInput
  priceBase: Decimal
  sumBase: Decimal
  partyFirmQuantityId: String
  storeFrameFromId: String
  storeFrameFromCode: String
  storeFrameToId: String
  storeFrameToCode: String
  partyBaseId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type MovingProductMutation {
  add(model: [MovingProductInput]): [MovingProduct]
  update(model: [MovingProductInput]): [MovingProduct]
  addOrUpdate(model: [MovingProductInput]): [MovingProduct]
  delete(model: [MovingProductInput]): [MovingProduct]
}

type MovingProductQuery {
  all(skip: Int, take: Int, where: MovingProductFilterInput, order: [MovingProductSortInput!]): MovingProductCollectionSegment
  userInfo(model: MovingProductInput): UserInfo
  getByKeys(movingId: String, productId: String, partyFirmQuantityId: String, partyBaseId: String): [MovingProduct]
}

input MovingProductSortInput {
  movingId: SortEnumType
  moving: MovingSortInput
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  productBarId: SortEnumType
  productBar: ProductBarSortInput
  productBarJson: ProductBarBaseSortInput
  amount: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitBaseSortInput
  priceBase: SortEnumType
  sumBase: SortEnumType
  partyFirmQuantityId: SortEnumType
  storeFrameFromId: SortEnumType
  storeFrameFrom: StoreFrameSortInput
  storeFrameFromCode: SortEnumType
  storeFrameToId: SortEnumType
  storeFrameTo: StoreFrameSortInput
  storeFrameToCode: SortEnumType
  partyBaseId: SortEnumType
  partyBase: PartyBaseSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type MovingQuery {
  all(skip: Int, take: Int, where: MovingFilterInput, order: [MovingSortInput!]): MovingCollectionSegment
  userInfo(model: MovingInput): UserInfo
  getByKeys(id: String): [Moving]
}

input MovingSortInput {
  globalCode: SortEnumType
  direct: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  firmJson: FirmBaseSortInput
  structureId: SortEnumType
  structure: StructureSortInput
  structureJson: StructureBaseSortInput
  storeFromId: SortEnumType
  storeFrom: StoreSortInput
  storeFromJson: StoreBaseSortInput
  storeToId: SortEnumType
  storeTo: StoreSortInput
  storeToJson: StoreBaseSortInput
  frpId: SortEnumType
  frp: FirmEmployeeSortInput
  frpJson: FirmEmployeeBaseSortInput
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  parentDocumentId: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type NationRegulPrice {
  code: String
  _raw_json_name: String
  name: [Locale]
  percentMin: Decimal
  percentMax: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type NationRegulPriceCollectionSegment {
  items: [NationRegulPrice]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input NationRegulPriceFilterInput {
  and: [NationRegulPriceFilterInput!]
  or: [NationRegulPriceFilterInput!]
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  percentMin: ComparableNullableOfDecimalOperationFilterInput
  percentMax: ComparableNullableOfDecimalOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input NationRegulPriceInput {
  code: String
  name: [LocaleInput!]!
  percentMin: Decimal
  percentMax: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type NationRegulPriceMutation {
  add(model: [NationRegulPriceInput]): [NationRegulPrice]
  update(model: [NationRegulPriceInput]): [NationRegulPrice]
  addOrUpdate(model: [NationRegulPriceInput]): [NationRegulPrice]
  delete(model: [NationRegulPriceInput]): [NationRegulPrice]
}

type NationRegulPriceQuery {
  all(skip: Int, take: Int, where: NationRegulPriceFilterInput, order: [NationRegulPriceSortInput!]): NationRegulPriceCollectionSegment
  userInfo(model: NationRegulPriceInput): UserInfo
  getByKeys(id: String): [NationRegulPrice]
}

input NationRegulPriceSortInput {
  code: SortEnumType
  percentMin: SortEnumType
  percentMax: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type NewProduct {
  structureId: String
  inventoryId: String
  productName: String
  makerName: String
  taxRateId: String
  amount: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  structure: Structure!
  inventory: Inventory!
  taxRate: TaxRate!
}

type NewProductCollectionSegment {
  items: [NewProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input NewProductFilterInput {
  and: [NewProductFilterInput!]
  or: [NewProductFilterInput!]
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  inventoryId: StringOperationFilterInput
  inventory: InventoryFilterInput
  productName: StringOperationFilterInput
  makerName: StringOperationFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  amount: ComparableDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input NewProductInput {
  structureId: String
  inventoryId: String
  productName: String
  makerName: String
  taxRateId: String
  amount: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type NewProductMutation {
  add(model: [NewProductInput]): [NewProduct]
  update(model: [NewProductInput]): [NewProduct]
  addOrUpdate(model: [NewProductInput]): [NewProduct]
  delete(model: [NewProductInput]): [NewProduct]
}

type NewProductQuery {
  all(skip: Int, take: Int, where: NewProductFilterInput, order: [NewProductSortInput!]): NewProductCollectionSegment
  userInfo(model: NewProductInput): UserInfo
  getByKeys(id: String): [NewProduct]
}

input NewProductSortInput {
  structureId: SortEnumType
  structure: StructureSortInput
  inventoryId: SortEnumType
  inventory: InventorySortInput
  productName: SortEnumType
  makerName: SortEnumType
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  amount: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ObjectsCompliance {
  idFor1C: Int
  name: String
  altiusGuid: String
  objectType: ObjectType
}

type ObjectsComplianceCollectionSegment {
  items: [ObjectsCompliance]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ObjectsComplianceFilterInput {
  and: [ObjectsComplianceFilterInput!]
  or: [ObjectsComplianceFilterInput!]
  idFor1C: ComparableInt32OperationFilterInput
  name: StringOperationFilterInput
  altiusGuid: StringOperationFilterInput
  objectType: ObjectTypeOperationFilterInput
}

input ObjectsComplianceInput {
  idFor1C: Int
  name: String
  altiusGuid: String
  objectType: ObjectType
}

type ObjectsComplianceMutation {
  add(model: [ObjectsComplianceInput]): [ObjectsCompliance]
  update(model: [ObjectsComplianceInput]): [ObjectsCompliance]
  addOrUpdate(model: [ObjectsComplianceInput]): [ObjectsCompliance]
  delete(model: [ObjectsComplianceInput]): [ObjectsCompliance]
}

type ObjectsComplianceQuery {
  all(skip: Int, take: Int, where: ObjectsComplianceFilterInput, order: [ObjectsComplianceSortInput!]): ObjectsComplianceCollectionSegment
  userInfo(model: ObjectsComplianceInput): UserInfo
}

input ObjectsComplianceSortInput {
  idFor1C: SortEnumType
  name: SortEnumType
  altiusGuid: SortEnumType
  objectType: SortEnumType
}

enum ObjectType {
  V
  F
  S
  P
  G
  C
  D
  B
}

input ObjectTypeOperationFilterInput {
  eq: ObjectType
  neq: ObjectType
  in: [ObjectType!]
  nin: [ObjectType!]
}

type OrderBase {
  id: String
  number: String
  date: DateTime!
  name: String
}

input OrderBaseFilterInput {
  and: [OrderBaseFilterInput!]
  or: [OrderBaseFilterInput!]
  id: StringOperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
}

input OrderBaseInput {
  id: String
  number: String
  date: DateTime!
  name: String
}

input OrderBaseSortInput {
  id: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
}

type OrderInternet {
  externalReceiptId: String
  fio: String
  phone: String
  address: String
}

input OrderInternetFilterInput {
  and: [OrderInternetFilterInput!]
  or: [OrderInternetFilterInput!]
  externalReceiptId: StringOperationFilterInput
  fio: StringOperationFilterInput
  phone: StringOperationFilterInput
  address: StringOperationFilterInput
}

input OrderInternetInput {
  externalReceiptId: String
  fio: String
  phone: String
  address: String
}

input OrderInternetSortInput {
  externalReceiptId: SortEnumType
  fio: SortEnumType
  phone: SortEnumType
  address: SortEnumType
}

type PartyBase {
  documentGlobalCode: String
  documentNumber: String
  documentDate: DateTime
  documentFirmId: String
  productArticle: String
  productSeries: String
  productCert: String
  productDateValid: DateTime
  divided: Decimal
  useManualPrice: Boolean
  manualPrice: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PartyBaseCollectionSegment {
  items: [PartyBase]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PartyBaseFilterInput {
  and: [PartyBaseFilterInput!]
  or: [PartyBaseFilterInput!]
  documentGlobalCode: StringOperationFilterInput
  documentNumber: StringOperationFilterInput
  documentDate: ComparableDateTimeOperationFilterInput
  documentFirmId: StringOperationFilterInput
  productArticle: StringOperationFilterInput
  productSeries: StringOperationFilterInput
  productCert: StringOperationFilterInput
  productDateValid: ComparableNullableOfDateTimeOperationFilterInput
  divided: ComparableDecimalOperationFilterInput
  useManualPrice: BooleanOperationFilterInput
  manualPrice: ComparableNullableOfDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PartyBaseInput {
  documentGlobalCode: String
  documentNumber: String
  documentDate: DateTime
  documentFirmId: String
  productArticle: String
  productSeries: String
  productCert: String
  productDateValid: DateTime
  divided: Decimal
  useManualPrice: Boolean
  manualPrice: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PartyBaseMutation {
  add(model: [PartyBaseInput]): [PartyBase]
  update(model: [PartyBaseInput]): [PartyBase]
  addOrUpdate(model: [PartyBaseInput]): [PartyBase]
  delete(model: [PartyBaseInput]): [PartyBase]
}

type PartyBaseQuery {
  all(skip: Int, take: Int, where: PartyBaseFilterInput, order: [PartyBaseSortInput!]): PartyBaseCollectionSegment
  userInfo(model: PartyBaseInput): UserInfo
  getByKeys(id: String): [PartyBase]
}

input PartyBaseSortInput {
  documentGlobalCode: SortEnumType
  documentNumber: SortEnumType
  documentDate: SortEnumType
  documentFirmId: SortEnumType
  productArticle: SortEnumType
  productSeries: SortEnumType
  productCert: SortEnumType
  productDateValid: SortEnumType
  divided: SortEnumType
  useManualPrice: SortEnumType
  manualPrice: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Policy {
  number: String
  clientId: String
  insuranceCompanyId: String
  franchiseType: Int
  franchiseValue: Decimal
  policyBegin: DateTime
  policyEnd: DateTime
  taxRateId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  client: Employee!
  insuranceCompany: Firm!
  taxRate: TaxRate!
}

type PolicyCollectionSegment {
  items: [Policy]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PolicyFilterInput {
  and: [PolicyFilterInput!]
  or: [PolicyFilterInput!]
  number: StringOperationFilterInput
  clientId: StringOperationFilterInput
  client: EmployeeFilterInput
  insuranceCompanyId: StringOperationFilterInput
  insuranceCompany: FirmFilterInput
  franchiseType: ComparableInt32OperationFilterInput
  franchiseValue: ComparableDecimalOperationFilterInput
  policyBegin: ComparableNullableOfDateTimeOperationFilterInput
  policyEnd: ComparableNullableOfDateTimeOperationFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PolicyInput {
  number: String
  clientId: String
  insuranceCompanyId: String
  franchiseType: Int
  franchiseValue: Decimal
  policyBegin: DateTime
  policyEnd: DateTime
  taxRateId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PolicyMutation {
  add(model: [PolicyInput]): [Policy]
  update(model: [PolicyInput]): [Policy]
  addOrUpdate(model: [PolicyInput]): [Policy]
  delete(model: [PolicyInput]): [Policy]
}

type PolicyQuery {
  all(skip: Int, take: Int, where: PolicyFilterInput, order: [PolicySortInput!]): PolicyCollectionSegment
  userInfo(model: PolicyInput): UserInfo
  getByKeys(id: String): [Policy]
}

input PolicySortInput {
  number: SortEnumType
  clientId: SortEnumType
  client: EmployeeSortInput
  insuranceCompanyId: SortEnumType
  insuranceCompany: FirmSortInput
  franchiseType: SortEnumType
  franchiseValue: SortEnumType
  policyBegin: SortEnumType
  policyEnd: SortEnumType
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Post {
  code: String
  _raw_json_name: String
  name: [Locale]
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PostCollectionSegment {
  items: [Post]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PostFilterInput {
  and: [PostFilterInput!]
  or: [PostFilterInput!]
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  isUse: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PostInput {
  code: String
  name: [LocaleInput!]!
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PostMutation {
  add(model: [PostInput]): [Post]
  update(model: [PostInput]): [Post]
  addOrUpdate(model: [PostInput]): [Post]
  delete(model: [PostInput]): [Post]
}

type PostQuery {
  all(skip: Int, take: Int, where: PostFilterInput, order: [PostSortInput!]): PostCollectionSegment
  userInfo(model: PostInput): UserInfo
  getByKeys(id: String): [Post]
}

input PostSortInput {
  code: SortEnumType
  isUse: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceListModel {
  productId: String
  productName: [Locale!]!
  partyBaseId: String
  productSeries: String
  amount: Decimal!
  salePrice: Decimal!
}

type PriceListModelCollectionSegment {
  items: [PriceListModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceListModelFilterInput {
  and: [PriceListModelFilterInput!]
  or: [PriceListModelFilterInput!]
  productId: StringOperationFilterInput
  productName: ListFilterInputTypeOfLocaleFilterInput
  partyBaseId: StringOperationFilterInput
  productSeries: StringOperationFilterInput
  amount: ComparableDecimalOperationFilterInput
  salePrice: ComparableDecimalOperationFilterInput
}

input PriceListModelSortInput {
  productId: SortEnumType
  partyBaseId: SortEnumType
  productSeries: SortEnumType
  amount: SortEnumType
  salePrice: SortEnumType
}

type PriceRange {
  minPrice: Decimal
  maxPrice: Decimal
  description: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRangeCollectionSegment {
  items: [PriceRange]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRangeFilterInput {
  and: [PriceRangeFilterInput!]
  or: [PriceRangeFilterInput!]
  minPrice: ComparableDecimalOperationFilterInput
  maxPrice: ComparableDecimalOperationFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRangeInput {
  minPrice: Decimal
  maxPrice: Decimal
  description: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRangeMutation {
  add(model: [PriceRangeInput]): [PriceRange]
  update(model: [PriceRangeInput]): [PriceRange]
  addOrUpdate(model: [PriceRangeInput]): [PriceRange]
  delete(model: [PriceRangeInput]): [PriceRange]
}

type PriceRangeQuery {
  all(skip: Int, take: Int, where: PriceRangeFilterInput, order: [PriceRangeSortInput!]): PriceRangeCollectionSegment
  userInfo(model: PriceRangeInput): UserInfo
  getByKeys(id: String): [PriceRange]
}

input PriceRangeSortInput {
  minPrice: SortEnumType
  maxPrice: SortEnumType
  description: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceRoundRule {
  type: RoundRuleType
  precision: Decimal
  minusValue: Decimal
  description: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRoundRuleCollectionSegment {
  items: [PriceRoundRule]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRoundRuleFilterInput {
  and: [PriceRoundRuleFilterInput!]
  or: [PriceRoundRuleFilterInput!]
  type: RoundRuleTypeOperationFilterInput
  precision: ComparableDecimalOperationFilterInput
  minusValue: ComparableDecimalOperationFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRoundRuleInput {
  type: RoundRuleType
  precision: Decimal
  minusValue: Decimal
  description: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRoundRuleMutation {
  add(model: [PriceRoundRuleInput]): [PriceRoundRule]
  update(model: [PriceRoundRuleInput]): [PriceRoundRule]
  addOrUpdate(model: [PriceRoundRuleInput]): [PriceRoundRule]
  delete(model: [PriceRoundRuleInput]): [PriceRoundRule]
}

type PriceRoundRuleQuery {
  all(skip: Int, take: Int, where: PriceRoundRuleFilterInput, order: [PriceRoundRuleSortInput!]): PriceRoundRuleCollectionSegment
  userInfo(model: PriceRoundRuleInput): UserInfo
  getByKeys(id: String): [PriceRoundRule]
}

input PriceRoundRuleSortInput {
  type: SortEnumType
  precision: SortEnumType
  minusValue: SortEnumType
  description: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceRule {
  type: RuleType
  value: Decimal
  description: String
  priority: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleCollectionSegment {
  items: [PriceRule]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleFilterInput {
  and: [PriceRuleFilterInput!]
  or: [PriceRuleFilterInput!]
  type: RuleTypeOperationFilterInput
  value: ComparableDecimalOperationFilterInput
  description: StringOperationFilterInput
  priority: ComparableInt32OperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleInput {
  type: RuleType
  value: Decimal
  description: String
  priority: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleMutation {
  add(model: [PriceRuleInput]): [PriceRule]
  update(model: [PriceRuleInput]): [PriceRule]
  addOrUpdate(model: [PriceRuleInput]): [PriceRule]
  delete(model: [PriceRuleInput]): [PriceRule]
}

type PriceRuleQuery {
  all(skip: Int, take: Int, where: PriceRuleFilterInput, order: [PriceRuleSortInput!]): PriceRuleCollectionSegment
  userInfo(model: PriceRuleInput): UserInfo
  getByKeys(id: String): [PriceRule]
}

type PriceRuleRelation {
  name: String
  ruleId: String
  priority: Int
  dateStart: DateTime
  dateFinish: DateTime
  isActive: Boolean
  activeDays: String
  productGroupType: RuleGroupType
  structureGroupType: RuleGroupType
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  rule: PriceRule!
}

type PriceRuleRelationCollectionSegment {
  items: [PriceRuleRelation]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type PriceRuleRelationContractor {
  priceRuleRelationId: String
  contractorId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  priceRuleRelation: PriceRuleRelation!
  contractor: Firm!
}

type PriceRuleRelationContractorCollectionSegment {
  items: [PriceRuleRelationContractor]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleRelationContractorFilterInput {
  and: [PriceRuleRelationContractorFilterInput!]
  or: [PriceRuleRelationContractorFilterInput!]
  priceRuleRelationId: StringOperationFilterInput
  priceRuleRelation: PriceRuleRelationFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationContractorInput {
  priceRuleRelationId: String
  contractorId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationContractorMutation {
  add(model: [PriceRuleRelationContractorInput]): [PriceRuleRelationContractor]
  update(model: [PriceRuleRelationContractorInput]): [PriceRuleRelationContractor]
  addOrUpdate(model: [PriceRuleRelationContractorInput]): [PriceRuleRelationContractor]
  delete(model: [PriceRuleRelationContractorInput]): [PriceRuleRelationContractor]
}

type PriceRuleRelationContractorQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationContractorFilterInput, order: [PriceRuleRelationContractorSortInput!]): PriceRuleRelationContractorCollectionSegment
  userInfo(model: PriceRuleRelationContractorInput): UserInfo
  getByKeys(priceRuleRelationId: String, contractorId: String): [PriceRuleRelationContractor]
}

input PriceRuleRelationContractorSortInput {
  priceRuleRelationId: SortEnumType
  priceRuleRelation: PriceRuleRelationSortInput
  contractorId: SortEnumType
  contractor: FirmSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input PriceRuleRelationFilterInput {
  and: [PriceRuleRelationFilterInput!]
  or: [PriceRuleRelationFilterInput!]
  name: StringOperationFilterInput
  ruleId: StringOperationFilterInput
  rule: PriceRuleFilterInput
  priority: ComparableInt32OperationFilterInput
  dateStart: ComparableNullableOfDateTimeOperationFilterInput
  dateFinish: ComparableNullableOfDateTimeOperationFilterInput
  isActive: BooleanOperationFilterInput
  activeDays: StringOperationFilterInput
  productGroupType: RuleGroupTypeOperationFilterInput
  structureGroupType: RuleGroupTypeOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationInput {
  name: String
  ruleId: String
  priority: Int
  dateStart: DateTime
  dateFinish: DateTime
  isActive: Boolean
  activeDays: String
  productGroupType: RuleGroupType
  structureGroupType: RuleGroupType
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationMutation {
  add(model: [PriceRuleRelationInput]): [PriceRuleRelation]
  update(model: [PriceRuleRelationInput]): [PriceRuleRelation]
  addOrUpdate(model: [PriceRuleRelationInput]): [PriceRuleRelation]
  delete(model: [PriceRuleRelationInput]): [PriceRuleRelation]
}

type PriceRuleRelationProduct {
  priceRuleRelationId: String
  productId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  priceRuleRelation: PriceRuleRelation!
  product: Product!
}

type PriceRuleRelationProductCatalogGroup {
  priceRuleRelationId: String
  productCatalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  priceRuleRelation: PriceRuleRelation!
  productCatalogGroup: CatalogGroup!
}

type PriceRuleRelationProductCatalogGroupCollectionSegment {
  items: [PriceRuleRelationProductCatalogGroup]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleRelationProductCatalogGroupFilterInput {
  and: [PriceRuleRelationProductCatalogGroupFilterInput!]
  or: [PriceRuleRelationProductCatalogGroupFilterInput!]
  priceRuleRelationId: StringOperationFilterInput
  priceRuleRelation: PriceRuleRelationFilterInput
  productCatalogGroupId: StringOperationFilterInput
  productCatalogGroup: CatalogGroupFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationProductCatalogGroupInput {
  priceRuleRelationId: String
  productCatalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationProductCatalogGroupMutation {
  add(model: [PriceRuleRelationProductCatalogGroupInput]): [PriceRuleRelationProductCatalogGroup]
  update(model: [PriceRuleRelationProductCatalogGroupInput]): [PriceRuleRelationProductCatalogGroup]
  addOrUpdate(model: [PriceRuleRelationProductCatalogGroupInput]): [PriceRuleRelationProductCatalogGroup]
  delete(model: [PriceRuleRelationProductCatalogGroupInput]): [PriceRuleRelationProductCatalogGroup]
}

type PriceRuleRelationProductCatalogGroupQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationProductCatalogGroupFilterInput, order: [PriceRuleRelationProductCatalogGroupSortInput!]): PriceRuleRelationProductCatalogGroupCollectionSegment
  userInfo(model: PriceRuleRelationProductCatalogGroupInput): UserInfo
  getByKeys(priceRuleRelationId: String, productCatalogGroupId: String): [PriceRuleRelationProductCatalogGroup]
}

input PriceRuleRelationProductCatalogGroupSortInput {
  priceRuleRelationId: SortEnumType
  priceRuleRelation: PriceRuleRelationSortInput
  productCatalogGroupId: SortEnumType
  productCatalogGroup: CatalogGroupSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceRuleRelationProductCollectionSegment {
  items: [PriceRuleRelationProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleRelationProductFilterInput {
  and: [PriceRuleRelationProductFilterInput!]
  or: [PriceRuleRelationProductFilterInput!]
  priceRuleRelationId: StringOperationFilterInput
  priceRuleRelation: PriceRuleRelationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationProductInput {
  priceRuleRelationId: String
  productId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationProductMutation {
  add(model: [PriceRuleRelationProductInput]): [PriceRuleRelationProduct]
  update(model: [PriceRuleRelationProductInput]): [PriceRuleRelationProduct]
  addOrUpdate(model: [PriceRuleRelationProductInput]): [PriceRuleRelationProduct]
  delete(model: [PriceRuleRelationProductInput]): [PriceRuleRelationProduct]
}

type PriceRuleRelationProductQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationProductFilterInput, order: [PriceRuleRelationProductSortInput!]): PriceRuleRelationProductCollectionSegment
  userInfo(model: PriceRuleRelationProductInput): UserInfo
  getByKeys(priceRuleRelationId: String, productId: String): [PriceRuleRelationProduct]
}

input PriceRuleRelationProductSortInput {
  priceRuleRelationId: SortEnumType
  priceRuleRelation: PriceRuleRelationSortInput
  productId: SortEnumType
  product: ProductSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceRuleRelationQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationFilterInput, order: [PriceRuleRelationSortInput!]): PriceRuleRelationCollectionSegment
  userInfo(model: PriceRuleRelationInput): UserInfo
  getByKeys(id: String): [PriceRuleRelation]
}

type PriceRuleRelationRange {
  priceRuleRelationId: String
  priceRangeId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  priceRuleRelation: PriceRuleRelation!
  priceRange: PriceRange!
}

type PriceRuleRelationRangeCollectionSegment {
  items: [PriceRuleRelationRange]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleRelationRangeFilterInput {
  and: [PriceRuleRelationRangeFilterInput!]
  or: [PriceRuleRelationRangeFilterInput!]
  priceRuleRelationId: StringOperationFilterInput
  priceRuleRelation: PriceRuleRelationFilterInput
  priceRangeId: StringOperationFilterInput
  priceRange: PriceRangeFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationRangeInput {
  priceRuleRelationId: String
  priceRangeId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationRangeMutation {
  add(model: [PriceRuleRelationRangeInput]): [PriceRuleRelationRange]
  update(model: [PriceRuleRelationRangeInput]): [PriceRuleRelationRange]
  addOrUpdate(model: [PriceRuleRelationRangeInput]): [PriceRuleRelationRange]
  delete(model: [PriceRuleRelationRangeInput]): [PriceRuleRelationRange]
}

type PriceRuleRelationRangeQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationRangeFilterInput, order: [PriceRuleRelationRangeSortInput!]): PriceRuleRelationRangeCollectionSegment
  userInfo(model: PriceRuleRelationRangeInput): UserInfo
  getByKeys(priceRuleRelationId: String, priceRangeId: String): [PriceRuleRelationRange]
}

input PriceRuleRelationRangeSortInput {
  priceRuleRelationId: SortEnumType
  priceRuleRelation: PriceRuleRelationSortInput
  priceRangeId: SortEnumType
  priceRange: PriceRangeSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceRuleRelationSaleChannel {
  priceRuleRelationId: String
  saleChannelId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  priceRuleRelation: PriceRuleRelation!
  saleChannel: SaleChannel!
}

type PriceRuleRelationSaleChannelCollectionSegment {
  items: [PriceRuleRelationSaleChannel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleRelationSaleChannelFilterInput {
  and: [PriceRuleRelationSaleChannelFilterInput!]
  or: [PriceRuleRelationSaleChannelFilterInput!]
  priceRuleRelationId: StringOperationFilterInput
  priceRuleRelation: PriceRuleRelationFilterInput
  saleChannelId: StringOperationFilterInput
  saleChannel: SaleChannelFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationSaleChannelInput {
  priceRuleRelationId: String
  saleChannelId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationSaleChannelMutation {
  add(model: [PriceRuleRelationSaleChannelInput]): [PriceRuleRelationSaleChannel]
  update(model: [PriceRuleRelationSaleChannelInput]): [PriceRuleRelationSaleChannel]
  addOrUpdate(model: [PriceRuleRelationSaleChannelInput]): [PriceRuleRelationSaleChannel]
  delete(model: [PriceRuleRelationSaleChannelInput]): [PriceRuleRelationSaleChannel]
}

type PriceRuleRelationSaleChannelQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationSaleChannelFilterInput, order: [PriceRuleRelationSaleChannelSortInput!]): PriceRuleRelationSaleChannelCollectionSegment
  userInfo(model: PriceRuleRelationSaleChannelInput): UserInfo
  getByKeys(priceRuleRelationId: String, saleChannelId: String): [PriceRuleRelationSaleChannel]
}

input PriceRuleRelationSaleChannelSortInput {
  priceRuleRelationId: SortEnumType
  priceRuleRelation: PriceRuleRelationSortInput
  saleChannelId: SortEnumType
  saleChannel: SaleChannelSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input PriceRuleRelationSortInput {
  name: SortEnumType
  ruleId: SortEnumType
  rule: PriceRuleSortInput
  priority: SortEnumType
  dateStart: SortEnumType
  dateFinish: SortEnumType
  isActive: SortEnumType
  activeDays: SortEnumType
  productGroupType: SortEnumType
  structureGroupType: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceRuleRelationStructure {
  priceRuleRelationId: String
  structureId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  priceRuleRelation: PriceRuleRelation!
  structure: Structure!
}

type PriceRuleRelationStructureCatalogGroup {
  priceRuleRelationId: String
  structureCatalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  priceRuleRelation: PriceRuleRelation!
  structureCatalogGroup: CatalogGroup!
}

type PriceRuleRelationStructureCatalogGroupCollectionSegment {
  items: [PriceRuleRelationStructureCatalogGroup]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleRelationStructureCatalogGroupFilterInput {
  and: [PriceRuleRelationStructureCatalogGroupFilterInput!]
  or: [PriceRuleRelationStructureCatalogGroupFilterInput!]
  priceRuleRelationId: StringOperationFilterInput
  priceRuleRelation: PriceRuleRelationFilterInput
  structureCatalogGroupId: StringOperationFilterInput
  structureCatalogGroup: CatalogGroupFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationStructureCatalogGroupInput {
  priceRuleRelationId: String
  structureCatalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationStructureCatalogGroupMutation {
  add(model: [PriceRuleRelationStructureCatalogGroupInput]): [PriceRuleRelationStructureCatalogGroup]
  update(model: [PriceRuleRelationStructureCatalogGroupInput]): [PriceRuleRelationStructureCatalogGroup]
  addOrUpdate(model: [PriceRuleRelationStructureCatalogGroupInput]): [PriceRuleRelationStructureCatalogGroup]
  delete(model: [PriceRuleRelationStructureCatalogGroupInput]): [PriceRuleRelationStructureCatalogGroup]
}

type PriceRuleRelationStructureCatalogGroupQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationStructureCatalogGroupFilterInput, order: [PriceRuleRelationStructureCatalogGroupSortInput!]): PriceRuleRelationStructureCatalogGroupCollectionSegment
  userInfo(model: PriceRuleRelationStructureCatalogGroupInput): UserInfo
  getByKeys(priceRuleRelationId: String, structureCatalogGroupId: String): [PriceRuleRelationStructureCatalogGroup]
}

input PriceRuleRelationStructureCatalogGroupSortInput {
  priceRuleRelationId: SortEnumType
  priceRuleRelation: PriceRuleRelationSortInput
  structureCatalogGroupId: SortEnumType
  structureCatalogGroup: CatalogGroupSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type PriceRuleRelationStructureCollectionSegment {
  items: [PriceRuleRelationStructure]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input PriceRuleRelationStructureFilterInput {
  and: [PriceRuleRelationStructureFilterInput!]
  or: [PriceRuleRelationStructureFilterInput!]
  priceRuleRelationId: StringOperationFilterInput
  priceRuleRelation: PriceRuleRelationFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input PriceRuleRelationStructureInput {
  priceRuleRelationId: String
  structureId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type PriceRuleRelationStructureMutation {
  add(model: [PriceRuleRelationStructureInput]): [PriceRuleRelationStructure]
  update(model: [PriceRuleRelationStructureInput]): [PriceRuleRelationStructure]
  addOrUpdate(model: [PriceRuleRelationStructureInput]): [PriceRuleRelationStructure]
  delete(model: [PriceRuleRelationStructureInput]): [PriceRuleRelationStructure]
}

type PriceRuleRelationStructureQuery {
  all(skip: Int, take: Int, where: PriceRuleRelationStructureFilterInput, order: [PriceRuleRelationStructureSortInput!]): PriceRuleRelationStructureCollectionSegment
  userInfo(model: PriceRuleRelationStructureInput): UserInfo
  getByKeys(priceRuleRelationId: String, structureId: String): [PriceRuleRelationStructure]
}

input PriceRuleRelationStructureSortInput {
  priceRuleRelationId: SortEnumType
  priceRuleRelation: PriceRuleRelationSortInput
  structureId: SortEnumType
  structure: StructureSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input PriceRuleSortInput {
  type: SortEnumType
  value: SortEnumType
  description: SortEnumType
  priority: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Product {
  article: String
  _raw_json_nameShort: String
  nameShort: [Locale]
  _raw_json_nameFull: String
  nameFull: [Locale]
  unitId: String
  isActive: Boolean
  shelfLife: Int
  formFactoryId: String
  firmId: String
  taxRateId: String
  productBrandId: String
  codeUKTZ: String
  divided: Decimal
  productCategoryId: String
  productGroupId: String
  registerNumber: String
  registerDate: DateTime
  registerDateEnd: DateTime
  width: Decimal
  height: Decimal
  depth: Decimal
  weight: Decimal
  maxQtyPerReceipt: Int
  minQtyPerReceipt: Int
  doseUnitId: String
  doseValue: Decimal
  packageQty: Int
  codeMorion: String
  reimbursementMedicationId: String
  needReceipt: Boolean
  _raw_json_imageLink: String
  imageLink: [ImageLink]
  info: String
  toc: Boolean
  segregatedStorageId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  unit: Unit
  formFactory: FormFactory
  firm: Firm
  taxRate: TaxRate!
  productBrand: ProductBrand
  productCategory: ProductCategory
  productGroup: ProductGroup
  doseUnit: Unit
  reimbursementMedication: ReimbursementMedication
  segregatedStorage: SegregatedStorage
  bars: [ProductBar!]
  substancies: [ProductSubstance!]
  symptoms: [ProductSymptom!]
  transforms: [ProductTransform!]
  consumptionMethods: [ProductConsumptionMethod!]
  storeConditions: [ProductStoreCondition!]
}

type ProductBar {
  code: String
  productId: String
  type: Int
  unitId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  unit: Unit!
}

type ProductBarBase {
  code: String
}

input ProductBarBaseFilterInput {
  and: [ProductBarBaseFilterInput!]
  or: [ProductBarBaseFilterInput!]
  code: StringOperationFilterInput
}

input ProductBarBaseInput {
  code: String
}

input ProductBarBaseSortInput {
  code: SortEnumType
}

type ProductBarCollectionSegment {
  items: [ProductBar]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductBarFilterInput {
  and: [ProductBarFilterInput!]
  or: [ProductBarFilterInput!]
  code: StringOperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  type: ComparableInt32OperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductBarInput {
  code: String
  productId: String
  type: Int
  unitId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductBarMutation {
  add(model: [ProductBarInput]): [ProductBar]
  update(model: [ProductBarInput]): [ProductBar]
  addOrUpdate(model: [ProductBarInput]): [ProductBar]
  delete(model: [ProductBarInput]): [ProductBar]
}

type ProductBarQuery {
  all(skip: Int, take: Int, where: ProductBarFilterInput, order: [ProductBarSortInput!]): ProductBarCollectionSegment
  userInfo(model: ProductBarInput): UserInfo
  getByKeys(id: String): [ProductBar]
}

input ProductBarSortInput {
  code: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  type: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductBase {
  id: String
  article: String
  nameShort: [Locale!]!
  formFactoryId: String
  divided: Decimal!
  codeUKTZ: String
}

input ProductBaseFilterInput {
  and: [ProductBaseFilterInput!]
  or: [ProductBaseFilterInput!]
  id: StringOperationFilterInput
  article: StringOperationFilterInput
  nameShort: ListFilterInputTypeOfLocaleFilterInput
  formFactoryId: StringOperationFilterInput
  divided: ComparableDecimalOperationFilterInput
  codeUKTZ: StringOperationFilterInput
}

input ProductBaseInput {
  id: String
  article: String
  nameShort: [LocaleInput!]!
  formFactoryId: String
  divided: Decimal!
  codeUKTZ: String
}

input ProductBaseSortInput {
  id: SortEnumType
  article: SortEnumType
  formFactoryId: SortEnumType
  divided: SortEnumType
  codeUKTZ: SortEnumType
}

type ProductBrand {
  code: String
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductBrandCollectionSegment {
  items: [ProductBrand]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductBrandFilterInput {
  and: [ProductBrandFilterInput!]
  or: [ProductBrandFilterInput!]
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductBrandInput {
  code: String
  name: [LocaleInput!]!
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductBrandMutation {
  add(model: [ProductBrandInput]): [ProductBrand]
  update(model: [ProductBrandInput]): [ProductBrand]
  addOrUpdate(model: [ProductBrandInput]): [ProductBrand]
  delete(model: [ProductBrandInput]): [ProductBrand]
}

type ProductBrandQuery {
  all(skip: Int, take: Int, where: ProductBrandFilterInput, order: [ProductBrandSortInput!]): ProductBrandCollectionSegment
  userInfo(model: ProductBrandInput): UserInfo
  getByKeys(id: String): [ProductBrand]
}

input ProductBrandSortInput {
  code: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductCategory {
  parentId: String
  code: String
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: ProductCategory!
}

type ProductCategoryCollectionSegment {
  items: [ProductCategory]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductCategoryFilterInput {
  and: [ProductCategoryFilterInput!]
  or: [ProductCategoryFilterInput!]
  parentId: StringOperationFilterInput
  parent: ProductCategoryFilterInput
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductCategoryInput {
  parentId: String
  code: String
  name: [LocaleInput!]!
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductCategoryMutation {
  add(model: [ProductCategoryInput]): [ProductCategory]
  update(model: [ProductCategoryInput]): [ProductCategory]
  addOrUpdate(model: [ProductCategoryInput]): [ProductCategory]
  delete(model: [ProductCategoryInput]): [ProductCategory]
}

type ProductCategoryQuery {
  all(skip: Int, take: Int, where: ProductCategoryFilterInput, order: [ProductCategorySortInput!]): ProductCategoryCollectionSegment
  userInfo(model: ProductCategoryInput): UserInfo
  getByKeys(id: String): [ProductCategory]
}

input ProductCategorySortInput {
  parentId: SortEnumType
  parent: ProductCategorySortInput
  code: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductCollectionSegment {
  items: [Product]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type ProductConsumptionMethod {
  productId: String
  consumptionMethodId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  consumptionMethod: ConsumptionMethod!
}

type ProductConsumptionMethodCollectionSegment {
  items: [ProductConsumptionMethod]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductConsumptionMethodFilterInput {
  and: [ProductConsumptionMethodFilterInput!]
  or: [ProductConsumptionMethodFilterInput!]
  productId: StringOperationFilterInput
  consumptionMethodId: StringOperationFilterInput
  consumptionMethod: ConsumptionMethodFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductConsumptionMethodInput {
  productId: String
  consumptionMethodId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductConsumptionMethodMutation {
  add(model: [ProductConsumptionMethodInput]): [ProductConsumptionMethod]
  update(model: [ProductConsumptionMethodInput]): [ProductConsumptionMethod]
  addOrUpdate(model: [ProductConsumptionMethodInput]): [ProductConsumptionMethod]
  delete(model: [ProductConsumptionMethodInput]): [ProductConsumptionMethod]
}

type ProductConsumptionMethodQuery {
  all(skip: Int, take: Int, where: ProductConsumptionMethodFilterInput, order: [ProductConsumptionMethodSortInput!]): ProductConsumptionMethodCollectionSegment
  userInfo(model: ProductConsumptionMethodInput): UserInfo
  getByKeys(productId: String, consumptionMethodId: String): [ProductConsumptionMethod]
}

input ProductConsumptionMethodSortInput {
  productId: SortEnumType
  consumptionMethodId: SortEnumType
  consumptionMethod: ConsumptionMethodSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input ProductFilterInput {
  and: [ProductFilterInput!]
  or: [ProductFilterInput!]
  article: StringOperationFilterInput
  nameShort: ListFilterInputTypeOfLocaleFilterInput
  nameFull: ListFilterInputTypeOfLocaleFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  isActive: BooleanOperationFilterInput
  shelfLife: ComparableNullableOfInt32OperationFilterInput
  formFactoryId: StringOperationFilterInput
  formFactory: FormFactoryFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  productBrandId: StringOperationFilterInput
  productBrand: ProductBrandFilterInput
  codeUKTZ: StringOperationFilterInput
  divided: ComparableDecimalOperationFilterInput
  productCategoryId: StringOperationFilterInput
  productCategory: ProductCategoryFilterInput
  productGroupId: StringOperationFilterInput
  productGroup: ProductGroupFilterInput
  registerNumber: StringOperationFilterInput
  registerDate: ComparableNullableOfDateTimeOperationFilterInput
  registerDateEnd: ComparableNullableOfDateTimeOperationFilterInput
  width: ComparableNullableOfDecimalOperationFilterInput
  height: ComparableNullableOfDecimalOperationFilterInput
  depth: ComparableNullableOfDecimalOperationFilterInput
  weight: ComparableNullableOfDecimalOperationFilterInput
  maxQtyPerReceipt: ComparableNullableOfInt32OperationFilterInput
  minQtyPerReceipt: ComparableNullableOfInt32OperationFilterInput
  doseUnitId: StringOperationFilterInput
  doseUnit: UnitFilterInput
  doseValue: ComparableNullableOfDecimalOperationFilterInput
  packageQty: ComparableInt32OperationFilterInput
  codeMorion: StringOperationFilterInput
  reimbursementMedicationId: StringOperationFilterInput
  reimbursementMedication: ReimbursementMedicationFilterInput
  needReceipt: BooleanOperationFilterInput
  imageLink: ListFilterInputTypeOfImageLinkFilterInput
  info: StringOperationFilterInput
  toc: BooleanOperationFilterInput
  segregatedStorageId: StringOperationFilterInput
  segregatedStorage: SegregatedStorageFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

type ProductGroup {
  parentId: String
  code: String
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: ProductGroup!
}

type ProductGroupCollectionSegment {
  items: [ProductGroup]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductGroupFilterInput {
  and: [ProductGroupFilterInput!]
  or: [ProductGroupFilterInput!]
  parentId: StringOperationFilterInput
  parent: ProductGroupFilterInput
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductGroupInput {
  parentId: String
  code: String
  name: [LocaleInput!]!
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductGroupMutation {
  add(model: [ProductGroupInput]): [ProductGroup]
  update(model: [ProductGroupInput]): [ProductGroup]
  addOrUpdate(model: [ProductGroupInput]): [ProductGroup]
  delete(model: [ProductGroupInput]): [ProductGroup]
}

type ProductGroupQuery {
  all(skip: Int, take: Int, where: ProductGroupFilterInput, order: [ProductGroupSortInput!]): ProductGroupCollectionSegment
  userInfo(model: ProductGroupInput): UserInfo
  getByKeys(id: String): [ProductGroup]
}

input ProductGroupSortInput {
  parentId: SortEnumType
  parent: ProductGroupSortInput
  code: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input ProductInput {
  article: String
  nameShort: [LocaleInput!]
  nameFull: [LocaleInput!]
  unitId: String
  isActive: Boolean
  shelfLife: Int
  formFactoryId: String
  firmId: String
  taxRateId: String
  productBrandId: String
  codeUKTZ: String
  divided: Decimal
  productCategoryId: String
  productGroupId: String
  registerNumber: String
  registerDate: DateTime
  registerDateEnd: DateTime
  width: Decimal
  height: Decimal
  depth: Decimal
  weight: Decimal
  maxQtyPerReceipt: Int
  minQtyPerReceipt: Int
  doseUnitId: String
  doseValue: Decimal
  packageQty: Int
  codeMorion: String
  reimbursementMedicationId: String
  needReceipt: Boolean
  imageLink: [ImageLinkInput!]
  info: String
  toc: Boolean
  segregatedStorageId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductKind {
  code: String
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductKindCollectionSegment {
  items: [ProductKind]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductKindFilterInput {
  and: [ProductKindFilterInput!]
  or: [ProductKindFilterInput!]
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductKindInput {
  code: String
  name: [LocaleInput!]!
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductKindMutation {
  add(model: [ProductKindInput]): [ProductKind]
  update(model: [ProductKindInput]): [ProductKind]
  addOrUpdate(model: [ProductKindInput]): [ProductKind]
  delete(model: [ProductKindInput]): [ProductKind]
}

type ProductKindQuery {
  all(skip: Int, take: Int, where: ProductKindFilterInput, order: [ProductKindSortInput!]): ProductKindCollectionSegment
  userInfo(model: ProductKindInput): UserInfo
  getByKeys(id: String): [ProductKind]
}

input ProductKindSortInput {
  code: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductManager {
  id: Int
  productId: String
  employeeId: String
  employeeShort: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  employee: Employee!
}

type ProductManagerCollectionSegment {
  items: [ProductManager]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductManagerFilterInput {
  and: [ProductManagerFilterInput!]
  or: [ProductManagerFilterInput!]
  id: ComparableInt32OperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  employeeId: StringOperationFilterInput
  employee: EmployeeFilterInput
  employeeShort: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductManagerInput {
  id: Int
  productId: String
  employeeId: String
  employeeShort: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductManagerMutation {
  add(model: [ProductManagerInput]): [ProductManager]
  update(model: [ProductManagerInput]): [ProductManager]
  addOrUpdate(model: [ProductManagerInput]): [ProductManager]
  delete(model: [ProductManagerInput]): [ProductManager]
}

type ProductManagerQuery {
  all(skip: Int, take: Int, where: ProductManagerFilterInput, order: [ProductManagerSortInput!]): ProductManagerCollectionSegment
  userInfo(model: ProductManagerInput): UserInfo
}

input ProductManagerSortInput {
  id: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  employeeId: SortEnumType
  employee: EmployeeSortInput
  employeeShort: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductMutation {
  add(model: [ProductInput]): [Product]
  update(model: [ProductInput]): [Product]
  addOrUpdate(model: [ProductInput]): [Product]
  delete(model: [ProductInput]): [Product]
}

type ProductQueries {
  staticGroupProducts(skip: Int, take: Int, catalogGroupId: String, where: ProductFilterInput, order: [ProductSortInput!]): ProductCollectionSegment
}

type ProductQuery {
  all(skip: Int, take: Int, where: ProductFilterInput, order: [ProductSortInput!]): ProductCollectionSegment
  userInfo(model: ProductInput): UserInfo
  getByKeys(id: String): [Product]
}

input ProductSortInput {
  article: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  isActive: SortEnumType
  shelfLife: SortEnumType
  formFactoryId: SortEnumType
  formFactory: FormFactorySortInput
  firmId: SortEnumType
  firm: FirmSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  productBrandId: SortEnumType
  productBrand: ProductBrandSortInput
  codeUKTZ: SortEnumType
  divided: SortEnumType
  productCategoryId: SortEnumType
  productCategory: ProductCategorySortInput
  productGroupId: SortEnumType
  productGroup: ProductGroupSortInput
  registerNumber: SortEnumType
  registerDate: SortEnumType
  registerDateEnd: SortEnumType
  width: SortEnumType
  height: SortEnumType
  depth: SortEnumType
  weight: SortEnumType
  maxQtyPerReceipt: SortEnumType
  minQtyPerReceipt: SortEnumType
  doseUnitId: SortEnumType
  doseUnit: UnitSortInput
  doseValue: SortEnumType
  packageQty: SortEnumType
  codeMorion: SortEnumType
  reimbursementMedicationId: SortEnumType
  reimbursementMedication: ReimbursementMedicationSortInput
  needReceipt: SortEnumType
  info: SortEnumType
  toc: SortEnumType
  segregatedStorageId: SortEnumType
  segregatedStorage: SegregatedStorageSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductStoreCondition {
  productId: String
  storeConditionId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  storeCondition: StoreCondition!
}

type ProductStoreConditionCollectionSegment {
  items: [ProductStoreCondition]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductStoreConditionFilterInput {
  and: [ProductStoreConditionFilterInput!]
  or: [ProductStoreConditionFilterInput!]
  productId: StringOperationFilterInput
  storeConditionId: StringOperationFilterInput
  storeCondition: StoreConditionFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductStoreConditionInput {
  productId: String
  storeConditionId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductStoreConditionMutation {
  add(model: [ProductStoreConditionInput]): [ProductStoreCondition]
  update(model: [ProductStoreConditionInput]): [ProductStoreCondition]
  addOrUpdate(model: [ProductStoreConditionInput]): [ProductStoreCondition]
  delete(model: [ProductStoreConditionInput]): [ProductStoreCondition]
}

type ProductStoreConditionQuery {
  all(skip: Int, take: Int, where: ProductStoreConditionFilterInput, order: [ProductStoreConditionSortInput!]): ProductStoreConditionCollectionSegment
  userInfo(model: ProductStoreConditionInput): UserInfo
  getByKeys(productId: String, storeConditionId: String): [ProductStoreCondition]
}

input ProductStoreConditionSortInput {
  productId: SortEnumType
  storeConditionId: SortEnumType
  storeCondition: StoreConditionSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductSubstance {
  productId: String
  substanceId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  substance: Substance
}

type ProductSubstanceCollectionSegment {
  items: [ProductSubstance]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductSubstanceFilterInput {
  and: [ProductSubstanceFilterInput!]
  or: [ProductSubstanceFilterInput!]
  productId: StringOperationFilterInput
  product: ProductFilterInput
  substanceId: StringOperationFilterInput
  substance: SubstanceFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductSubstanceInput {
  productId: String
  substanceId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductSubstanceMutation {
  add(model: [ProductSubstanceInput]): [ProductSubstance]
  update(model: [ProductSubstanceInput]): [ProductSubstance]
  addOrUpdate(model: [ProductSubstanceInput]): [ProductSubstance]
  delete(model: [ProductSubstanceInput]): [ProductSubstance]
}

type ProductSubstanceQuery {
  all(skip: Int, take: Int, where: ProductSubstanceFilterInput, order: [ProductSubstanceSortInput!]): ProductSubstanceCollectionSegment
  userInfo(model: ProductSubstanceInput): UserInfo
  getByKeys(productId: String, substanceId: String): [ProductSubstance]
}

input ProductSubstanceSortInput {
  productId: SortEnumType
  product: ProductSortInput
  substanceId: SortEnumType
  substance: SubstanceSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductSymptom {
  productId: String
  symptomId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  symptom: Symptom
}

type ProductSymptomCollectionSegment {
  items: [ProductSymptom]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductSymptomFilterInput {
  and: [ProductSymptomFilterInput!]
  or: [ProductSymptomFilterInput!]
  productId: StringOperationFilterInput
  product: ProductFilterInput
  symptomId: StringOperationFilterInput
  symptom: SymptomFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductSymptomInput {
  productId: String
  symptomId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductSymptomMutation {
  add(model: [ProductSymptomInput]): [ProductSymptom]
  update(model: [ProductSymptomInput]): [ProductSymptom]
  addOrUpdate(model: [ProductSymptomInput]): [ProductSymptom]
  delete(model: [ProductSymptomInput]): [ProductSymptom]
}

type ProductSymptomQuery {
  all(skip: Int, take: Int, where: ProductSymptomFilterInput, order: [ProductSymptomSortInput!]): ProductSymptomCollectionSegment
  userInfo(model: ProductSymptomInput): UserInfo
  getByKeys(productId: String, symptomId: String): [ProductSymptom]
}

input ProductSymptomSortInput {
  productId: SortEnumType
  product: ProductSortInput
  symptomId: SortEnumType
  symptom: SymptomSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ProductTransform {
  productId: String
  unitId: String
  value: Decimal
  width: Decimal
  height: Decimal
  depth: Decimal
  weight: Decimal
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  unit: Unit!
}

type ProductTransformCollectionSegment {
  items: [ProductTransform]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ProductTransformFilterInput {
  and: [ProductTransformFilterInput!]
  or: [ProductTransformFilterInput!]
  productId: StringOperationFilterInput
  product: ProductFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  value: ComparableDecimalOperationFilterInput
  width: ComparableNullableOfDecimalOperationFilterInput
  height: ComparableNullableOfDecimalOperationFilterInput
  depth: ComparableNullableOfDecimalOperationFilterInput
  weight: ComparableNullableOfDecimalOperationFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ProductTransformInput {
  productId: String
  unitId: String
  value: Decimal
  width: Decimal
  height: Decimal
  depth: Decimal
  weight: Decimal
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ProductTransformMutation {
  add(model: [ProductTransformInput]): [ProductTransform]
  update(model: [ProductTransformInput]): [ProductTransform]
  addOrUpdate(model: [ProductTransformInput]): [ProductTransform]
  delete(model: [ProductTransformInput]): [ProductTransform]
}

type ProductTransformQuery {
  all(skip: Int, take: Int, where: ProductTransformFilterInput, order: [ProductTransformSortInput!]): ProductTransformCollectionSegment
  userInfo(model: ProductTransformInput): UserInfo
  getByKeys(productId: String, unitId: String): [ProductTransform]
}

input ProductTransformSortInput {
  productId: SortEnumType
  product: ProductSortInput
  unitId: SortEnumType
  unit: UnitSortInput
  value: SortEnumType
  width: SortEnumType
  height: SortEnumType
  depth: SortEnumType
  weight: SortEnumType
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Quantity {
  documentId: String
  globalCode: String
  direct: Int
  number: String
  date: DateTime
  firmId: String
  firmStructureId: String
  firmStoreId: String
  cashboxId: String
  contractorId: String
  contractorStructureId: String
  contractId: String
  contractGlobalCode: String
  orderId: String
  orderGlobalCode: String
  documentProductId: String
  productId: String
  productBarId: String
  unitId: String
  storeFrameId: String
  storeFrameCode: String
  amount: Decimal
  price: Decimal
  sumDoc: Decimal
  currencyId: String
  sumBase: Decimal
  taxRateId: String
  sumTax: Decimal
  priceCost: Decimal
  sumCost: Decimal
  partyBaseId: String
  quantityPartyAmount: Decimal
  partyFirmQuantityId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm
  firmJson: FirmBase
  firmStructure: Structure
  firmStructureJson: StructureBase
  firmStore: Store
  firmStoreJson: StoreBase
  cashbox: Cashbox
  cashboxJson: CashboxBase
  contractor: Firm
  contractorJson: FirmBase
  contractorStructure: Structure
  contractorStructureJson: StructureBase
  contract: Contract
  contractJson: ContractBase
  orderJson: OrderBase
  product: Product
  productJson: ProductBase
  productBar: ProductBar
  productBarJson: ProductBarBase
  unit: Unit
  unitJson: UnitBase
  storeFrame: StoreFrame
  currency: Currency
  taxRate: TaxRate
  taxRateJson: TaxRateBase
}

type QuantityCollectionSegment {
  items: [Quantity]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input QuantityFilterInput {
  and: [QuantityFilterInput!]
  or: [QuantityFilterInput!]
  documentId: StringOperationFilterInput
  globalCode: StringOperationFilterInput
  direct: ComparableInt32OperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  firmJson: FirmBaseFilterInput
  firmStructureId: StringOperationFilterInput
  firmStructure: StructureFilterInput
  firmStructureJson: StructureBaseFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreBaseFilterInput
  cashboxId: StringOperationFilterInput
  cashbox: CashboxFilterInput
  cashboxJson: CashboxBaseFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  contractorJson: FirmBaseFilterInput
  contractorStructureId: StringOperationFilterInput
  contractorStructure: StructureFilterInput
  contractorStructureJson: StructureBaseFilterInput
  contractId: StringOperationFilterInput
  contract: ContractFilterInput
  contractGlobalCode: StringOperationFilterInput
  contractJson: ContractBaseFilterInput
  orderId: StringOperationFilterInput
  orderGlobalCode: StringOperationFilterInput
  orderJson: OrderBaseFilterInput
  documentProductId: StringOperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductBaseFilterInput
  productBarId: StringOperationFilterInput
  productBar: ProductBarFilterInput
  productBarJson: ProductBarBaseFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitBaseFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  storeFrameCode: StringOperationFilterInput
  amount: ComparableDecimalOperationFilterInput
  price: ComparableDecimalOperationFilterInput
  sumDoc: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  sumBase: ComparableDecimalOperationFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateBaseFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  priceCost: ComparableDecimalOperationFilterInput
  sumCost: ComparableDecimalOperationFilterInput
  partyBaseId: StringOperationFilterInput
  quantityPartyAmount: ComparableNullableOfDecimalOperationFilterInput
  partyFirmQuantityId: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input QuantityInput {
  documentId: String
  globalCode: String
  direct: Int
  number: String
  date: DateTime
  firmId: String
  firmJson: FirmBaseInput
  firmStructureId: String
  firmStructureJson: StructureBaseInput
  firmStoreId: String
  firmStoreJson: StoreBaseInput
  cashboxId: String
  cashboxJson: CashboxBaseInput
  contractorId: String
  contractorJson: FirmBaseInput
  contractorStructureId: String
  contractorStructureJson: StructureBaseInput
  contractId: String
  contractGlobalCode: String
  contractJson: ContractBaseInput
  orderId: String
  orderGlobalCode: String
  orderJson: OrderBaseInput
  documentProductId: String
  productId: String
  productJson: ProductBaseInput
  productBarId: String
  productBarJson: ProductBarBaseInput
  unitId: String
  unitJson: UnitBaseInput
  storeFrameId: String
  storeFrameCode: String
  amount: Decimal
  price: Decimal
  sumDoc: Decimal
  currencyId: String
  sumBase: Decimal
  taxRateId: String
  taxRateJson: TaxRateBaseInput
  sumTax: Decimal
  priceCost: Decimal
  sumCost: Decimal
  partyBaseId: String
  quantityPartyAmount: Decimal
  partyFirmQuantityId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type QuantityMutation {
  add(model: [QuantityInput]): [Quantity]
  update(model: [QuantityInput]): [Quantity]
  addOrUpdate(model: [QuantityInput]): [Quantity]
  delete(model: [QuantityInput]): [Quantity]
}

type QuantityParty {
  quantityId: String
  documentId: String
  globalCode: String
  documentProductId: String
  amount: Decimal
  sumCost: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  quantity: Quantity
}

type QuantityPartyCollectionSegment {
  items: [QuantityParty]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input QuantityPartyFilterInput {
  and: [QuantityPartyFilterInput!]
  or: [QuantityPartyFilterInput!]
  quantityId: StringOperationFilterInput
  quantity: QuantityFilterInput
  documentId: StringOperationFilterInput
  globalCode: StringOperationFilterInput
  documentProductId: StringOperationFilterInput
  amount: ComparableDecimalOperationFilterInput
  sumCost: ComparableDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input QuantityPartyInput {
  quantityId: String
  documentId: String
  globalCode: String
  documentProductId: String
  amount: Decimal
  sumCost: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type QuantityPartyMutation {
  add(model: [QuantityPartyInput]): [QuantityParty]
  update(model: [QuantityPartyInput]): [QuantityParty]
  addOrUpdate(model: [QuantityPartyInput]): [QuantityParty]
  delete(model: [QuantityPartyInput]): [QuantityParty]
}

type QuantityPartyQuery {
  all(skip: Int, take: Int, where: QuantityPartyFilterInput, order: [QuantityPartySortInput!]): QuantityPartyCollectionSegment
  userInfo(model: QuantityPartyInput): UserInfo
  getByKeys(id: String): [QuantityParty]
}

input QuantityPartySortInput {
  quantityId: SortEnumType
  quantity: QuantitySortInput
  documentId: SortEnumType
  globalCode: SortEnumType
  documentProductId: SortEnumType
  amount: SortEnumType
  sumCost: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type QuantityQuery {
  all(skip: Int, take: Int, where: QuantityFilterInput, order: [QuantitySortInput!]): QuantityCollectionSegment
  userInfo(model: QuantityInput): UserInfo
  getByKeys(id: String): [Quantity]
}

input QuantitySortInput {
  documentId: SortEnumType
  globalCode: SortEnumType
  direct: SortEnumType
  number: SortEnumType
  date: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  firmJson: FirmBaseSortInput
  firmStructureId: SortEnumType
  firmStructure: StructureSortInput
  firmStructureJson: StructureBaseSortInput
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreBaseSortInput
  cashboxId: SortEnumType
  cashbox: CashboxSortInput
  cashboxJson: CashboxBaseSortInput
  contractorId: SortEnumType
  contractor: FirmSortInput
  contractorJson: FirmBaseSortInput
  contractorStructureId: SortEnumType
  contractorStructure: StructureSortInput
  contractorStructureJson: StructureBaseSortInput
  contractId: SortEnumType
  contract: ContractSortInput
  contractGlobalCode: SortEnumType
  contractJson: ContractBaseSortInput
  orderId: SortEnumType
  orderGlobalCode: SortEnumType
  orderJson: OrderBaseSortInput
  documentProductId: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductBaseSortInput
  productBarId: SortEnumType
  productBar: ProductBarSortInput
  productBarJson: ProductBarBaseSortInput
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitBaseSortInput
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  storeFrameCode: SortEnumType
  amount: SortEnumType
  price: SortEnumType
  sumDoc: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  sumBase: SortEnumType
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateBaseSortInput
  sumTax: SortEnumType
  priceCost: SortEnumType
  sumCost: SortEnumType
  partyBaseId: SortEnumType
  quantityPartyAmount: SortEnumType
  partyFirmQuantityId: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Receipt {
  globalCode: String
  status: Int
  direct: Int
  numberReceipt: String
  dateOpen: DateTime
  dateClose: DateTime
  name: String
  firmId: String
  structureId: String
  cashboxId: String
  numberZReport: String
  orderId: String
  orderGlobalCode: String
  sum: Decimal
  currencyId: String
  sumTax: Decimal
  saleChannelId: String
  saleChannelJson: String
  returnDocumentId: String
  returnDocumentGlobalCode: String
  firmEmployeeId: String
  jsonString: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm!
  firmJson: FirmBase!
  structure: Structure!
  structureJson: StructureBase!
  cashbox: Cashbox
  cashboxJson: CashboxBase
  order: ExternalReceipt
  orderJson: OrderInternet
  currency: Currency
  saleChannel: SaleChannel
  returnDocument: Receipt
  returnDocumentJson: ReceiptBase
  firmEmployeeJson: FirmEmployeeBase
}

type ReceiptAdditionalInfo {
  receiptId: String
  code: String
  jsonData: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  receipt: Receipt!
}

type ReceiptAdditionalInfoCollectionSegment {
  items: [ReceiptAdditionalInfo]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReceiptAdditionalInfoFilterInput {
  and: [ReceiptAdditionalInfoFilterInput!]
  or: [ReceiptAdditionalInfoFilterInput!]
  receiptId: StringOperationFilterInput
  receipt: ReceiptFilterInput
  code: StringOperationFilterInput
  jsonData: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ReceiptAdditionalInfoInput {
  receiptId: String
  code: String
  jsonData: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReceiptAdditionalInfoMutation {
  add(model: [ReceiptAdditionalInfoInput]): [ReceiptAdditionalInfo]
  update(model: [ReceiptAdditionalInfoInput]): [ReceiptAdditionalInfo]
  addOrUpdate(model: [ReceiptAdditionalInfoInput]): [ReceiptAdditionalInfo]
  delete(model: [ReceiptAdditionalInfoInput]): [ReceiptAdditionalInfo]
}

type ReceiptAdditionalInfoQuery {
  all(skip: Int, take: Int, where: ReceiptAdditionalInfoFilterInput, order: [ReceiptAdditionalInfoSortInput!]): ReceiptAdditionalInfoCollectionSegment
  userInfo(model: ReceiptAdditionalInfoInput): UserInfo
  getByKeys(id: String): [ReceiptAdditionalInfo]
}

input ReceiptAdditionalInfoSortInput {
  receiptId: SortEnumType
  receipt: ReceiptSortInput
  code: SortEnumType
  jsonData: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ReceiptBase {
  id: String
  numberReceipt: String
  dateOpen: DateTime!
  name: String
  firmId: String
  structureId: String
  cashboxId: String
  numberZReport: String
}

input ReceiptBaseFilterInput {
  and: [ReceiptBaseFilterInput!]
  or: [ReceiptBaseFilterInput!]
  id: StringOperationFilterInput
  numberReceipt: StringOperationFilterInput
  dateOpen: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  firmId: StringOperationFilterInput
  structureId: StringOperationFilterInput
  cashboxId: StringOperationFilterInput
  numberZReport: StringOperationFilterInput
}

input ReceiptBaseInput {
  id: String
  numberReceipt: String
  dateOpen: DateTime!
  name: String
  firmId: String
  structureId: String
  cashboxId: String
  numberZReport: String
}

input ReceiptBaseSortInput {
  id: SortEnumType
  numberReceipt: SortEnumType
  dateOpen: SortEnumType
  name: SortEnumType
  firmId: SortEnumType
  structureId: SortEnumType
  cashboxId: SortEnumType
  numberZReport: SortEnumType
}

type ReceiptCollectionSegment {
  items: [Receipt]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReceiptFilterInput {
  and: [ReceiptFilterInput!]
  or: [ReceiptFilterInput!]
  globalCode: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  direct: ComparableInt32OperationFilterInput
  numberReceipt: StringOperationFilterInput
  dateOpen: ComparableDateTimeOperationFilterInput
  dateClose: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  firmJson: FirmBaseFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  structureJson: StructureBaseFilterInput
  cashboxId: StringOperationFilterInput
  cashbox: CashboxFilterInput
  cashboxJson: CashboxBaseFilterInput
  numberZReport: StringOperationFilterInput
  orderId: StringOperationFilterInput
  order: ExternalReceiptFilterInput
  orderGlobalCode: StringOperationFilterInput
  orderJson: OrderInternetFilterInput
  sum: ComparableDecimalOperationFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  saleChannelId: StringOperationFilterInput
  saleChannel: SaleChannelFilterInput
  saleChannelJson: StringOperationFilterInput
  returnDocumentId: StringOperationFilterInput
  returnDocument: ReceiptFilterInput
  returnDocumentGlobalCode: StringOperationFilterInput
  returnDocumentJson: ReceiptBaseFilterInput
  firmEmployeeId: StringOperationFilterInput
  firmEmployeeJson: FirmEmployeeBaseFilterInput
  jsonString: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ReceiptInput {
  globalCode: String
  status: Int
  direct: Int
  numberReceipt: String
  dateOpen: DateTime
  dateClose: DateTime
  name: String
  firmId: String
  firmJson: FirmBaseInput!
  structureId: String
  structureJson: StructureBaseInput!
  cashboxId: String
  cashboxJson: CashboxBaseInput
  numberZReport: String
  orderId: String
  orderGlobalCode: String
  orderJson: OrderInternetInput
  sum: Decimal
  currencyId: String
  sumTax: Decimal
  saleChannelId: String
  saleChannelJson: String
  returnDocumentId: String
  returnDocumentGlobalCode: String
  returnDocumentJson: ReceiptBaseInput
  firmEmployeeId: String
  firmEmployeeJson: FirmEmployeeBaseInput
  jsonString: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReceiptMutation {
  add(model: [ReceiptInput]): [Receipt]
  update(model: [ReceiptInput]): [Receipt]
  addOrUpdate(model: [ReceiptInput]): [Receipt]
  delete(model: [ReceiptInput]): [Receipt]
}

type ReceiptPayment {
  code: String
  codeType: String
  paymentName: String
  cashbackExist: Boolean
  useTerminal: Boolean
  receiptId: String
  paymentPosition: Int
  paymentIndex: Int
  type: Int
  sum: Decimal
  preSum: Decimal
  terminalDateTime: String
  terminalRRN: String
  terminalInvoiceNumber: String
  terminalId: String
  terminalAccount: String
  terminalName: String
  terminalIssuerName: String
  terminalPan: String
  terminalAuthCode: String
  terminalReturnRRN: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  receipt: Receipt!
}

type ReceiptPaymentCollectionSegment {
  items: [ReceiptPayment]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReceiptPaymentFilterInput {
  and: [ReceiptPaymentFilterInput!]
  or: [ReceiptPaymentFilterInput!]
  code: StringOperationFilterInput
  codeType: StringOperationFilterInput
  paymentName: StringOperationFilterInput
  cashbackExist: BooleanOperationFilterInput
  useTerminal: BooleanOperationFilterInput
  receiptId: StringOperationFilterInput
  receipt: ReceiptFilterInput
  paymentPosition: ComparableInt32OperationFilterInput
  paymentIndex: ComparableInt32OperationFilterInput
  type: ComparableInt32OperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  preSum: ComparableDecimalOperationFilterInput
  terminalDateTime: StringOperationFilterInput
  terminalRRN: StringOperationFilterInput
  terminalInvoiceNumber: StringOperationFilterInput
  terminalId: StringOperationFilterInput
  terminalAccount: StringOperationFilterInput
  terminalName: StringOperationFilterInput
  terminalIssuerName: StringOperationFilterInput
  terminalPan: StringOperationFilterInput
  terminalAuthCode: StringOperationFilterInput
  terminalReturnRRN: StringOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ReceiptPaymentInput {
  code: String
  codeType: String
  paymentName: String
  cashbackExist: Boolean
  useTerminal: Boolean
  receiptId: String
  paymentPosition: Int
  paymentIndex: Int
  type: Int
  sum: Decimal
  preSum: Decimal
  terminalDateTime: String
  terminalRRN: String
  terminalInvoiceNumber: String
  terminalId: String
  terminalAccount: String
  terminalName: String
  terminalIssuerName: String
  terminalPan: String
  terminalAuthCode: String
  terminalReturnRRN: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReceiptPaymentMutation {
  add(model: [ReceiptPaymentInput]): [ReceiptPayment]
  update(model: [ReceiptPaymentInput]): [ReceiptPayment]
  addOrUpdate(model: [ReceiptPaymentInput]): [ReceiptPayment]
  delete(model: [ReceiptPaymentInput]): [ReceiptPayment]
}

type ReceiptPaymentQuery {
  all(skip: Int, take: Int, where: ReceiptPaymentFilterInput, order: [ReceiptPaymentSortInput!]): ReceiptPaymentCollectionSegment
  userInfo(model: ReceiptPaymentInput): UserInfo
  getByKeys(id: String): [ReceiptPayment]
}

input ReceiptPaymentSortInput {
  code: SortEnumType
  codeType: SortEnumType
  paymentName: SortEnumType
  cashbackExist: SortEnumType
  useTerminal: SortEnumType
  receiptId: SortEnumType
  receipt: ReceiptSortInput
  paymentPosition: SortEnumType
  paymentIndex: SortEnumType
  type: SortEnumType
  sum: SortEnumType
  preSum: SortEnumType
  terminalDateTime: SortEnumType
  terminalRRN: SortEnumType
  terminalInvoiceNumber: SortEnumType
  terminalId: SortEnumType
  terminalAccount: SortEnumType
  terminalName: SortEnumType
  terminalIssuerName: SortEnumType
  terminalPan: SortEnumType
  terminalAuthCode: SortEnumType
  terminalReturnRRN: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ReceiptProduct {
  receiptId: String
  productPosition: Int
  dateAdd: DateTime
  productId: String
  productBarId: String
  taxRateId: String
  amount: Decimal
  unitId: String
  firmProducerId: String
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  sumDiscount: Decimal
  partyFirmQuantityId: String
  storeId: String
  storeFrameId: String
  storeFrameCode: String
  returnDocumentProductId: String
  info: String
  _raw_json_discountJson: String
  discountJson: [AlphaDiscount]
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  receipt: Receipt!
  product: Product!
  productJson: ProductBase
  productBar: ProductBar
  productBarJson: ProductBarBase
  taxRate: TaxRate!
  taxRateJson: TaxRateBase
  unit: Unit
  unitJson: UnitBase
  firmProducer: Firm
  firmProducerJson: FirmBase
  store: Store!
  storeJson: StoreBase
  storeFrame: StoreFrame
  returnDocumentProduct: ReceiptProduct
}

type ReceiptProductCollectionSegment {
  items: [ReceiptProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReceiptProductFilterInput {
  and: [ReceiptProductFilterInput!]
  or: [ReceiptProductFilterInput!]
  receiptId: StringOperationFilterInput
  receipt: ReceiptFilterInput
  productPosition: ComparableInt32OperationFilterInput
  dateAdd: ComparableDateTimeOperationFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductBaseFilterInput
  productBarId: StringOperationFilterInput
  productBar: ProductBarFilterInput
  productBarJson: ProductBarBaseFilterInput
  taxRateId: StringOperationFilterInput
  taxRate: TaxRateFilterInput
  taxRateJson: TaxRateBaseFilterInput
  amount: ComparableDecimalOperationFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitBaseFilterInput
  firmProducerId: StringOperationFilterInput
  firmProducer: FirmFilterInput
  firmProducerJson: FirmBaseFilterInput
  price: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableDecimalOperationFilterInput
  sumDiscount: ComparableDecimalOperationFilterInput
  partyFirmQuantityId: StringOperationFilterInput
  storeId: StringOperationFilterInput
  store: StoreFilterInput
  storeJson: StoreBaseFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  storeFrameCode: StringOperationFilterInput
  returnDocumentProductId: StringOperationFilterInput
  returnDocumentProduct: ReceiptProductFilterInput
  info: StringOperationFilterInput
  discountJson: ListFilterInputTypeOfAlphaDiscountFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ReceiptProductInput {
  receiptId: String
  productPosition: Int
  dateAdd: DateTime
  productId: String
  productJson: ProductBaseInput
  productBarId: String
  productBarJson: ProductBarBaseInput
  taxRateId: String
  taxRateJson: TaxRateBaseInput
  amount: Decimal
  unitId: String
  unitJson: UnitBaseInput
  firmProducerId: String
  firmProducerJson: FirmBaseInput
  price: Decimal
  sum: Decimal
  sumTax: Decimal
  sumDiscount: Decimal
  partyFirmQuantityId: String
  storeId: String
  storeJson: StoreBaseInput
  storeFrameId: String
  storeFrameCode: String
  returnDocumentProductId: String
  info: String
  discountJson: [AlphaDiscountInput!]
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReceiptProductMutation {
  add(model: [ReceiptProductInput]): [ReceiptProduct]
  update(model: [ReceiptProductInput]): [ReceiptProduct]
  addOrUpdate(model: [ReceiptProductInput]): [ReceiptProduct]
  delete(model: [ReceiptProductInput]): [ReceiptProduct]
}

type ReceiptProductQuery {
  all(skip: Int, take: Int, where: ReceiptProductFilterInput, order: [ReceiptProductSortInput!]): ReceiptProductCollectionSegment
  userInfo(model: ReceiptProductInput): UserInfo
  getByKeys(id: String): [ReceiptProduct]
}

input ReceiptProductSortInput {
  receiptId: SortEnumType
  receipt: ReceiptSortInput
  productPosition: SortEnumType
  dateAdd: SortEnumType
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductBaseSortInput
  productBarId: SortEnumType
  productBar: ProductBarSortInput
  productBarJson: ProductBarBaseSortInput
  taxRateId: SortEnumType
  taxRate: TaxRateSortInput
  taxRateJson: TaxRateBaseSortInput
  amount: SortEnumType
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitBaseSortInput
  firmProducerId: SortEnumType
  firmProducer: FirmSortInput
  firmProducerJson: FirmBaseSortInput
  price: SortEnumType
  sum: SortEnumType
  sumTax: SortEnumType
  sumDiscount: SortEnumType
  partyFirmQuantityId: SortEnumType
  storeId: SortEnumType
  store: StoreSortInput
  storeJson: StoreBaseSortInput
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  storeFrameCode: SortEnumType
  returnDocumentProductId: SortEnumType
  returnDocumentProduct: ReceiptProductSortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ReceiptQuery {
  all(skip: Int, take: Int, where: ReceiptFilterInput, order: [ReceiptSortInput!]): ReceiptCollectionSegment
  userInfo(model: ReceiptInput): UserInfo
  getByKeys(id: String): [Receipt]
}

input ReceiptSortInput {
  globalCode: SortEnumType
  status: SortEnumType
  direct: SortEnumType
  numberReceipt: SortEnumType
  dateOpen: SortEnumType
  dateClose: SortEnumType
  name: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  firmJson: FirmBaseSortInput
  structureId: SortEnumType
  structure: StructureSortInput
  structureJson: StructureBaseSortInput
  cashboxId: SortEnumType
  cashbox: CashboxSortInput
  cashboxJson: CashboxBaseSortInput
  numberZReport: SortEnumType
  orderId: SortEnumType
  order: ExternalReceiptSortInput
  orderGlobalCode: SortEnumType
  orderJson: OrderInternetSortInput
  sum: SortEnumType
  currencyId: SortEnumType
  currency: CurrencySortInput
  sumTax: SortEnumType
  saleChannelId: SortEnumType
  saleChannel: SaleChannelSortInput
  saleChannelJson: SortEnumType
  returnDocumentId: SortEnumType
  returnDocument: ReceiptSortInput
  returnDocumentGlobalCode: SortEnumType
  returnDocumentJson: ReceiptBaseSortInput
  firmEmployeeId: SortEnumType
  firmEmployeeJson: FirmEmployeeBaseSortInput
  jsonString: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type RefreshToken {
  id: String
  token: String
  username: String
  employeeCode: String
  userId: String
  expireDate: DateTime
  ipAddress: String
}

type RefreshTokenCollectionSegment {
  items: [RefreshToken]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input RefreshTokenFilterInput {
  and: [RefreshTokenFilterInput!]
  or: [RefreshTokenFilterInput!]
  id: StringOperationFilterInput
  token: StringOperationFilterInput
  username: StringOperationFilterInput
  employeeCode: StringOperationFilterInput
  userId: StringOperationFilterInput
  expireDate: ComparableDateTimeOperationFilterInput
  ipAddress: StringOperationFilterInput
}

input RefreshTokenInput {
  id: String
  token: String
  username: String
  employeeCode: String
  userId: String
  expireDate: DateTime
  ipAddress: String
}

type RefreshTokenMutation {
  add(model: [RefreshTokenInput]): [RefreshToken]
  update(model: [RefreshTokenInput]): [RefreshToken]
  addOrUpdate(model: [RefreshTokenInput]): [RefreshToken]
  delete(model: [RefreshTokenInput]): [RefreshToken]
}

type RefreshTokenQuery {
  all(skip: Int, take: Int, where: RefreshTokenFilterInput, order: [RefreshTokenSortInput!]): RefreshTokenCollectionSegment
  userInfo(model: RefreshTokenInput): UserInfo
  getByKeys(id: String): [RefreshToken]
}

input RefreshTokenSortInput {
  id: SortEnumType
  token: SortEnumType
  username: SortEnumType
  employeeCode: SortEnumType
  userId: SortEnumType
  expireDate: SortEnumType
  ipAddress: SortEnumType
}

type ReimbursementMedication {
  medicationId: String
  innmName: String
  innmNameOriginal: String
  form: String
  manufacturerName: String
  manufacturerCountry: String
  medicationName: String
  numeratorUnit: String
  numeratorValue: Decimal
  packageQty: Int
  atcCode: String
  drlzLicenceNumber: String
  registryValidTo: String
  wholesalePrice: Decimal
  fullReimbursementPrice: Decimal
  partialReimbursementPrice: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReimbursementMedicationCollectionSegment {
  items: [ReimbursementMedication]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReimbursementMedicationFilterInput {
  and: [ReimbursementMedicationFilterInput!]
  or: [ReimbursementMedicationFilterInput!]
  medicationId: StringOperationFilterInput
  innmName: StringOperationFilterInput
  innmNameOriginal: StringOperationFilterInput
  form: StringOperationFilterInput
  manufacturerName: StringOperationFilterInput
  manufacturerCountry: StringOperationFilterInput
  medicationName: StringOperationFilterInput
  numeratorUnit: StringOperationFilterInput
  numeratorValue: ComparableDecimalOperationFilterInput
  packageQty: ComparableInt32OperationFilterInput
  atcCode: StringOperationFilterInput
  drlzLicenceNumber: StringOperationFilterInput
  registryValidTo: StringOperationFilterInput
  wholesalePrice: ComparableNullableOfDecimalOperationFilterInput
  fullReimbursementPrice: ComparableNullableOfDecimalOperationFilterInput
  partialReimbursementPrice: ComparableNullableOfDecimalOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ReimbursementMedicationInput {
  medicationId: String
  innmName: String
  innmNameOriginal: String
  form: String
  manufacturerName: String
  manufacturerCountry: String
  medicationName: String
  numeratorUnit: String
  numeratorValue: Decimal
  packageQty: Int
  atcCode: String
  drlzLicenceNumber: String
  registryValidTo: String
  wholesalePrice: Decimal
  fullReimbursementPrice: Decimal
  partialReimbursementPrice: Decimal
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReimbursementMedicationMutation {
  add(model: [ReimbursementMedicationInput]): [ReimbursementMedication]
  update(model: [ReimbursementMedicationInput]): [ReimbursementMedication]
  addOrUpdate(model: [ReimbursementMedicationInput]): [ReimbursementMedication]
  delete(model: [ReimbursementMedicationInput]): [ReimbursementMedication]
}

type ReimbursementMedicationQuery {
  all(skip: Int, take: Int, where: ReimbursementMedicationFilterInput, order: [ReimbursementMedicationSortInput!]): ReimbursementMedicationCollectionSegment
  userInfo(model: ReimbursementMedicationInput): UserInfo
  getByKeys(id: String): [ReimbursementMedication]
}

input ReimbursementMedicationSortInput {
  medicationId: SortEnumType
  innmName: SortEnumType
  innmNameOriginal: SortEnumType
  form: SortEnumType
  manufacturerName: SortEnumType
  manufacturerCountry: SortEnumType
  medicationName: SortEnumType
  numeratorUnit: SortEnumType
  numeratorValue: SortEnumType
  packageQty: SortEnumType
  atcCode: SortEnumType
  drlzLicenceNumber: SortEnumType
  registryValidTo: SortEnumType
  wholesalePrice: SortEnumType
  fullReimbursementPrice: SortEnumType
  partialReimbursementPrice: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type RelatedCategory {
  catalogGroupId: String
  relatedCatalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  catalogGroup: LineDictionary!
  relatedCatalogGroup: LineDictionary!
}

type RelatedCategoryCollectionSegment {
  items: [RelatedCategory]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input RelatedCategoryFilterInput {
  and: [RelatedCategoryFilterInput!]
  or: [RelatedCategoryFilterInput!]
  catalogGroupId: StringOperationFilterInput
  catalogGroup: LineDictionaryFilterInput
  relatedCatalogGroupId: StringOperationFilterInput
  relatedCatalogGroup: LineDictionaryFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input RelatedCategoryInput {
  catalogGroupId: String
  relatedCatalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type RelatedCategoryMutation {
  add(model: [RelatedCategoryInput]): [RelatedCategory]
  update(model: [RelatedCategoryInput]): [RelatedCategory]
  addOrUpdate(model: [RelatedCategoryInput]): [RelatedCategory]
  delete(model: [RelatedCategoryInput]): [RelatedCategory]
}

type RelatedCategoryProduct {
  productId: String
  catalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  catalogGroup: LineDictionary!
}

type RelatedCategoryProductCollectionSegment {
  items: [RelatedCategoryProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input RelatedCategoryProductFilterInput {
  and: [RelatedCategoryProductFilterInput!]
  or: [RelatedCategoryProductFilterInput!]
  productId: StringOperationFilterInput
  product: ProductFilterInput
  catalogGroupId: StringOperationFilterInput
  catalogGroup: LineDictionaryFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input RelatedCategoryProductInput {
  productId: String
  catalogGroupId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type RelatedCategoryProductMutation {
  add(model: [RelatedCategoryProductInput]): [RelatedCategoryProduct]
  update(model: [RelatedCategoryProductInput]): [RelatedCategoryProduct]
  addOrUpdate(model: [RelatedCategoryProductInput]): [RelatedCategoryProduct]
  delete(model: [RelatedCategoryProductInput]): [RelatedCategoryProduct]
}

type RelatedCategoryProductQuery {
  all(skip: Int, take: Int, where: RelatedCategoryProductFilterInput, order: [RelatedCategoryProductSortInput!]): RelatedCategoryProductCollectionSegment
  userInfo(model: RelatedCategoryProductInput): UserInfo
  getByKeys(productId: String, catalogGroupId: String): [RelatedCategoryProduct]
}

input RelatedCategoryProductSortInput {
  productId: SortEnumType
  product: ProductSortInput
  catalogGroupId: SortEnumType
  catalogGroup: LineDictionarySortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type RelatedCategoryQuery {
  all(skip: Int, take: Int, where: RelatedCategoryFilterInput, order: [RelatedCategorySortInput!]): RelatedCategoryCollectionSegment
  userInfo(model: RelatedCategoryInput): UserInfo
  getByKeys(catalogGroupId: String, relatedCatalogGroupId: String): [RelatedCategory]
}

input RelatedCategorySortInput {
  catalogGroupId: SortEnumType
  catalogGroup: LineDictionarySortInput
  relatedCatalogGroupId: SortEnumType
  relatedCatalogGroup: LineDictionarySortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ReportFilterDescriptionModel {
  id: Int!
  label: String
}

type ReportFilterDescriptionModelCollectionSegment {
  items: [ReportFilterDescriptionModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReportFilterDescriptionModelFilterInput {
  and: [ReportFilterDescriptionModelFilterInput!]
  or: [ReportFilterDescriptionModelFilterInput!]
  id: ComparableInt32OperationFilterInput
  label: StringOperationFilterInput
}

input ReportFilterDescriptionModelSortInput {
  id: SortEnumType
  label: SortEnumType
}

type ReturnReason {
  _raw_json_name: String
  name: [Locale]
  isUse: Boolean
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReturnReasonCollectionSegment {
  items: [ReturnReason]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReturnReasonFilterInput {
  and: [ReturnReasonFilterInput!]
  or: [ReturnReasonFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  isUse: BooleanOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ReturnReasonInput {
  name: [LocaleInput!]!
  isUse: Boolean
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReturnReasonInvoice {
  invoiceId: String
  returnReasonId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  invoice: InvoiceIn!
  returnReason: ReturnReason!
}

type ReturnReasonInvoiceCollectionSegment {
  items: [ReturnReasonInvoice]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ReturnReasonInvoiceFilterInput {
  and: [ReturnReasonInvoiceFilterInput!]
  or: [ReturnReasonInvoiceFilterInput!]
  invoiceId: StringOperationFilterInput
  invoice: InvoiceInFilterInput
  returnReasonId: StringOperationFilterInput
  returnReason: ReturnReasonFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ReturnReasonInvoiceInput {
  invoiceId: String
  returnReasonId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ReturnReasonInvoiceMutation {
  add(model: [ReturnReasonInvoiceInput]): [ReturnReasonInvoice]
  update(model: [ReturnReasonInvoiceInput]): [ReturnReasonInvoice]
  addOrUpdate(model: [ReturnReasonInvoiceInput]): [ReturnReasonInvoice]
  delete(model: [ReturnReasonInvoiceInput]): [ReturnReasonInvoice]
}

type ReturnReasonInvoiceQuery {
  all(skip: Int, take: Int, where: ReturnReasonInvoiceFilterInput, order: [ReturnReasonInvoiceSortInput!]): ReturnReasonInvoiceCollectionSegment
  userInfo(model: ReturnReasonInvoiceInput): UserInfo
  getByKeys(invoiceId: String, returnReasonId: String): [ReturnReasonInvoice]
}

input ReturnReasonInvoiceSortInput {
  invoiceId: SortEnumType
  invoice: InvoiceInSortInput
  returnReasonId: SortEnumType
  returnReason: ReturnReasonSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ReturnReasonMutation {
  add(model: [ReturnReasonInput]): [ReturnReason]
  update(model: [ReturnReasonInput]): [ReturnReason]
  addOrUpdate(model: [ReturnReasonInput]): [ReturnReason]
  delete(model: [ReturnReasonInput]): [ReturnReason]
}

type ReturnReasonQuery {
  all(skip: Int, take: Int, where: ReturnReasonFilterInput, order: [ReturnReasonSortInput!]): ReturnReasonCollectionSegment
  userInfo(model: ReturnReasonInput): UserInfo
  getByKeys(id: String): [ReturnReason]
}

input ReturnReasonSortInput {
  isUse: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Role {
  _raw_json_name: String
  name: [Locale]
  description: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type RoleCollectionSegment {
  items: [Role]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input RoleFilterInput {
  and: [RoleFilterInput!]
  or: [RoleFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  description: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input RoleInput {
  name: [LocaleInput!]!
  description: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type RoleMutation {
  add(model: [RoleInput]): [Role]
  update(model: [RoleInput]): [Role]
  addOrUpdate(model: [RoleInput]): [Role]
  delete(model: [RoleInput]): [Role]
}

type RolePermition {
  roleId: String
  tableName: String
  description: String
  canCreate: Boolean
  canRead: Boolean
  canUpdate: Boolean
  canDelete: Boolean
  canMove: Boolean
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type RolePermitionCollectionSegment {
  items: [RolePermition]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input RolePermitionFilterInput {
  and: [RolePermitionFilterInput!]
  or: [RolePermitionFilterInput!]
  roleId: StringOperationFilterInput
  tableName: StringOperationFilterInput
  description: StringOperationFilterInput
  canCreate: BooleanOperationFilterInput
  canRead: BooleanOperationFilterInput
  canUpdate: BooleanOperationFilterInput
  canDelete: BooleanOperationFilterInput
  canMove: BooleanOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input RolePermitionInput {
  roleId: String
  tableName: String
  description: String
  canCreate: Boolean
  canRead: Boolean
  canUpdate: Boolean
  canDelete: Boolean
  canMove: Boolean
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type RolePermitionMutation {
  add(model: [RolePermitionInput]): [RolePermition]
  update(model: [RolePermitionInput]): [RolePermition]
  addOrUpdate(model: [RolePermitionInput]): [RolePermition]
  delete(model: [RolePermitionInput]): [RolePermition]
}

type RolePermitionQuery {
  all(skip: Int, take: Int, where: RolePermitionFilterInput, order: [RolePermitionSortInput!]): RolePermitionCollectionSegment
  userInfo(model: RolePermitionInput): UserInfo
  getByKeys(roleId: String, tableName: String): [RolePermition]
}

input RolePermitionSortInput {
  roleId: SortEnumType
  tableName: SortEnumType
  description: SortEnumType
  canCreate: SortEnumType
  canRead: SortEnumType
  canUpdate: SortEnumType
  canDelete: SortEnumType
  canMove: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type RoleQuery {
  all(skip: Int, take: Int, where: RoleFilterInput, order: [RoleSortInput!]): RoleCollectionSegment
  userInfo(model: RoleInput): UserInfo
  getByKeys(id: String): [Role]
}

input RoleSortInput {
  description: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

enum RoundRuleType {
  MATH
  CEIL
  FLOOR
}

input RoundRuleTypeOperationFilterInput {
  eq: RoundRuleType
  neq: RoundRuleType
  in: [RoundRuleType!]
  nin: [RoundRuleType!]
}

enum RuleGroupType {
  NONE
  GROUP
  SINGLE
}

input RuleGroupTypeOperationFilterInput {
  eq: RuleGroupType
  neq: RuleGroupType
  in: [RuleGroupType!]
  nin: [RuleGroupType!]
}

enum RuleType {
  FIX_RULE
  PERCENT_RULE
  PERCENT_FROM_BASE_RULE
  FIX_PRICE_TO_BASE_RULE
  FIX_PRICE
  MIN_PRICE
  MAX_PRICE
  PERCENT_MIN
  PERCENT_MAX
}

input RuleTypeOperationFilterInput {
  eq: RuleType
  neq: RuleType
  in: [RuleType!]
  nin: [RuleType!]
}

type SaleChannel {
  _raw_json_name: String
  name: [Locale]
  code: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SaleChannelCollectionSegment {
  items: [SaleChannel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SaleChannelFilterInput {
  and: [SaleChannelFilterInput!]
  or: [SaleChannelFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  code: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input SaleChannelInput {
  name: [LocaleInput!]!
  code: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SaleChannelMutation {
  add(model: [SaleChannelInput]): [SaleChannel]
  update(model: [SaleChannelInput]): [SaleChannel]
  addOrUpdate(model: [SaleChannelInput]): [SaleChannel]
  delete(model: [SaleChannelInput]): [SaleChannel]
}

type SaleChannelQuery {
  all(skip: Int, take: Int, where: SaleChannelFilterInput, order: [SaleChannelSortInput!]): SaleChannelCollectionSegment
  userInfo(model: SaleChannelInput): UserInfo
  getByKeys(id: String): [SaleChannel]
}

input SaleChannelSortInput {
  code: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type SalesPlan {
  status: Int
  number: String
  date: DateTime
  name: String
  firmStructureId: String
  sum: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  filterByStructureId(id: String!): Boolean!
  firmStructure: Structure!
}

type SalesPlanCollectionSegment {
  items: [SalesPlan]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type SalesPlanDay {
  salesPlanId: String
  dayNumber: Int
  coeff: Decimal
  sum: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  masterTableId: String!
  salesPlan: SalesPlan!
}

type SalesPlanDayCollectionSegment {
  items: [SalesPlanDay]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SalesPlanDayFilterInput {
  and: [SalesPlanDayFilterInput!]
  or: [SalesPlanDayFilterInput!]
  salesPlanId: StringOperationFilterInput
  salesPlan: SalesPlanFilterInput
  dayNumber: ComparableInt32OperationFilterInput
  coeff: ComparableDecimalOperationFilterInput
  sum: ComparableDecimalOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input SalesPlanDayInput {
  salesPlanId: String
  dayNumber: Int
  coeff: Decimal
  sum: Decimal
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SalesPlanDayMutation {
  add(model: [SalesPlanDayInput]): [SalesPlanDay]
  update(model: [SalesPlanDayInput]): [SalesPlanDay]
  addOrUpdate(model: [SalesPlanDayInput]): [SalesPlanDay]
  delete(model: [SalesPlanDayInput]): [SalesPlanDay]
}

type SalesPlanDayQuery {
  all(skip: Int, take: Int, where: SalesPlanDayFilterInput, order: [SalesPlanDaySortInput!]): SalesPlanDayCollectionSegment
  userInfo(model: SalesPlanDayInput): UserInfo
  getByKeys(salesPlanId: String): [SalesPlanDay]
}

input SalesPlanDaySortInput {
  salesPlanId: SortEnumType
  salesPlan: SalesPlanSortInput
  dayNumber: SortEnumType
  coeff: SortEnumType
  sum: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input SalesPlanFilterInput {
  and: [SalesPlanFilterInput!]
  or: [SalesPlanFilterInput!]
  status: ComparableInt32OperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  name: StringOperationFilterInput
  firmStructureId: StringOperationFilterInput
  firmStructure: StructureFilterInput
  sum: ComparableDecimalOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

enum SalesPlanImplementationFilters {
  STRUCTURE
  DAY
}

input SalesPlanImplementationFiltersOperationFilterInput {
  eq: SalesPlanImplementationFilters
  neq: SalesPlanImplementationFilters
  in: [SalesPlanImplementationFilters!]
  nin: [SalesPlanImplementationFilters!]
}

type SalesPlanImplementationNode {
  data: SalesPlanImplementationValues!
  children: [SalesPlanImplementationNode!]
}

type SalesPlanImplementationNodeCollectionSegment {
  items: [SalesPlanImplementationNode]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SalesPlanImplementationNodeFilterInput {
  and: [SalesPlanImplementationNodeFilterInput!]
  or: [SalesPlanImplementationNodeFilterInput!]
  data: SalesPlanImplementationValuesFilterInput
  children: ListFilterInputTypeOfSalesPlanImplementationNodeFilterInput
}

input SalesPlanImplementationNodeSortInput {
  data: SalesPlanImplementationValuesSortInput
}

type SalesPlanImplementationValues {
  nodeLevel: Int!
  value: String
  type: SalesPlanImplementationFilters!
  salesSum: Decimal!
  planSum: Decimal!
  implementationRate: Decimal!
}

input SalesPlanImplementationValuesFilterInput {
  and: [SalesPlanImplementationValuesFilterInput!]
  or: [SalesPlanImplementationValuesFilterInput!]
  nodeLevel: ComparableInt32OperationFilterInput
  value: StringOperationFilterInput
  type: SalesPlanImplementationFiltersOperationFilterInput
  salesSum: ComparableDecimalOperationFilterInput
  planSum: ComparableDecimalOperationFilterInput
  implementationRate: ComparableDecimalOperationFilterInput
}

input SalesPlanImplementationValuesSortInput {
  nodeLevel: SortEnumType
  value: SortEnumType
  type: SortEnumType
  salesSum: SortEnumType
  planSum: SortEnumType
  implementationRate: SortEnumType
}

input SalesPlanInput {
  status: Int
  number: String
  date: DateTime
  name: String
  firmStructureId: String
  sum: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SalesPlanMutation {
  add(model: [SalesPlanInput]): [SalesPlan]
  update(model: [SalesPlanInput]): [SalesPlan]
  addOrUpdate(model: [SalesPlanInput]): [SalesPlan]
  delete(model: [SalesPlanInput]): [SalesPlan]
}

type SalesPlanQuery {
  all(skip: Int, take: Int, where: SalesPlanFilterInput, order: [SalesPlanSortInput!]): SalesPlanCollectionSegment
  userInfo(model: SalesPlanInput): UserInfo
  getByKeys(id: String): [SalesPlan]
}

input SalesPlanSortInput {
  status: SortEnumType
  number: SortEnumType
  date: SortEnumType
  name: SortEnumType
  firmStructureId: SortEnumType
  firmStructure: StructureSortInput
  sum: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Scan {
  globalCode: String
  status: Int
  _raw_json_statusHistory: String
  statusHistory: [StatusHistory]
  number: String
  brigadeNumber: String
  storageAddresses: String
  date: DateTime
  firmStructureId: String
  firmStoreId: String
  firmEmployeeId: String
  inventoryId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firmStructure: Structure
  firmStructureJson: Structure
  firmStore: Store
  firmStoreJson: Store
  firmEmployee: FirmEmployee
  firmEmployeeJson: FirmEmployee
  inventory: Inventory
}

type ScanCollectionSegment {
  items: [Scan]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ScanFilterInput {
  and: [ScanFilterInput!]
  or: [ScanFilterInput!]
  globalCode: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  statusHistory: ListFilterInputTypeOfStatusHistoryFilterInput
  number: StringOperationFilterInput
  brigadeNumber: StringOperationFilterInput
  storageAddresses: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  firmStructureId: StringOperationFilterInput
  firmStructure: StructureFilterInput
  firmStructureJson: StructureFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreFilterInput
  firmEmployeeId: StringOperationFilterInput
  firmEmployee: FirmEmployeeFilterInput
  firmEmployeeJson: FirmEmployeeFilterInput
  inventoryId: StringOperationFilterInput
  inventory: InventoryFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ScanInput {
  globalCode: String
  status: Int
  statusHistory: [StatusHistoryInput!]
  number: String
  brigadeNumber: String
  storageAddresses: String
  date: DateTime
  firmStructureId: String
  firmStructureJson: StructureInput
  firmStoreId: String
  firmStoreJson: StoreInput
  firmEmployeeId: String
  firmEmployeeJson: FirmEmployeeInput
  inventoryId: String
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ScanMutation {
  add(model: [ScanInput]): [Scan]
  update(model: [ScanInput]): [Scan]
  addOrUpdate(model: [ScanInput]): [Scan]
  delete(model: [ScanInput]): [Scan]
}

type ScanProduct {
  scanId: String
  productId: String
  unitId: String
  restFact: Decimal
  restDateTime: DateTime
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  scan: Scan
  product: Product
  productJson: Product
  unit: Unit
  unitJson: Unit
}

type ScanProductCollectionSegment {
  items: [ScanProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ScanProductFilterInput {
  and: [ScanProductFilterInput!]
  or: [ScanProductFilterInput!]
  scanId: StringOperationFilterInput
  scan: ScanFilterInput
  productId: StringOperationFilterInput
  product: ProductFilterInput
  productJson: ProductFilterInput
  unitId: StringOperationFilterInput
  unit: UnitFilterInput
  unitJson: UnitFilterInput
  restFact: ComparableDecimalOperationFilterInput
  restDateTime: ComparableDateTimeOperationFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input ScanProductInput {
  scanId: String
  productId: String
  productJson: ProductInput
  unitId: String
  unitJson: UnitInput
  restFact: Decimal
  restDateTime: DateTime
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type ScanProductMutation {
  add(model: [ScanProductInput]): [ScanProduct]
  update(model: [ScanProductInput]): [ScanProduct]
  addOrUpdate(model: [ScanProductInput]): [ScanProduct]
  delete(model: [ScanProductInput]): [ScanProduct]
}

type ScanProductQueries {
  total(id: String): Int!
}

type ScanProductQuery {
  all(skip: Int, take: Int, where: ScanProductFilterInput, order: [ScanProductSortInput!]): ScanProductCollectionSegment
  userInfo(model: ScanProductInput): UserInfo
  getByKeys(scanId: String, productId: String): [ScanProduct]
}

input ScanProductSortInput {
  scanId: SortEnumType
  scan: ScanSortInput
  productId: SortEnumType
  product: ProductSortInput
  productJson: ProductSortInput
  unitId: SortEnumType
  unit: UnitSortInput
  unitJson: UnitSortInput
  restFact: SortEnumType
  restDateTime: SortEnumType
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ScanQuery {
  all(skip: Int, take: Int, where: ScanFilterInput, order: [ScanSortInput!]): ScanCollectionSegment
  userInfo(model: ScanInput): UserInfo
  getByKeys(id: String): [Scan]
}

input ScanSortInput {
  globalCode: SortEnumType
  status: SortEnumType
  number: SortEnumType
  brigadeNumber: SortEnumType
  storageAddresses: SortEnumType
  date: SortEnumType
  firmStructureId: SortEnumType
  firmStructure: StructureSortInput
  firmStructureJson: StructureSortInput
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreSortInput
  firmEmployeeId: SortEnumType
  firmEmployee: FirmEmployeeSortInput
  firmEmployeeJson: FirmEmployeeSortInput
  inventoryId: SortEnumType
  inventory: InventorySortInput
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type SegregatedStorage {
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SegregatedStorageCollectionSegment {
  items: [SegregatedStorage]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SegregatedStorageFilterInput {
  and: [SegregatedStorageFilterInput!]
  or: [SegregatedStorageFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input SegregatedStorageInput {
  name: [LocaleInput!]!
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SegregatedStorageMutation {
  add(model: [SegregatedStorageInput]): [SegregatedStorage]
  update(model: [SegregatedStorageInput]): [SegregatedStorage]
  addOrUpdate(model: [SegregatedStorageInput]): [SegregatedStorage]
  delete(model: [SegregatedStorageInput]): [SegregatedStorage]
}

type SegregatedStorageQuery {
  all(skip: Int, take: Int, where: SegregatedStorageFilterInput, order: [SegregatedStorageSortInput!]): SegregatedStorageCollectionSegment
  userInfo(model: SegregatedStorageInput): UserInfo
  getByKeys(id: String): [SegregatedStorage]
}

input SegregatedStorageSortInput {
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type SettingsQueries {
  defaultFirmId: String
  infoForUser(type: String, id: String): UserInfo
}

enum SortEnumType {
  ASC
  DESC
}

type Speciality {
  _raw_json_name: String
  name: [Locale]
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SpecialityCollectionSegment {
  items: [Speciality]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SpecialityFilterInput {
  and: [SpecialityFilterInput!]
  or: [SpecialityFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input SpecialityInput {
  name: [LocaleInput!]!
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SpecialityMutation {
  add(model: [SpecialityInput]): [Speciality]
  update(model: [SpecialityInput]): [Speciality]
  addOrUpdate(model: [SpecialityInput]): [Speciality]
  delete(model: [SpecialityInput]): [Speciality]
}

type SpecialityQuery {
  all(skip: Int, take: Int, where: SpecialityFilterInput, order: [SpecialitySortInput!]): SpecialityCollectionSegment
  userInfo(model: SpecialityInput): UserInfo
  getByKeys(id: String): [Speciality]
}

input SpecialitySortInput {
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type StatusHistory {
  status: Int!
  date: DateTime!
}

input StatusHistoryFilterInput {
  and: [StatusHistoryFilterInput!]
  or: [StatusHistoryFilterInput!]
  status: ComparableInt32OperationFilterInput
  date: ComparableDateTimeOperationFilterInput
}

input StatusHistoryInput {
  status: Int!
  date: DateTime!
}

type Store {
  firmId: String
  structureId: String
  type: Int
  typeFrame: Int
  isBase: Boolean
  isVirtual: Boolean
  isSupplierReturn: Boolean
  number: String
  _raw_json_name: String
  name: [Locale]
  info: String
  firmEmployeeId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm
  structure: Structure
  firmEmployee: FirmEmployee
}

type StoreBase {
  id: String
  number: String
  name: [Locale!]!
}

input StoreBaseFilterInput {
  and: [StoreBaseFilterInput!]
  or: [StoreBaseFilterInput!]
  id: StringOperationFilterInput
  number: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
}

input StoreBaseInput {
  id: String
  number: String
  name: [LocaleInput!]!
}

input StoreBaseSortInput {
  id: SortEnumType
  number: SortEnumType
}

type StoreCollectionSegment {
  items: [Store]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type StoreCondition {
  code: String
  _raw_json_name: String
  name: [Locale]
  temperatureMin: Decimal
  temperatureMax: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type StoreConditionCollectionSegment {
  items: [StoreCondition]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input StoreConditionFilterInput {
  and: [StoreConditionFilterInput!]
  or: [StoreConditionFilterInput!]
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  temperatureMin: ComparableNullableOfDecimalOperationFilterInput
  temperatureMax: ComparableNullableOfDecimalOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input StoreConditionInput {
  code: String
  name: [LocaleInput!]!
  temperatureMin: Decimal
  temperatureMax: Decimal
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type StoreConditionMutation {
  add(model: [StoreConditionInput]): [StoreCondition]
  update(model: [StoreConditionInput]): [StoreCondition]
  addOrUpdate(model: [StoreConditionInput]): [StoreCondition]
  delete(model: [StoreConditionInput]): [StoreCondition]
}

type StoreConditionQuery {
  all(skip: Int, take: Int, where: StoreConditionFilterInput, order: [StoreConditionSortInput!]): StoreConditionCollectionSegment
  userInfo(model: StoreConditionInput): UserInfo
  getByKeys(id: String): [StoreCondition]
}

input StoreConditionSortInput {
  code: SortEnumType
  temperatureMin: SortEnumType
  temperatureMax: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input StoreFilterInput {
  and: [StoreFilterInput!]
  or: [StoreFilterInput!]
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  structureId: StringOperationFilterInput
  structure: StructureFilterInput
  type: ComparableInt32OperationFilterInput
  typeFrame: ComparableInt32OperationFilterInput
  isBase: BooleanOperationFilterInput
  isVirtual: BooleanOperationFilterInput
  isSupplierReturn: BooleanOperationFilterInput
  number: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  firmEmployeeId: StringOperationFilterInput
  firmEmployee: FirmEmployeeFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

type StoreFrame {
  parentId: String
  storeId: String
  type: Int
  code: String
  _raw_json_name: String
  name: [Locale]
  storeConditionId: String
  info: String
  segregatedStorageId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: StoreFrame!
  store: Store!
  storeCondition: StoreCondition!
  segregatedStorage: SegregatedStorage!
}

type StoreFrameCollectionSegment {
  items: [StoreFrame]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input StoreFrameFilterInput {
  and: [StoreFrameFilterInput!]
  or: [StoreFrameFilterInput!]
  parentId: StringOperationFilterInput
  parent: StoreFrameFilterInput
  storeId: StringOperationFilterInput
  store: StoreFilterInput
  type: ComparableInt32OperationFilterInput
  code: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  storeConditionId: StringOperationFilterInput
  storeCondition: StoreConditionFilterInput
  info: StringOperationFilterInput
  segregatedStorageId: StringOperationFilterInput
  segregatedStorage: SegregatedStorageFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input StoreFrameInput {
  parentId: String
  storeId: String
  type: Int
  code: String
  name: [LocaleInput!]!
  storeConditionId: String
  info: String
  segregatedStorageId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type StoreFrameMutation {
  add(model: [StoreFrameInput]): [StoreFrame]
  update(model: [StoreFrameInput]): [StoreFrame]
  addOrUpdate(model: [StoreFrameInput]): [StoreFrame]
  delete(model: [StoreFrameInput]): [StoreFrame]
}

type StoreFrameProduct {
  productId: String
  storeFrameId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  product: Product
  storeFrame: StoreFrame!
}

type StoreFrameProductCollectionSegment {
  items: [StoreFrameProduct]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input StoreFrameProductFilterInput {
  and: [StoreFrameProductFilterInput!]
  or: [StoreFrameProductFilterInput!]
  productId: StringOperationFilterInput
  product: ProductFilterInput
  storeFrameId: StringOperationFilterInput
  storeFrame: StoreFrameFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input StoreFrameProductInput {
  productId: String
  storeFrameId: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type StoreFrameProductMutation {
  add(model: [StoreFrameProductInput]): [StoreFrameProduct]
  update(model: [StoreFrameProductInput]): [StoreFrameProduct]
  addOrUpdate(model: [StoreFrameProductInput]): [StoreFrameProduct]
  delete(model: [StoreFrameProductInput]): [StoreFrameProduct]
}

type StoreFrameProductQuery {
  all(skip: Int, take: Int, where: StoreFrameProductFilterInput, order: [StoreFrameProductSortInput!]): StoreFrameProductCollectionSegment
  userInfo(model: StoreFrameProductInput): UserInfo
  getByKeys(productId: String, storeFrameId: String): [StoreFrameProduct]
}

input StoreFrameProductSortInput {
  productId: SortEnumType
  product: ProductSortInput
  storeFrameId: SortEnumType
  storeFrame: StoreFrameSortInput
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type StoreFrameQuery {
  all(skip: Int, take: Int, where: StoreFrameFilterInput, order: [StoreFrameSortInput!]): StoreFrameCollectionSegment
  userInfo(model: StoreFrameInput): UserInfo
  getByKeys(id: String): [StoreFrame]
}

input StoreFrameSortInput {
  parentId: SortEnumType
  parent: StoreFrameSortInput
  storeId: SortEnumType
  store: StoreSortInput
  type: SortEnumType
  code: SortEnumType
  storeConditionId: SortEnumType
  storeCondition: StoreConditionSortInput
  info: SortEnumType
  segregatedStorageId: SortEnumType
  segregatedStorage: SegregatedStorageSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input StoreInput {
  firmId: String
  structureId: String
  type: Int
  typeFrame: Int
  isBase: Boolean
  isVirtual: Boolean
  isSupplierReturn: Boolean
  number: String
  name: [LocaleInput!]
  info: String
  firmEmployeeId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type StoreMutation {
  add(model: [StoreInput]): [Store]
  update(model: [StoreInput]): [Store]
  addOrUpdate(model: [StoreInput]): [Store]
  delete(model: [StoreInput]): [Store]
}

type StoreQuery {
  all(skip: Int, take: Int, where: StoreFilterInput, order: [StoreSortInput!]): StoreCollectionSegment
  userInfo(model: StoreInput): UserInfo
  getByKeys(id: String): [Store]
}

input StoreSortInput {
  firmId: SortEnumType
  firm: FirmSortInput
  structureId: SortEnumType
  structure: StructureSortInput
  type: SortEnumType
  typeFrame: SortEnumType
  isBase: SortEnumType
  isVirtual: SortEnumType
  isSupplierReturn: SortEnumType
  number: SortEnumType
  info: SortEnumType
  firmEmployeeId: SortEnumType
  firmEmployee: FirmEmployeeSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

type Structure {
  firmId: String
  number: String
  type: Int
  _raw_json_name: String
  name: [Locale]
  locationAddress: String
  addressId: String
  isOffice: Boolean
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firm: Firm!
  address: Address
}

type StructureBase {
  id: String
  number: String
  name: [Locale!]!
  locationAddress: String
}

input StructureBaseFilterInput {
  and: [StructureBaseFilterInput!]
  or: [StructureBaseFilterInput!]
  id: StringOperationFilterInput
  number: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  locationAddress: StringOperationFilterInput
}

input StructureBaseInput {
  id: String
  number: String
  name: [LocaleInput!]!
  locationAddress: String
}

input StructureBaseSortInput {
  id: SortEnumType
  number: SortEnumType
  locationAddress: SortEnumType
}

type StructureCollectionSegment {
  items: [Structure]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input StructureFilterInput {
  and: [StructureFilterInput!]
  or: [StructureFilterInput!]
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  number: StringOperationFilterInput
  type: ComparableInt32OperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  locationAddress: StringOperationFilterInput
  addressId: StringOperationFilterInput
  address: AddressFilterInput
  isOffice: BooleanOperationFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input StructureInput {
  firmId: String
  number: String
  type: Int
  name: [LocaleInput!]!
  locationAddress: String
  addressId: String
  isOffice: Boolean
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type StructureMutation {
  add(model: [StructureInput]): [Structure]
  update(model: [StructureInput]): [Structure]
  addOrUpdate(model: [StructureInput]): [Structure]
  delete(model: [StructureInput]): [Structure]
}

type StructureQuery {
  all(skip: Int, take: Int, where: StructureFilterInput, order: [StructureSortInput!]): StructureCollectionSegment
  userInfo(model: StructureInput): UserInfo
  getByKeys(id: String): [Structure]
}

input StructureSortInput {
  firmId: SortEnumType
  firm: FirmSortInput
  number: SortEnumType
  type: SortEnumType
  locationAddress: SortEnumType
  addressId: SortEnumType
  address: AddressSortInput
  isOffice: SortEnumType
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Substance {
  parentId: String
  _raw_json_name: String
  name: [Locale]
  code: String
  recipe: String
  info: String
  level: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  parent: Substance
}

type SubstanceCollectionSegment {
  items: [Substance]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SubstanceFilterInput {
  and: [SubstanceFilterInput!]
  or: [SubstanceFilterInput!]
  parentId: StringOperationFilterInput
  parent: SubstanceFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  code: StringOperationFilterInput
  recipe: StringOperationFilterInput
  info: StringOperationFilterInput
  level: ComparableInt32OperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input SubstanceInput {
  parentId: String
  name: [LocaleInput!]!
  code: String
  recipe: String
  info: String
  level: Int
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SubstanceMutation {
  add(model: [SubstanceInput]): [Substance]
  update(model: [SubstanceInput]): [Substance]
  addOrUpdate(model: [SubstanceInput]): [Substance]
  delete(model: [SubstanceInput]): [Substance]
}

type SubstanceQuery {
  all(skip: Int, take: Int, where: SubstanceFilterInput, order: [SubstanceSortInput!]): SubstanceCollectionSegment
  userInfo(model: SubstanceInput): UserInfo
  getByKeys(id: String): [Substance]
}

input SubstanceSortInput {
  parentId: SortEnumType
  parent: SubstanceSortInput
  code: SortEnumType
  recipe: SortEnumType
  info: SortEnumType
  level: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type Symptom {
  _raw_json_name: String
  name: [Locale]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SymptomCollectionSegment {
  items: [Symptom]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SymptomFilterInput {
  and: [SymptomFilterInput!]
  or: [SymptomFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input SymptomInput {
  name: [LocaleInput]
  info: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SymptomMutation {
  add(model: [SymptomInput]): [Symptom]
  update(model: [SymptomInput]): [Symptom]
  addOrUpdate(model: [SymptomInput]): [Symptom]
  delete(model: [SymptomInput]): [Symptom]
}

type SymptomQuery {
  all(skip: Int, take: Int, where: SymptomFilterInput, order: [SymptomSortInput!]): SymptomCollectionSegment
  userInfo(model: SymptomInput): UserInfo
  getByKeys(id: String): [Symptom]
}

input SymptomSortInput {
  info: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type SystemSettings {
  key: String
  value: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SystemSettingsCollectionSegment {
  items: [SystemSettings]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input SystemSettingsFilterInput {
  and: [SystemSettingsFilterInput!]
  or: [SystemSettingsFilterInput!]
  key: StringOperationFilterInput
  value: StringOperationFilterInput
  info: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input SystemSettingsInput {
  key: String
  value: String
  info: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type SystemSettingsMutation {
  add(model: [SystemSettingsInput]): [SystemSettings]
  update(model: [SystemSettingsInput]): [SystemSettings]
  addOrUpdate(model: [SystemSettingsInput]): [SystemSettings]
  delete(model: [SystemSettingsInput]): [SystemSettings]
}

type SystemSettingsQuery {
  all(skip: Int, take: Int, where: SystemSettingsFilterInput, order: [SystemSettingsSortInput!]): SystemSettingsCollectionSegment
  userInfo(model: SystemSettingsInput): UserInfo
  getByKeys(key: String): [SystemSettings]
}

input SystemSettingsSortInput {
  key: SortEnumType
  value: SortEnumType
  info: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type TaskJournal {
  status: TaskStatus
  result: String
  name: String
  dateTimeStart: DateTime
  taskType: TaskType
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type TaskJournalCollectionSegment {
  items: [TaskJournal]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input TaskJournalFilterInput {
  and: [TaskJournalFilterInput!]
  or: [TaskJournalFilterInput!]
  status: TaskStatusOperationFilterInput
  result: StringOperationFilterInput
  name: StringOperationFilterInput
  dateTimeStart: ComparableDateTimeOperationFilterInput
  taskType: TaskTypeOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input TaskJournalInput {
  status: TaskStatus
  result: String
  name: String
  dateTimeStart: DateTime
  taskType: TaskType
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type TaskJournalMutation {
  add(model: [TaskJournalInput]): [TaskJournal]
  update(model: [TaskJournalInput]): [TaskJournal]
  addOrUpdate(model: [TaskJournalInput]): [TaskJournal]
  delete(model: [TaskJournalInput]): [TaskJournal]
}

type TaskJournalMutations {
  createTask(name: String, type: TaskType!, dateStart: DateTime!): Boolean!
}

type TaskJournalQuery {
  all(skip: Int, take: Int, where: TaskJournalFilterInput, order: [TaskJournalSortInput!]): TaskJournalCollectionSegment
  userInfo(model: TaskJournalInput): UserInfo
  getByKeys(id: String): [TaskJournal]
}

input TaskJournalSortInput {
  status: SortEnumType
  result: SortEnumType
  name: SortEnumType
  dateTimeStart: SortEnumType
  taskType: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

enum TaskStatus {
  NEW
  IN_PROGRESS
  PENDING
  CANCEL
  ERROR
  DONE
}

input TaskStatusOperationFilterInput {
  eq: TaskStatus
  neq: TaskStatus
  in: [TaskStatus!]
  nin: [TaskStatus!]
}

enum TaskType {
  EXPORT_TIME_SHEETS_TO_BACK_OFFICE
  EXPORT_KPI_TO_BACK_OFFICE
  EXPORT_PLAN_BONUS_TO_BACK_OFFICE
  EXPORT_DOCUMENTS_TO_BACK_OFFICE
}

input TaskTypeOperationFilterInput {
  eq: TaskType
  neq: TaskType
  in: [TaskType!]
  nin: [TaskType!]
}

type TaxRate {
  dateAction: DateTime
  codeNum: CodeNum
  codeChar: String
  _raw_json_name: String
  name: [Locale]
  value: Decimal
  addTaxRateId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  addTaxRate: TaxRate
}

type TaxRateBase {
  id: String
  codeNum: CodeNum!
  codeChar: String
  value: Decimal!
  name: [Locale!]!
}

input TaxRateBaseFilterInput {
  and: [TaxRateBaseFilterInput!]
  or: [TaxRateBaseFilterInput!]
  id: StringOperationFilterInput
  codeNum: CodeNumOperationFilterInput
  codeChar: StringOperationFilterInput
  value: ComparableDecimalOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
}

input TaxRateBaseInput {
  id: String
  codeNum: CodeNum!
  codeChar: String
  value: Decimal!
  name: [LocaleInput!]!
}

input TaxRateBaseSortInput {
  id: SortEnumType
  codeNum: SortEnumType
  codeChar: SortEnumType
  value: SortEnumType
}

type TaxRateCollectionSegment {
  items: [TaxRate]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input TaxRateFilterInput {
  and: [TaxRateFilterInput!]
  or: [TaxRateFilterInput!]
  dateAction: ComparableDateTimeOperationFilterInput
  codeNum: CodeNumOperationFilterInput
  codeChar: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  value: ComparableDecimalOperationFilterInput
  addTaxRateId: StringOperationFilterInput
  addTaxRate: TaxRateFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input TaxRateInput {
  dateAction: DateTime
  codeNum: CodeNum
  codeChar: String
  name: [LocaleInput!]
  value: Decimal
  addTaxRateId: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type TaxRateMutation {
  add(model: [TaxRateInput]): [TaxRate]
  update(model: [TaxRateInput]): [TaxRate]
  addOrUpdate(model: [TaxRateInput]): [TaxRate]
  delete(model: [TaxRateInput]): [TaxRate]
}

type TaxRateQuery {
  all(skip: Int, take: Int, where: TaxRateFilterInput, order: [TaxRateSortInput!]): TaxRateCollectionSegment
  userInfo(model: TaxRateInput): UserInfo
  getByKeys(id: String): [TaxRate]
}

input TaxRateSortInput {
  dateAction: SortEnumType
  codeNum: SortEnumType
  codeChar: SortEnumType
  value: SortEnumType
  addTaxRateId: SortEnumType
  addTaxRate: TaxRateSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type TemplateData {
  _raw_json_name: String
  name: [Locale]
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type TemplateDataCollectionSegment {
  items: [TemplateData]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input TemplateDataFilterInput {
  and: [TemplateDataFilterInput!]
  or: [TemplateDataFilterInput!]
  name: ListFilterInputTypeOfLocaleFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input TemplateDataInput {
  name: [LocaleInput!]!
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type TemplateDataMutation {
  add(model: [TemplateDataInput]): [TemplateData]
  update(model: [TemplateDataInput]): [TemplateData]
  addOrUpdate(model: [TemplateDataInput]): [TemplateData]
  delete(model: [TemplateDataInput]): [TemplateData]
}

type TemplateDataQuery {
  all(skip: Int, take: Int, where: TemplateDataFilterInput, order: [TemplateDataSortInput!]): TemplateDataCollectionSegment
  userInfo(model: TemplateDataInput): UserInfo
  getByKeys(id: String): [TemplateData]
}

input TemplateDataSortInput {
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

enum TimesheetAbsenceReasonType {
  NO_REASON
  WEEKEND
  HOLIDAY
  VACATION
  MATERNITY_LEAVE
  ADMIN_VACATION
  BUSINESS_TRIP
  SICK_LEAVE
  QUIET
}

input TimesheetAbsenceReasonTypeOperationFilterInput {
  eq: TimesheetAbsenceReasonType
  neq: TimesheetAbsenceReasonType
  in: [TimesheetAbsenceReasonType!]
  nin: [TimesheetAbsenceReasonType!]
}

type TimesheetDaySummaryStatistics {
  holidayHours: Decimal!
  nightlyHours: Decimal!
  workHours: Decimal!
  normalWorkHours: Decimal!
  deviationWorkHours: Decimal!
  isShortDay: Boolean!
  isHoliday: Boolean!
  isWeekend: Boolean!
}

input TimesheetDaySummaryStatisticsFilterInput {
  and: [TimesheetDaySummaryStatisticsFilterInput!]
  or: [TimesheetDaySummaryStatisticsFilterInput!]
  holidayHours: ComparableDecimalOperationFilterInput
  nightlyHours: ComparableDecimalOperationFilterInput
  workHours: ComparableDecimalOperationFilterInput
  normalWorkHours: ComparableDecimalOperationFilterInput
  deviationWorkHours: ComparableDecimalOperationFilterInput
  isShortDay: BooleanOperationFilterInput
  isHoliday: BooleanOperationFilterInput
  isWeekend: BooleanOperationFilterInput
}

type TimesheetEmployeeDailyHoursInfo {
  hours: Decimal!
  timesheetAbsenceReason: TimesheetAbsenceReasonType!
}

input TimesheetEmployeeDailyHoursInfoFilterInput {
  and: [TimesheetEmployeeDailyHoursInfoFilterInput!]
  or: [TimesheetEmployeeDailyHoursInfoFilterInput!]
  hours: ComparableDecimalOperationFilterInput
  timesheetAbsenceReason: TimesheetAbsenceReasonTypeOperationFilterInput
}

type TimesheetEmployeeFieldsModel {
  personalNumber: String
  fullName: String
  isActing: Boolean!
  employmentType: Int!
  postName: String
  workSchedule: Decimal!
  lastWorkDay: DateTime
  dailyHoursInfo: [TimesheetEmployeeDailyHoursInfo!]!
  nightlyHours: [Decimal!]!
  dailyStatistics: TimesheetEmployeeFullComputedStatistics!
  nightlyStatistics: TimesheetEmployeeShortComputedStatistics!
}

input TimesheetEmployeeFieldsModelFilterInput {
  and: [TimesheetEmployeeFieldsModelFilterInput!]
  or: [TimesheetEmployeeFieldsModelFilterInput!]
  personalNumber: StringOperationFilterInput
  fullName: StringOperationFilterInput
  isActing: BooleanOperationFilterInput
  employmentType: ComparableInt32OperationFilterInput
  postName: StringOperationFilterInput
  workSchedule: ComparableDecimalOperationFilterInput
  lastWorkDay: ComparableNullableOfDateTimeOperationFilterInput
  dailyHoursInfo: ListFilterInputTypeOfTimesheetEmployeeDailyHoursInfoFilterInput
  nightlyHours: ListComparableDecimalOperationFilterInput
  dailyStatistics: TimesheetEmployeeFullComputedStatisticsFilterInput
  nightlyStatistics: TimesheetEmployeeShortComputedStatisticsFilterInput
}

type TimesheetEmployeeFullComputedStatistics {
  vacationDays: Int!
  sickLeaveDays: Int!
  maternityLeaveDays: Int!
  businessTripDays: Int!
  adminVacationDays: Int!
  leaveDays: Int!
  overTimeHours: Decimal!
  workDays: Int!
  weekendWorkDays: Int!
  weekendWorkHours: Decimal!
  holidayWorkDays: Int!
  holidayWorkHours: Decimal!
  totalHours: Decimal!
}

input TimesheetEmployeeFullComputedStatisticsFilterInput {
  and: [TimesheetEmployeeFullComputedStatisticsFilterInput!]
  or: [TimesheetEmployeeFullComputedStatisticsFilterInput!]
  vacationDays: ComparableInt32OperationFilterInput
  sickLeaveDays: ComparableInt32OperationFilterInput
  maternityLeaveDays: ComparableInt32OperationFilterInput
  businessTripDays: ComparableInt32OperationFilterInput
  adminVacationDays: ComparableInt32OperationFilterInput
  leaveDays: ComparableInt32OperationFilterInput
  overTimeHours: ComparableDecimalOperationFilterInput
  workDays: ComparableInt32OperationFilterInput
  weekendWorkDays: ComparableInt32OperationFilterInput
  weekendWorkHours: ComparableDecimalOperationFilterInput
  holidayWorkDays: ComparableInt32OperationFilterInput
  holidayWorkHours: ComparableDecimalOperationFilterInput
  totalHours: ComparableDecimalOperationFilterInput
}

input TimesheetEmployeeFullComputedStatisticsSortInput {
  vacationDays: SortEnumType
  sickLeaveDays: SortEnumType
  maternityLeaveDays: SortEnumType
  businessTripDays: SortEnumType
  adminVacationDays: SortEnumType
  leaveDays: SortEnumType
  overTimeHours: SortEnumType
  workDays: SortEnumType
  weekendWorkDays: SortEnumType
  weekendWorkHours: SortEnumType
  holidayWorkDays: SortEnumType
  holidayWorkHours: SortEnumType
  totalHours: SortEnumType
}

type TimesheetEmployeeShortComputedStatistics {
  workDays: Int!
  weekendWorkDays: Int!
  weekendWorkHours: Decimal!
  holidayWorkDays: Int!
  holidayWorkHours: Decimal!
  totalHours: Decimal!
}

input TimesheetEmployeeShortComputedStatisticsFilterInput {
  and: [TimesheetEmployeeShortComputedStatisticsFilterInput!]
  or: [TimesheetEmployeeShortComputedStatisticsFilterInput!]
  workDays: ComparableInt32OperationFilterInput
  weekendWorkDays: ComparableInt32OperationFilterInput
  weekendWorkHours: ComparableDecimalOperationFilterInput
  holidayWorkDays: ComparableInt32OperationFilterInput
  holidayWorkHours: ComparableDecimalOperationFilterInput
  totalHours: ComparableDecimalOperationFilterInput
}

type TimesheetFieldsModel {
  daysInMonth: Int!
  workDaysInMonth: Int!
  month: DateTime!
  employees: [TimesheetEmployeeFieldsModel!]!
  statistics: TimesheetTotalStatistics!
}

input TimesheetFieldsModelFilterInput {
  and: [TimesheetFieldsModelFilterInput!]
  or: [TimesheetFieldsModelFilterInput!]
  daysInMonth: ComparableInt32OperationFilterInput
  workDaysInMonth: ComparableInt32OperationFilterInput
  month: ComparableDateTimeOperationFilterInput
  employees: ListFilterInputTypeOfTimesheetEmployeeFieldsModelFilterInput
  statistics: TimesheetTotalStatisticsFilterInput
}

input TimesheetFieldsModelSortInput {
  daysInMonth: SortEnumType
  workDaysInMonth: SortEnumType
  month: SortEnumType
  statistics: TimesheetTotalStatisticsSortInput
}

type TimesheetModel {
  structureId: String
  firmId: String
  status: TimesheetStatusType!
  month: DateTime!
  fieldsJson: TimesheetFieldsModel!
  id: String!
  isDeleted: Boolean!
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type TimesheetModelCollectionSegment {
  items: [TimesheetModel]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input TimesheetModelFilterInput {
  and: [TimesheetModelFilterInput!]
  or: [TimesheetModelFilterInput!]
  structureId: StringOperationFilterInput
  firmId: StringOperationFilterInput
  status: TimesheetStatusTypeOperationFilterInput
  month: ComparableDateTimeOperationFilterInput
  fieldsJson: TimesheetFieldsModelFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input TimesheetModelSortInput {
  structureId: SortEnumType
  firmId: SortEnumType
  status: SortEnumType
  month: SortEnumType
  fieldsJson: TimesheetFieldsModelSortInput
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type TimesheetMutations {
  changeStatus(model: ChangeStatusAsyncParametersInput): TimesheetModel
  saveTimesheet(timesheetId: String, model: ClientTimesheetModelInput): TimesheetModel
}

type TimesheetQueries {
  timesheets(skip: Int, take: Int, where: TimesheetModelFilterInput, order: [TimesheetModelSortInput!]): TimesheetModelCollectionSegment
  timesheet(structureId: String, month: DateTime!): TimesheetModel
}

enum TimesheetStatusType {
  DRAFT
  OPENED
  CLOSED
}

input TimesheetStatusTypeOperationFilterInput {
  eq: TimesheetStatusType
  neq: TimesheetStatusType
  in: [TimesheetStatusType!]
  nin: [TimesheetStatusType!]
}

type TimesheetTotalStatistics {
  totalHolidayHours: Decimal!
  totalNightlyHours: Decimal!
  totalWorkHours: Decimal!
  totalNormalWorkHours: Decimal!
  totalDeviationWorkHours: Decimal!
  dailyStatistics: [TimesheetDaySummaryStatistics!]!
  totalDailyStatistics: TimesheetEmployeeFullComputedStatistics!
}

input TimesheetTotalStatisticsFilterInput {
  and: [TimesheetTotalStatisticsFilterInput!]
  or: [TimesheetTotalStatisticsFilterInput!]
  totalHolidayHours: ComparableDecimalOperationFilterInput
  totalNightlyHours: ComparableDecimalOperationFilterInput
  totalWorkHours: ComparableDecimalOperationFilterInput
  totalNormalWorkHours: ComparableDecimalOperationFilterInput
  totalDeviationWorkHours: ComparableDecimalOperationFilterInput
  dailyStatistics: ListFilterInputTypeOfTimesheetDaySummaryStatisticsFilterInput
  totalDailyStatistics: TimesheetEmployeeFullComputedStatisticsFilterInput
}

input TimesheetTotalStatisticsSortInput {
  totalHolidayHours: SortEnumType
  totalNightlyHours: SortEnumType
  totalWorkHours: SortEnumType
  totalNormalWorkHours: SortEnumType
  totalDeviationWorkHours: SortEnumType
  totalDailyStatistics: TimesheetEmployeeFullComputedStatisticsSortInput
}

type TotalResults {
  skuQty: Int!
  packageQty: Decimal!
  totalSum: Decimal!
}

enum Type {
  FISCAL
  SCALE
  TERMINAL
  SCANNER
  SCALE_SCANNER
}

input TypeOperationFilterInput {
  eq: Type
  neq: Type
  in: [Type!]
  nin: [Type!]
}

type Unit {
  codeNum: Int
  codeChar: String
  shortLoc: String
  shortIntl: String
  _raw_json_name: String
  name: [Locale]
  info: String
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type UnitBase {
  id: String
  codeNum: Int!
  shortLoc: String
}

input UnitBaseFilterInput {
  and: [UnitBaseFilterInput!]
  or: [UnitBaseFilterInput!]
  id: StringOperationFilterInput
  codeNum: ComparableInt32OperationFilterInput
  shortLoc: StringOperationFilterInput
}

input UnitBaseInput {
  id: String
  codeNum: Int!
  shortLoc: String
}

input UnitBaseSortInput {
  id: SortEnumType
  codeNum: SortEnumType
  shortLoc: SortEnumType
}

type UnitCollectionSegment {
  items: [Unit]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input UnitFilterInput {
  and: [UnitFilterInput!]
  or: [UnitFilterInput!]
  codeNum: ComparableInt32OperationFilterInput
  codeChar: StringOperationFilterInput
  shortLoc: StringOperationFilterInput
  shortIntl: StringOperationFilterInput
  name: ListFilterInputTypeOfLocaleFilterInput
  info: StringOperationFilterInput
  isUse: BooleanOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input UnitInput {
  codeNum: Int
  codeChar: String
  shortLoc: String
  shortIntl: String
  name: [LocaleInput!]
  info: String
  isUse: Boolean
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type UnitMutation {
  add(model: [UnitInput]): [Unit]
  update(model: [UnitInput]): [Unit]
  addOrUpdate(model: [UnitInput]): [Unit]
  delete(model: [UnitInput]): [Unit]
}

type UnitQuery {
  all(skip: Int, take: Int, where: UnitFilterInput, order: [UnitSortInput!]): UnitCollectionSegment
  userInfo(model: UnitInput): UserInfo
  getByKeys(id: String): [Unit]
}

input UnitSortInput {
  codeNum: SortEnumType
  codeChar: SortEnumType
  shortLoc: SortEnumType
  shortIntl: SortEnumType
  info: SortEnumType
  isUse: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type User {
  id: String
  username: String
  password: String
  employeeCode: String
  refreshToken: String
  firmEmployeeId: String
  isAuthorizeCashbox: Boolean
  isPharmacyManager: Boolean
  cashboxPermitId: String
  cardNumber: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  firmEmployee: FirmEmployee
  cashboxPermit: CashboxPermit
}

type UserCollectionSegment {
  items: [User]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

type UserData {
  userId: String
  templateDataId: String
  tableName: String
  fieldName: String
  value: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  templateData: TemplateData!
}

type UserDataCollectionSegment {
  items: [UserData]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input UserDataFilterInput {
  and: [UserDataFilterInput!]
  or: [UserDataFilterInput!]
  userId: StringOperationFilterInput
  templateDataId: StringOperationFilterInput
  templateData: TemplateDataFilterInput
  tableName: StringOperationFilterInput
  fieldName: StringOperationFilterInput
  value: StringOperationFilterInput
  id: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input UserDataInput {
  userId: String
  templateDataId: String
  tableName: String
  fieldName: String
  value: String
  id: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type UserDataMutation {
  add(model: [UserDataInput]): [UserData]
  update(model: [UserDataInput]): [UserData]
  addOrUpdate(model: [UserDataInput]): [UserData]
  delete(model: [UserDataInput]): [UserData]
}

type UserDataQuery {
  all(skip: Int, take: Int, where: UserDataFilterInput, order: [UserDataSortInput!]): UserDataCollectionSegment
  userInfo(model: UserDataInput): UserInfo
  getByKeys(id: String): [UserData]
}

input UserDataSortInput {
  userId: SortEnumType
  templateDataId: SortEnumType
  templateData: TemplateDataSortInput
  tableName: SortEnumType
  fieldName: SortEnumType
  value: SortEnumType
  id: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  id: StringOperationFilterInput
  username: StringOperationFilterInput
  password: StringOperationFilterInput
  employeeCode: StringOperationFilterInput
  refreshToken: StringOperationFilterInput
  firmEmployeeId: StringOperationFilterInput
  firmEmployee: FirmEmployeeFilterInput
  isAuthorizeCashbox: BooleanOperationFilterInput
  isPharmacyManager: BooleanOperationFilterInput
  cashboxPermitId: StringOperationFilterInput
  cashboxPermit: CashboxPermitFilterInput
  cardNumber: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

type UserInfo {
  createUser: User
  lastUpdateUser: User
  isDeleted: Boolean!
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

input UserInput {
  id: String
  username: String
  password: String
  employeeCode: String
  refreshToken: String
  firmEmployeeId: String
  isAuthorizeCashbox: Boolean
  isPharmacyManager: Boolean
  cashboxPermitId: String
  cardNumber: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type UserMutation {
  add(model: [UserInput]): [User]
  update(model: [UserInput]): [User]
  addOrUpdate(model: [UserInput]): [User]
  delete(model: [UserInput]): [User]
}

type UserQuery {
  all(skip: Int, take: Int, where: UserFilterInput, order: [UserSortInput!]): UserCollectionSegment
  userInfo(model: UserInput): UserInfo
  getByKeys(id: String): [User]
}

type UserRole {
  userId: String
  roleId: String
  reason: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  user: User!
  role: Role!
}

type UserRoleCollectionSegment {
  items: [UserRole]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input UserRoleFilterInput {
  and: [UserRoleFilterInput!]
  or: [UserRoleFilterInput!]
  userId: StringOperationFilterInput
  user: UserFilterInput
  roleId: StringOperationFilterInput
  role: RoleFilterInput
  reason: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input UserRoleInput {
  userId: String
  roleId: String
  reason: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type UserRoleMutation {
  add(model: [UserRoleInput]): [UserRole]
  update(model: [UserRoleInput]): [UserRole]
  addOrUpdate(model: [UserRoleInput]): [UserRole]
  delete(model: [UserRoleInput]): [UserRole]
}

type UserRoleQuery {
  all(skip: Int, take: Int, where: UserRoleFilterInput, order: [UserRoleSortInput!]): UserRoleCollectionSegment
  userInfo(model: UserRoleInput): UserInfo
  getByKeys(userId: String, roleId: String): [UserRole]
}

input UserRoleSortInput {
  userId: SortEnumType
  user: UserSortInput
  roleId: SortEnumType
  role: RoleSortInput
  reason: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

input UserSortInput {
  id: SortEnumType
  username: SortEnumType
  password: SortEnumType
  employeeCode: SortEnumType
  refreshToken: SortEnumType
  firmEmployeeId: SortEnumType
  firmEmployee: FirmEmployeeSortInput
  isAuthorizeCashbox: SortEnumType
  isPharmacyManager: SortEnumType
  cashboxPermitId: SortEnumType
  cashboxPermit: CashboxPermitSortInput
  cardNumber: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type UserTemplates {
  userId: String
  templateDataId: String
  reason: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
  user: User!
  templateData: TemplateData!
}

type UserTemplatesCollectionSegment {
  items: [UserTemplates]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input UserTemplatesFilterInput {
  and: [UserTemplatesFilterInput!]
  or: [UserTemplatesFilterInput!]
  userId: StringOperationFilterInput
  user: UserFilterInput
  templateDataId: StringOperationFilterInput
  templateData: TemplateDataFilterInput
  reason: StringOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  dateInsert: ComparableNullableOfDateTimeOperationFilterInput
  dateUpdate: ComparableNullableOfDateTimeOperationFilterInput
  createUserId: StringOperationFilterInput
  lastUpdateUserId: StringOperationFilterInput
}

input UserTemplatesInput {
  userId: String
  templateDataId: String
  reason: String
  isDeleted: Boolean
  dateInsert: DateTime
  dateUpdate: DateTime
  createUserId: String
  lastUpdateUserId: String
}

type UserTemplatesMutation {
  add(model: [UserTemplatesInput]): [UserTemplates]
  update(model: [UserTemplatesInput]): [UserTemplates]
  addOrUpdate(model: [UserTemplatesInput]): [UserTemplates]
  delete(model: [UserTemplatesInput]): [UserTemplates]
}

type UserTemplatesQuery {
  all(skip: Int, take: Int, where: UserTemplatesFilterInput, order: [UserTemplatesSortInput!]): UserTemplatesCollectionSegment
  userInfo(model: UserTemplatesInput): UserInfo
  getByKeys(userId: String, templateDataId: String): [UserTemplates]
}

input UserTemplatesSortInput {
  userId: SortEnumType
  user: UserSortInput
  templateDataId: SortEnumType
  templateData: TemplateDataSortInput
  reason: SortEnumType
  isDeleted: SortEnumType
  dateInsert: SortEnumType
  dateUpdate: SortEnumType
  createUserId: SortEnumType
  lastUpdateUserId: SortEnumType
}

type ViewQuantity {
  documentId: String
  globalCode: String
  status: Int
  direct: Int
  name: String
  number: String
  date: DateTime
  firmId: String
  firmStructureId: String
  firmStoreId: String
  cashboxId: String
  contractorId: String
  contractorStructureId: String
  contractId: String
  contractGlobalCode: String
  orderId: String
  orderGlobalCode: String
  currencyId: String
  sum: Decimal
  sumTax: Decimal
  parentDocumentId: String
  firm: Firm
  firmJson: Firm
  firmStructure: Structure
  firmStructureJson: Structure
  firmStore: Store
  firmStoreJson: StoreBase
  cashbox: Cashbox
  cashboxJson: Cashbox
  contractor: Firm
  contractorJson: Firm
  contractorStructure: Structure
  contractorStructureJson: Structure
  contract: Contract
  contractJson: Contract
  orderJson: OrderBase
  currency: Currency
}

type ViewQuantityCollectionSegment {
  items: [ViewQuantity]

  """Information to aid in pagination."""
  pageInfo: CollectionSegmentInfo!
  totalCount: Int!
}

input ViewQuantityFilterInput {
  and: [ViewQuantityFilterInput!]
  or: [ViewQuantityFilterInput!]
  documentId: StringOperationFilterInput
  globalCode: StringOperationFilterInput
  status: ComparableInt32OperationFilterInput
  direct: ComparableInt32OperationFilterInput
  name: StringOperationFilterInput
  number: StringOperationFilterInput
  date: ComparableDateTimeOperationFilterInput
  firmId: StringOperationFilterInput
  firm: FirmFilterInput
  firmJson: FirmFilterInput
  firmStructureId: StringOperationFilterInput
  firmStructure: StructureFilterInput
  firmStructureJson: StructureFilterInput
  firmStoreId: StringOperationFilterInput
  firmStore: StoreFilterInput
  firmStoreJson: StoreBaseFilterInput
  cashboxId: StringOperationFilterInput
  cashbox: CashboxFilterInput
  cashboxJson: CashboxFilterInput
  contractorId: StringOperationFilterInput
  contractor: FirmFilterInput
  contractorJson: FirmFilterInput
  contractorStructureId: StringOperationFilterInput
  contractorStructure: StructureFilterInput
  contractorStructureJson: StructureFilterInput
  contractId: StringOperationFilterInput
  contract: ContractFilterInput
  contractGlobalCode: StringOperationFilterInput
  contractJson: ContractFilterInput
  orderId: StringOperationFilterInput
  orderGlobalCode: StringOperationFilterInput
  orderJson: OrderBaseFilterInput
  currencyId: StringOperationFilterInput
  currency: CurrencyFilterInput
  sum: ComparableDecimalOperationFilterInput
  sumTax: ComparableNullableOfDecimalOperationFilterInput
  parentDocumentId: StringOperationFilterInput
}

input ViewQuantityInput {
  documentId: String
  globalCode: String
  status: Int
  direct: Int
  name: String
  number: String
  date: DateTime
  firmId: String
  firmJson: FirmInput
  firmStructureId: String
  firmStructureJson: StructureInput
  firmStoreId: String
  firmStoreJson: StoreBaseInput
  cashboxId: String
  cashboxJson: CashboxInput
  contractorId: String
  contractorJson: FirmInput
  contractorStructureId: String
  contractorStructureJson: StructureInput
  contractId: String
  contractGlobalCode: String
  contractJson: ContractInput
  orderId: String
  orderGlobalCode: String
  orderJson: OrderBaseInput
  currencyId: String
  sum: Decimal
  sumTax: Decimal
  parentDocumentId: String
}

type ViewQuantityMutation {
  add(model: [ViewQuantityInput]): [ViewQuantity]
  update(model: [ViewQuantityInput]): [ViewQuantity]
  addOrUpdate(model: [ViewQuantityInput]): [ViewQuantity]
  delete(model: [ViewQuantityInput]): [ViewQuantity]
}

type ViewQuantityQuery {
  all(skip: Int, take: Int, where: ViewQuantityFilterInput, order: [ViewQuantitySortInput!]): ViewQuantityCollectionSegment
  userInfo(model: ViewQuantityInput): UserInfo
}

input ViewQuantitySortInput {
  documentId: SortEnumType
  globalCode: SortEnumType
  status: SortEnumType
  direct: SortEnumType
  name: SortEnumType
  number: SortEnumType
  date: SortEnumType
  firmId: SortEnumType
  firm: FirmSortInput
  firmJson: FirmSortInput
  firmStructureId: SortEnumType
  firmStructure: StructureSortInput
  firmStructureJson: StructureSortInput
  firmStoreId: SortEnumType
  firmStore: StoreSortInput
  firmStoreJson: StoreBaseSortInput
  cashboxId: SortEnumType
  cashbox: CashboxSortInput
  cashboxJson: CashboxSortInput
  contractorId: SortEnumType
  contractor: FirmSortInput
  contractorJson: FirmSortInput
  contractorStructureId: SortEnumType
  contractorStructure: StructureSortInput
  contractorStructureJson: StructureSortInput
  contractId: SortEnumType
  contract: ContractSortInput
  contractGlobalCode: SortEnumType
  contractJson: ContractSortInput
  orderId: SortEnumType
  orderGlobalCode: SortEnumType
  orderJson: OrderBaseSortInput
  currencyId: SortEnumType
  currency: CurrencySortInput
  sum: SortEnumType
  sumTax: SortEnumType
  parentDocumentId: SortEnumType
}

